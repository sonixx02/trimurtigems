var skim = {
	utils : {}

};
skim.utils.three = {};
skim.geometry = {};
skim.skel = {};
skim.parametrics = {};
skim.instances = {};
skim.tables = {};
skim.polygonizers = {};
skim.views = {};
skim.widgets3d = {};
skim.blobtree = {};
skim.threeUtils = {};
skim.importers = {};
skim.exporters = {};
skim.VolType = {
	Mech : 0,
	Orga : 1
};
skim.blobtree.iso_value = 1;
skim.blobtree.neutral_value = 0;
skim.CAMERA_TARGET_0 = 0;
skim.CAMERA_TARGET_SMART = 1;
skim.CAMERA_MODE = {
	Perspective : 1,
	Orthographic : 2,
	PXOrthographic : 3,
	NXOrthographic : 4,
	PYOrthographic : 5,
	NYOrthographic : 6,
	PZOrthographic : 7,
	NZOrthographic : 8
};
skim.DEFAULT_COLORS = {
	verticesColors : {
		defaultColor : 4550491,
		highlight : 16742263,
		symHighlight : 16682638,
		selected : 16667989,
		merged : 16711680,
		onSymPlane : 6921086
	},
	primitivesColors : {
		defaultColor : 4550491,
		highlight : 16742263,
		symHighlight : 16682638,
		selected : 16667989,
		merged : 16711680,
		onSymPlane : 6921086
	}
};
skim.SCREENSHOT = {
	NONE : 0,
	MASK : 1,
	NORMAL_MAP : 2
};
skim.init = function (a) {
	skim.utils.assert(void 0 === a.symPlane, "Error : symPlane has been renamed symPlaneX, please correct the code");
	skim.instances.skel = new skim.skel.Skeleton;
	skim.instances.defaultMaterial = new skim.Material(null, null, null);
	skim.instances.ressourcesPath = a.ressourcesPath.replace(/\/?$/, "/");
	skim.utils.assert(a.canvas, "skim init: canvas seems to be wrong");
	var b = a.canvas;
	skim.settings = {
		cameraTarget : void 0 !== a.cameraTarget ? a.cameraTarget : skim.CAMERA_TARGET_SMART,
		trackballHelper : void 0 !==
		a.trackballHelper ? a.trackballHelper : !0,
		colors : void 0 !== a.colors ? a.colors : skim.DEFAULT_COLORS,
		unit : void 0 !== a.unit ? a.unit : 0.1
	};
	var c = {
		colorFront : void 0 !== a.colorFront ? a.colorFront : 16777215,
		colorBack : void 0 !== a.colorBack ? a.colorBack : 16777215,
		shading : void 0 !== a.shading ? a.shading : "exp",
		environment : {
			skybox : void 0 !== a.skybox ? a.skybox : !1,
			name : void 0 !== a.envname ? a.envname : "none"
		},
		coef : 5
	};
	skim.utils.assert(a.statemachine, "skim init: statemachine seems to be wrong");
	var d = a.statemachine,
	e = void 0 !== a.pageInterface ?
		a.pageInterface : {},
	f = void 0 !== a.postInit ? a.postInit : function () {};
	console.log("Extending Transformer...");
	if (void 0 !== a.extendedSMfunctions) {
		for (var g = Object.keys(a.extendedSMfunctions), h = 0; h < g.length; ++h)
			void 0 !== Transformer[g] && console.log("... overwriting entry : " + g), Transformer[g] = a.extendedSMfunctions[g];
		console.log("... Done.")
	}
	g = function () {
		var b = skim.instances.modeler;
		b.sceneManager.setSymPlaneXVisible(void 0 !== a.symPlaneX ? a.symPlaneX : !1);
		b.sceneManager.setSymPlaneYVisible(void 0 !== a.symPlaneY ?
			a.symPlaneY : !1);
		b.sceneManager.setSymPlaneZVisible(void 0 !== a.symPlaneZ ? a.symPlaneZ : !1);
		b.sceneManager.setPedestalVisible(void 0 !== a.pedestal ? a.pedestal : !1);
		b.sceneManager.setHelperBoundingBoxVisible(void 0 !== a.helperBoundingBox ? a.helperBoundingBox : !1);
		void 0 !== a.symPlaneXColor && b.sceneManager.setSymPlaneXColor(a.symPlaneXColor);
		void 0 !== a.symPlaneYColor && b.sceneManager.setSymPlaneYColor(a.symPlaneYColor);
		void 0 !== a.symPlaneZColor && b.sceneManager.setSymPlaneZColor(a.symPlaneZColor);
		f()
	};
	skim.instances.modeler =
		new skim.MainModeler;
	skim.engine.init(void 0 === a.engine ? {}

		 : a.engine);
	try {
		return console.log("starting modeler init"),
		skim.instances.modeler.init(b, c, d, e, g, void 0 === a.initCamPos ? null : a.initCamPos, void 0 === a.rotcamSpeed ? null : a.rotcamSpeed)
	} catch (k) {
		return console.error("Failed to init modeler: ", k.message),
		!1
	}
};
skim.dispose = function () {
	skim.engine.clean();
	void 0 !== skim.instances.modeler && null !== skim.instances.modeler && skim.instances.modeler.dispose()
};
skim.Material = function (a, b, c) {
	this.color = null !== a ? a.clone() : new THREE.Color(11184810);
	this.roughness = null !== b ? b : 0;
	this.metallic = null !== c ? c : 0
};
skim.Material.prototype.clone = function () {
	return new skim.Material(this.color, this.roughness, this.metallic)
};
skim.Material.prototype.copy = function (a) {
	this.color.copy(a.color);
	this.roughness = a.roughness;
	this.metallic = a.metallic
};
skim.Material.prototype.set = function (a, b, c) {
	this.color.copy(a);
	this.roughness = b;
	this.metallic = c
};
skim.Material.prototype.getColor = function () {
	return this.color
};
skim.Material.prototype.getRoughness = function () {
	return this.roughness
};
skim.Material.prototype.getMetallic = function () {
	return this.metallic
};
skim.Material.prototype.equals = function (a) {
	return this.color.equals(a.color) && this.metallic === a.metallic && this.roughness === a.roughness
};
skim.Material.prototype.lerp = function (a, b) {
	this.color.lerp(a.color, b);
	this.roughness = (1 - b) * this.roughness + b * a.roughness;
	this.metallic = (1 - b) * this.metallic + b * a.metallic
};
skim.Material.prototype.triMean = function (a, b, c, d, e, f, g) {
	this.color.r = (d * a.color.r + e * b.color.r + f * c.color.r) / g;
	this.color.g = (d * a.color.g + e * b.color.g + f * c.color.g) / g;
	this.color.b = (d * a.color.b + e * b.color.b + f * c.color.b) / g;
	this.roughness = (d * a.roughness + e * b.roughness + f * c.roughness) / g;
	this.metallic = (d * a.metallic + e * b.metallic + f * c.metallic) / g;
	return this
};
skim.Material.prototype.weightedMean = function (a, b, c) {
	this.color.setRGB(0, 0, 0);
	this.metallic = this.roughness = 0;
	c = void 0 === c ? a.length : c;
	for (var d = 0, e = 0; e < c; ++e)
		this.color.r += b[e] * a[e].color.r, this.color.g += b[e] * a[e].color.g, this.color.b += b[e] * a[e].color.b, this.roughness += b[e] * a[e].roughness, this.metallic += b[e] * a[e].metallic, d += b[e];
	0 !== d ? (this.color.r /= d, this.color.g /= d, this.color.b /= d, this.roughness /= d, this.metallic /= d) : (this.color.r = 0, this.color.g = 0, this.metallic = this.roughness = this.color.b = 0);
	return this
};
skim.Material.buildFromJSON = function (a) {
	return new skim.Material(new THREE.Color(parseInt(a.c, 16)), a.r, a.m)
};
skim.Material.prototype.getJSON = function () {
	return function () {
		for (var a = this.color.getHex().toString(16), b = 6 - a.length, c = 0; c < b; ++c)
			a = "0" + a;
		return {
			c : "0x" + a,
			r : this.roughness,
			m : this.metallic
		}
	}
}
();
skim.Material.areEqualsArrays = function (a, b, c, d, e) {
	for (var f = !0, g = 1; g < arguments.length; g++)
		f = f && (null === a && null === arguments[g] || null !== a && null !== arguments[g]);
	if (!f)
		return f;
	if (null === a)
		return !0;
	for (g = 1; g < arguments.length; g++) {
		var h = !0;
		if (arguments[g].length !== a.length)
			return !1;
		for (var k = 0; k < a.length; ++k)
			h = h && a[k].equals(arguments[g][k]);
		f = f && h
	}
	return f
};
skim.shaders = {
	envMap : {
		vert : "varying vec3 vColor;\nvarying vec3 vNormal;\nvoid main ()\n{\n   vNormal = normalize(normalMatrix * normal);\n   /* vColor = vec4(0); */\n   vColor = color;\n   gl_Position = projectionMatrix * modelViewMatrix  * vec4(position,1.);\n}",
		frag : "varying vec3 vNormal;\nvarying vec3 vColor;\nuniform sampler2D uTexture;\nuniform vec3 uColor;\nvoid main ()\n{\n  vec2 index = vec2(0.5) + 0.5*normalize(vNormal).xy;\n  vec4 texel = texture2D(uTexture, index);\n  vec3 finalColor = texel.xyz;\n#ifdef MERGE_WITH_VERTEX_COLOR\n  if (vColor.x + vColor.y + vColor.z > 0.1)\n    /* finalColor = mix(texel.xyz,vColor,0.3); */\n    finalColor = clamp((texel.xyz+vColor)/1.45,0.,1.);\n    /* finalColor = normalize(texel.xyz*2.+vColor*0.5); */\n  else\n    finalColor = texel.xyz;\n#endif\n#ifdef MERGE_WITH_OBJECT_COLOR\n    // use overlay blending (like photoshop does)\n    // see http://www.pegtop.net/delphi/articles/blendmodes/overlay.htm\n    if(finalColor.x < 0.5){\n        finalColor.x = 2.0*finalColor.x*uColor.x;\n    }else{\n        finalColor.x = 1.0 - 2.0*(1.0 - finalColor.x)*(1.0 - uColor.x);\n    }\n    if(finalColor.y < 0.5){\n        finalColor.y = 2.0*finalColor.y*uColor.y;\n    }else{\n        finalColor.y = 1.0 - 2.0*(1.0 - finalColor.y)*(1.0 - uColor.y);\n    }\n    if(finalColor.z < 0.5){\n        finalColor.z = 2.0*finalColor.z*uColor.z;\n    }else{\n        finalColor.z = 1.0 - 2.0*(1.0 - finalColor.z)*(1.0 - uColor.z);\n    }\n#endif\n  gl_FragColor = vec4(finalColor,\n                      1.);\n}"
	},
	envMapDarken : {
		frag : "varying vec3 vNormal;\nvarying vec3 vColor;\nuniform sampler2D uTexture;\nvoid main ()\n{\n  vec2 index = vec2(0.5) + 0.5*normalize(vNormal).xy;\n  vec4 texel = texture2D(uTexture, index);\n  vec3 finalColor = texel.xyz;\n  float average = 1.0 - (vColor.x + vColor.y + vColor.z)/3.0;\n  finalColor.x = finalColor.x*average;\n  finalColor.y = finalColor.y*average;\n  finalColor.z = finalColor.z*average;\n  gl_FragColor = vec4(finalColor,\n                      1.);\n}"
	},
	saveEnvMapNormals : {
		frag : "varying vec3 vNormal;\nvarying vec3 vColor;\nvoid main ()\n{\n    gl_FragColor = vec4(0.5+0.5*normalize(vNormal),1.);\n}"
	},
	background : {
		vert : "uniform vec2 pointLightPosition;\n/* we rely on openGL interpolation in order to calculate distance from fragment to pointlight */\n/* this speeds up computation because the work is done in the vertex shader+rasterisation instead of the  */\n/* fragment shader */\nvarying vec2 vFragDistance;\nvarying float vMaxDistance;\nvoid main(void)\n{\n  /* vMaxDistance is the max distance to the four corners of the screen */\n  vMaxDistance=max(\n                   max(\n                       length(vec2(-1.,-1.)-pointLightPosition),\n                       length(vec2(-1.,1.)-pointLightPosition)\n                       ),\n                   max(\n                       length(vec2(1.,1.)-pointLightPosition),\n                       length(vec2(1.,-1.)-pointLightPosition)\n                       )\n                   );\n  /* transform to point light position space */\n  vFragDistance=vec2(position)-pointLightPosition;\n  /* max depth we can have in the frustum */\n  gl_Position = vec4 (vec2(position),1.,1.);\n}"
	},
	backgroundExp : {
		frag : "varying vec2 vFragDistance;\nvarying float vMaxDistance;\nuniform vec3 backgroundColor;\nuniform vec3 pointLightColor;\nuniform float uA;\nfloat coef (float dist)\n{\n  const float e=2.71828;\n  return pow(e,-dist*uA);\n}\nvoid main(void)\n{\n  /* max distance is 2*sqrt(2) coz we're dealing with coordinates from -1 to 1*/\n  float normalizedDist=length(vFragDistance)/vMaxDistance;\n  gl_FragColor = clamp(vec4((coef(normalizedDist))*pointLightColor+\n                            (1.-coef(normalizedDist))*backgroundColor,1.),0.,1.);\n  /* gl_FragColor = vec4(coef(normalizedDist), */\n  /*                     coef(normalizedDist), */\n  /*                     coef(normalizedDist), */\n  /*                     1.); */\n}"
	},
	backgroundLinear : {
		frag : "varying vec2 vFragDistance;\nvarying float vMaxDistance;\nuniform vec3 backgroundColor;\nuniform vec3 pointLightColor;\nuniform vec2 pointLightPosition;\nvoid main(void)\n{\n  float normalizedDist=length(vFragDistance)/vMaxDistance;\n  gl_FragColor = vec4((1.-normalizedDist)*pointLightColor+normalizedDist*backgroundColor,1.);\n}"
	},
	backgroundSin : {
		frag : "varying vec2 vFragDistance;\nvarying float vMaxDistance;\nuniform vec3 backgroundColor;\nuniform vec3 pointLightColor;\nuniform vec2 pointLightPosition;\nuniform float uA;\nfloat coef (float dist)\n{\n  return (sin(dist*uA)+1.)/2.;\n}\nvoid main(void)\n{\n  /* max distance is 2*sqrt(2) coz we're dealing with coordinates from -1 to 1*/\n  float a=100.;\n  float normalizedDist=length(vFragDistance)/vMaxDistance;\n  gl_FragColor = vec4(coef(1.-normalizedDist)*pointLightColor+\n                      coef(normalizedDist)*backgroundColor,1.);\n}"
	}
};
skim.loadShader = function (a, b, c) {
	console.warn("WARNING : skim.loadShader is deprecated, we load shaders statically now");
	skim.utils.assert("vert" === b || "frag" === b, "Error : shader type must be vert or frag");
	var d = new XMLHttpRequest;
	d.open("GET", skim.instances.ressourcesPath + "shaders/" + (a + "." + b), !0);
	d.onreadystatechange = function (a, b, d) {
		return function () {
			4 == this.readyState && (200 == this.status || 0 === this.status ? (void 0 === skim.shaders[b] && (skim.shaders[b] = {}), skim.shaders[b][d] = this.responseText, c()) : console.log("failed to load shader " +
					b))
		}
	}
	(d, a, b);
	d.send(null)
};
skim.textures = {
	caps : {
		brass : {
			path : "img/envMaps/print_imat_brass.png",
			texture : null
		},
		bronze : {
			path : "img/envMaps/print_imat_bronze.png",
			texture : null
		},
		silverhg : {
			path : "img/envMaps/print_imat_silver_highgloss.png",
			texture : null
		},
		silverg : {
			path : "img/envMaps/print_imat_silver_gloss.png",
			texture : null
		},
		silversb : {
			path : "img/envMaps/print_imat_silver_sandblasted.png",
			texture : null
		},
		steel : {
			path : "img/envMaps/print_imat_steel.png",
			texture : null
		},
		titanium : {
			path : "img/envMaps/print_imat_titanium.png",
			texture : null
		},
		gold : {
			path : "img/envMaps/print_imat_gold.png",
			texture : null
		},
		gold_red : {
			path : "img/envMaps/print_imat_gold_pink.png",
			texture : null
		},
		gold_white : {
			path : "img/envMaps/print_imat_gold_white.png",
			texture : null
		},
		gold_plated : {
			path : "img/envMaps/print_imat_gold_plated.png",
			texture : null
		},
		normals : {
			path : "img/envMaps/normals.jpg",
			texture : null
		},
		skim_vertices_widget : {
			path : "img/envMaps/skim_vertices_widget.png",
			texture : null
		},
		skim_primitives_widget : {
			path : "img/envMaps/skim_primitives_widget.png",
			texture : null
		}
	}
};
skim.getGeneralEnvMapFunction = function (a, b, c) {
	return function () {
		var d = null;
		return function (e) {
			var f = {
				mat : d,
				textures : [skim.textures.caps[a].texture]
			};
			if (null !== d)
				return e(f), d;
			skim.utils.assert(void 0 !== skim.textures.caps[a], "Error : cannot build envmap material without the texture slot defined");
			null === skim.textures.caps[a].texture && (skim.textures.caps[a].texture = THREE.ImageUtils.loadTexture(skim.instances.ressourcesPath + skim.textures.caps[a].path, {}, function () {
						e(f)
					}));
			d = new EnvironmentMapMaterial(skim.shaders,
					skim.textures.caps[a].texture, {
					color : b,
					mergeColorWith : c
				});
			f.mat = d;
			f.textures = [skim.textures.caps[a].texture];
			return d
		}
	}
	()
};
skim.getGeneralEnvMapDarkenFunction = function (a) {
	return function () {
		var b = null;
		return function (c) {
			var d = {
				mat : b,
				textures : [skim.textures.caps[a].texture]
			};
			if (null !== b)
				return c(d), b;
			skim.utils.assert(void 0 !== skim.textures.caps[a], "Error : cannot build envmap material for silver HG without the texture slot defined");
			null === skim.textures.caps[a].texture && (skim.textures.caps[a].texture = THREE.ImageUtils.loadTexture(skim.instances.ressourcesPath + skim.textures.caps[a].path, {}, function () {
						c(d)
					}));
			b = new EnvironmentMapDarkenMaterial(skim.shaders,
					skim.textures.caps[a].texture);
			d.mat = b;
			d.textures = [skim.textures.caps[a].texture];
			return b
		}
	}
	()
};
skim.getGeneralSaveEnvMapNormalsFunction = function () {
	return function () {
		var a = null;
		return function (b) {
			var c = {
				mat : a,
				textures : []
			};
			return null !== a ? (b(c), a) : a = new SaveEnvMapNormalsMaterial
		}
	}
	()
};
skim.getUniformPhysicalMaterialFunction = function () {
	skim.utils.assert(!1, " skim.getUniformPhysicalMaterialFunction DEPRECATED : use getPhysicalMaterialFunction(false,false,false) instead");
	return function () {
		var a = 0,
		b = null,
		c = [null, null, null, null, null, null];
		return function (d) {
			var e = {
				mat : b,
				textures : c
			};
			if (null === b) {
				for (var f = function () {
					a++;
					6 === a && d(e)
				}, g = 0; 7 > g; ++g) {
					var h = skim.instances.ressourcesPath + "img/cubeMaps/LandscapeMountain/",
					h = 6 > g ? h + "specular/0" + g + "_" : h + "diffuse/";
					c[g] = THREE.ImageUtils.loadTextureCube([h +
								"px.png", h + "nx.png", h + "py.png", h + "ny.png", h + "pz.png", h + "nz.png"], THREE.Texture.DEFAULT_MAPPING, f);
					c[g].format = THREE.RGBFormat
				}
				b = new THREE.ShaderMaterial({
						uniforms : {
							envMap0 : {
								type : "t",
								value : c[0]
							},
							envMap1 : {
								type : "t",
								value : c[1]
							},
							envMap2 : {
								type : "t",
								value : c[2]
							},
							envMap3 : {
								type : "t",
								value : c[3]
							},
							envMap4 : {
								type : "t",
								value : c[4]
							},
							envMap5 : {
								type : "t",
								value : c[5]
							},
							diffuseMap : {
								type : "t",
								value : c[6]
							},
							lightIntensity : {
								type : "f",
								value : 1.5
							},
							saturation : {
								type : "f",
								value : 0.3
							},
							vRoughness : {
								type : "f",
								value : 0.3
							},
							vMetallic : {
								type : "f",
								value : 0.5
							},
							baseColor : {
								type : "c",
								value : new THREE.Color(10066329)
							}
						},
						vertexShader : "/**uniform vec3 lightPosition;*/\nvarying vec3 vLightVector;\nvarying vec3 vTestNormal;\nvarying vec3 vPosition;\nvoid main()\n{\n   vec3 vNormal = normalize(normalMatrix * normal);\n   vLightVector = normalize(vec3(0.4, 0.2 ,0.2));\n   vPosition = position;\n   vTestNormal = normal;\n   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
						fragmentShader : "#define PI 3.14159265359\nuniform samplerCube envMap0;\nuniform samplerCube envMap1;\nuniform samplerCube envMap2;\nuniform samplerCube envMap3;\nuniform samplerCube envMap4;\nuniform samplerCube envMap5;\nuniform samplerCube diffuseMap;\nuniform float lightIntensity;\nuniform float saturation;\nvarying vec3 vLightVector;\nvarying vec3 vTestNormal;\nvarying vec3 vPosition;\nuniform vec3 baseColor;\nuniform float vRoughness;\nuniform float vMetallic;\nvec3 Diffuse(vec3 pAlbedo)\n{\n    return pAlbedo/PI;\n}\n//-------------------------- Normal distribution functions --------------------------------------------\nfloat NormalDistribution_GGX(float a, float NdH)\n{\n    // Isotropic ggx.\n   float a2 = a*a;\n    float NdH2 = NdH * NdH;\n    float denominator = NdH2 * (a2 - 1.0) + 1.0;\n    denominator *= denominator;\n    denominator *= PI;\n    return a2 / denominator;\n}\n//-------------------------- Geometric shadowing -------------------------------------------\nfloat Geometric_Smith_Schlick_GGX(float a, float NdV, float NdL)\n{\n        // Smith schlick-GGX.\n    float k = a * 0.5;\n    float GV = NdV / (NdV * (1.0 - k) + k);\n    float GL = NdL / (NdL * (1.0 - k) + k);\n    return GV * GL;\n}\n//-------------------------- Fresnel ------------------------------------\nvec3 Fresnel_Schlick(vec3 specularColor, vec3 h, vec3 v)\n{\n    return (specularColor + (1.0 - specularColor) * pow((1.0 - clamp(dot(v, h), 0.0, 1.0)), 5.0));\n}\n//-------------------------- BRDF terms ------------------------------------\nfloat Specular_D(float a, float NdH)\n{\n    return NormalDistribution_GGX(a, NdH);\n}\nvec3 Specular_F(vec3 specularColor, vec3 h, vec3 v)\n{\n     return Fresnel_Schlick(specularColor, h, v);\n}\nvec3 Specular_F_Roughness(vec3 specularColor, float a, vec3 h, vec3 v)\n{\n    return (specularColor + (max(vec3(1.0 - a), specularColor) - specularColor) * pow((1.0 - clamp(dot(v, h), 0.0, 1.0)), 5.0));\n}\nfloat Specular_G(float a, float NdV, float NdL, float NdH, float VdH, float LdV)\n{\n   return Geometric_Smith_Schlick_GGX(a, NdV, NdL);\n}\nvec3 Specular(vec3 specularColor, vec3 h, vec3 v, vec3 l, float a, float NdL, float NdV, float NdH, float VdH, float LdV)\n{\n    return ((Specular_D(a, NdH) * Specular_G(a, NdV, NdL, NdH, VdH, LdV)) * Specular_F(specularColor, v, h) ) / (4.0 * NdL * NdV + 0.0001);\n}\nvec3 ComputeLight(vec3 albedoColor,vec3 specularColor, vec3 normal, vec3 diffuseMapColor, vec3 lightColor, vec3 lightDir, vec3 viewDir)\n{\n    // Compute some useful values.\n    float NdL = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float NdV = clamp(dot(normal, viewDir), 0.0, 1.0);\n    vec3 h = normalize(lightDir + viewDir);\n    float NdH = clamp(dot(normal, h), 0.0, 1.0);\n    float VdH = clamp(dot(viewDir, h), 0.0, 1.0);\n    float LdV = clamp(dot(lightDir, viewDir), 0.0, 1.0);\n    float a = max(0.001, vRoughness * vRoughness);\n    vec3 cDiff = Diffuse(albedoColor);\n    vec3 cSpec = Specular(specularColor, h, viewDir, lightDir, a, NdL, NdV, NdH, VdH, LdV);\n   return diffuseMapColor*cDiff + lightColor * NdL * (cDiff * (1.0-cSpec) + cSpec);\n}\n// Ok, this is ugly, but there is an explanation ...\n// WebGL need the extension EXT_shader_texture_lod in order to use textureCubeLod, and it's not yet implemented.\n// With textureCube the mipmap is automatically applied, and you can only add a bias.\n// To avoid that I saved each mip level in a separate cubemap.\n// If there is a less awfull way to do this I'd be happy to know !\nvec3 ComputeEnvColor(float roughness, vec3 reflectionVector)\n{\n    float a = roughness * roughness * 6.0;\n    if ( a < 1.0)\n    {\n        return mix(textureCube(envMap0, reflectionVector).rgb, textureCube(envMap1, reflectionVector).rgb, a);\n    }\n    if ( a < 2.0)\n    {\n        return mix(textureCube(envMap1, reflectionVector).rgb, textureCube(envMap2, reflectionVector).rgb, a - 1.0);\n    }\n    if ( a < 3.0)\n    {\n        return mix(textureCube(envMap2, reflectionVector).rgb, textureCube(envMap3, reflectionVector).rgb, a - 2.0);\n    }\n    if ( a < 4.0)\n    {\n        return mix(textureCube(envMap3, reflectionVector).rgb, textureCube(envMap4, reflectionVector).rgb, a - 3.0);\n    }\n    if ( a < 5.0)\n    {\n        return mix(textureCube(envMap4, reflectionVector).rgb, textureCube(envMap5, reflectionVector).rgb, a - 4.0);\n    }\n    return textureCube(envMap5, reflectionVector).rgb;\n}\nvec3 changeSaturation(vec3 c, float change)\n{\n   float P = sqrt(c.r*c.r*0.299+c.g*c.g*0.587+c.b*c.b*0.114);\n   return vec3(P+(c.r-P)*change,P+(c.g-P)*change,P+(c.b-P)*change);\n}\nvoid main()\n{\n    vec3 normal = vTestNormal;\n    vec3 viewDir = normalize(cameraPosition - vPosition);\n    vec3 albedoCorrected = pow(abs(baseColor.rgb), vec3(2.2));\n    vec3 realAlbedo = baseColor - baseColor * vMetallic;\n    vec3 realSpecularColor = mix(vec3(0.03, 0.03, 0.03), baseColor, vMetallic);\n    vec3 reflectVector = reflect(-viewDir, normal);\n    vec3 envColor = changeSaturation(ComputeEnvColor(vRoughness, reflectVector),saturation);\n    vec3 lightColor = changeSaturation(textureCube(diffuseMap, normal).rgb,saturation);\n    vec3 light1 = ComputeLight( realAlbedo, realSpecularColor, normal, lightColor, vec3(1.0, 1.0, 0.96), vLightVector, viewDir);\n    vec3 envFresnel = Specular_F_Roughness(realSpecularColor, vRoughness * vRoughness, normal, viewDir);\n   gl_FragColor = vec4(vec3(lightIntensity) * light1 + 1.0 * envFresnel * envColor + realAlbedo * 0.01, 1.0);\n}"
					});
				e.mat = b
			} else
				d(e);
			return b
		}
	}
	()
};
skim.getUniformPhysicalWireframeMaterialFunction = function () {
	return function () {
		var a = 0,
		b = null,
		c = [null, null, null, null, null, null];
		return function (d) {
			var e = {
				mat : b,
				textures : c
			};
			if (null === b) {
				for (var f = function () {
					a++;
					6 === a && d(e)
				}, g = 0; 7 > g; ++g) {
					var h = skim.instances.ressourcesPath + "img/cubeMaps/LandscapeMountain/",
					h = 6 > g ? h + "specular/0" + g + "_" : h + "diffuse/";
					c[g] = THREE.ImageUtils.loadTextureCube([h + "px.png", h + "nx.png", h + "py.png", h + "ny.png", h + "pz.png", h + "nz.png"], THREE.Texture.DEFAULT_MAPPING, f);
					c[g].format = THREE.RGBFormat
				}
				b =
					new THREE.ShaderMaterial({
						uniforms : {
							envMap0 : {
								type : "t",
								value : c[0]
							},
							envMap1 : {
								type : "t",
								value : c[1]
							},
							envMap2 : {
								type : "t",
								value : c[2]
							},
							envMap3 : {
								type : "t",
								value : c[3]
							},
							envMap4 : {
								type : "t",
								value : c[4]
							},
							envMap5 : {
								type : "t",
								value : c[5]
							},
							diffuseMap : {
								type : "t",
								value : c[6]
							},
							lightIntensity : {
								type : "f",
								value : 1.7
							},
							saturation : {
								type : "f",
								value : 0.2
							},
							vRoughness : {
								type : "f",
								value : 0.8
							},
							vMetallic : {
								type : "f",
								value : 0
							},
							baseColor : {
								type : "c",
								value : new THREE.Color(16777215)
							}
						},
						vertexShader : "attribute vec3 barycentric;\nvarying vec3 vLightVector;\nvarying vec3 vTestNormal;\nvarying vec3 vPosition;\nvarying vec3 vBarycentric;\nvoid main()\n{\n   vec3 vNormal = normalize(normalMatrix * normal);\n   vLightVector = normalize(vec3(0.4, 0.2 ,0.2));\n   vPosition = position;\n   vTestNormal = normal;\n   vBarycentric = barycentric;\n   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
						fragmentShader : "#define PI 3.14159265359\nuniform samplerCube envMap0;\nuniform samplerCube envMap1;\nuniform samplerCube envMap2;\nuniform samplerCube envMap3;\nuniform samplerCube envMap4;\nuniform samplerCube envMap5;\nuniform samplerCube diffuseMap;\nuniform float lightIntensity;\nuniform float saturation;\nvarying vec3 vLightVector;\nvarying vec3 vTestNormal;\nvarying vec3 vPosition;\nvarying vec3 vBarycentric;\nuniform vec3 baseColor;\nuniform float vRoughness;\nuniform float vMetallic;\nvec3 Diffuse(vec3 pAlbedo)\n{\n    return pAlbedo/PI;\n}\n//-------------------------- Normal distribution functions --------------------------------------------\nfloat NormalDistribution_GGX(float a, float NdH)\n{\n    // Isotropic ggx.\n   float a2 = a*a;\n    float NdH2 = NdH * NdH;\n    float denominator = NdH2 * (a2 - 1.0) + 1.0;\n    denominator *= denominator;\n    denominator *= PI;\n    return a2 / denominator;\n}\n//-------------------------- Geometric shadowing -------------------------------------------\nfloat Geometric_Smith_Schlick_GGX(float a, float NdV, float NdL)\n{\n        // Smith schlick-GGX.\n    float k = a * 0.5;\n    float GV = NdV / (NdV * (1.0 - k) + k);\n    float GL = NdL / (NdL * (1.0 - k) + k);\n    return GV * GL;\n}\n//-------------------------- Fresnel ------------------------------------\nvec3 Fresnel_Schlick(vec3 specularColor, vec3 h, vec3 v)\n{\n    return (specularColor + (1.0 - specularColor) * pow((1.0 - clamp(dot(v, h), 0.0, 1.0)), 5.0));\n}\n//-------------------------- BRDF terms ------------------------------------\nfloat Specular_D(float a, float NdH)\n{\n    return NormalDistribution_GGX(a, NdH);\n}\nvec3 Specular_F(vec3 specularColor, vec3 h, vec3 v)\n{\n     return Fresnel_Schlick(specularColor, h, v);\n}\nvec3 Specular_F_Roughness(vec3 specularColor, float a, vec3 h, vec3 v)\n{\n    return (specularColor + (max(vec3(1.0 - a), specularColor) - specularColor) * pow((1.0 - clamp(dot(v, h), 0.0, 1.0)), 5.0));\n}\nfloat Specular_G(float a, float NdV, float NdL, float NdH, float VdH, float LdV)\n{\n   return Geometric_Smith_Schlick_GGX(a, NdV, NdL);\n}\nvec3 Specular(vec3 specularColor, vec3 h, vec3 v, vec3 l, float a, float NdL, float NdV, float NdH, float VdH, float LdV)\n{\n    return ((Specular_D(a, NdH) * Specular_G(a, NdV, NdL, NdH, VdH, LdV)) * Specular_F(specularColor, v, h) ) / (4.0 * NdL * NdV + 0.0001);\n}\nvec3 ComputeLight(vec3 albedoColor,vec3 specularColor, vec3 normal, vec3 diffuseMapColor, vec3 lightColor, vec3 lightDir, vec3 viewDir)\n{\n    // Compute some useful values.\n    float NdL = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float NdV = clamp(dot(normal, viewDir), 0.0, 1.0);\n    vec3 h = normalize(lightDir + viewDir);\n    float NdH = clamp(dot(normal, h), 0.0, 1.0);\n    float VdH = clamp(dot(viewDir, h), 0.0, 1.0);\n    float LdV = clamp(dot(lightDir, viewDir), 0.0, 1.0);\n    float a = max(0.001, vRoughness * vRoughness);\n    vec3 cDiff = Diffuse(albedoColor);\n    vec3 cSpec = Specular(specularColor, h, viewDir, lightDir, a, NdL, NdV, NdH, VdH, LdV);\n   return diffuseMapColor*cDiff + lightColor * NdL * (cDiff * (1.0-cSpec) + cSpec);\n}\n// Ok, this is ugly, but there is an explanation ...\n// WebGL need the extension EXT_shader_texture_lod in order to use textureCubeLod, and it's not yet implemented.\n// With textureCube the mipmap is automatically applied, and you can only add a bias.\n// To avoid that I saved each mip level in a separate cubemap.\n// If there is a less awfull way to do this I'd be happy to know !\nvec3 ComputeEnvColor(float roughness, vec3 reflectionVector)\n{\n    float a = roughness * roughness * 6.0;\n    if ( a < 1.0)\n    {\n        return mix(textureCube(envMap0, reflectionVector).rgb, textureCube(envMap1, reflectionVector).rgb, a);\n    }\n    if ( a < 2.0)\n    {\n        return mix(textureCube(envMap1, reflectionVector).rgb, textureCube(envMap2, reflectionVector).rgb, a - 1.0);\n    }\n    if ( a < 3.0)\n    {\n        return mix(textureCube(envMap2, reflectionVector).rgb, textureCube(envMap3, reflectionVector).rgb, a - 2.0);\n    }\n    if ( a < 4.0)\n    {\n        return mix(textureCube(envMap3, reflectionVector).rgb, textureCube(envMap4, reflectionVector).rgb, a - 3.0);\n    }\n    if ( a < 5.0)\n    {\n        return mix(textureCube(envMap4, reflectionVector).rgb, textureCube(envMap5, reflectionVector).rgb, a - 4.0);\n    }\n    return textureCube(envMap5, reflectionVector).rgb;\n}\nvec3 changeSaturation(vec3 c, float change)\n{\n   float P = sqrt(c.r*c.r*0.299+c.g*c.g*0.587+c.b*c.b*0.114);\n   return vec3(P+(c.r-P)*change,P+(c.g-P)*change,P+(c.b-P)*change);\n}\n#ifdef GL_OES_standard_derivatives\n   float edgeFactor(vec3 vBarycentric){                 \n       vec3 d = fwidth(vBarycentric);                 \n       vec3 a3 = smoothstep(vec3(0.0), d, vBarycentric);   \n       return min(min(a3.x, a3.y), a3.z);             \n   }\n#endif\nvoid main()\n{\n    vec3 normal = vTestNormal;\n    vec3 viewDir = normalize(cameraPosition - vPosition);\n    vec3 albedoCorrected = pow(abs(baseColor.rgb), vec3(2.2));\n    vec3 realAlbedo = baseColor - baseColor * vMetallic;\n    vec3 realSpecularColor = mix(vec3(0.03, 0.03, 0.03), baseColor, vMetallic);\n    vec3 reflectVector = reflect(-viewDir, normal);\n    vec3 envColor = changeSaturation(ComputeEnvColor(vRoughness, reflectVector),saturation);\n    vec3 lightColor = changeSaturation(textureCube(diffuseMap, normal).rgb,saturation);\n    vec3 light1 = ComputeLight( realAlbedo, realSpecularColor, normal, lightColor, vec3(1.0, 1.0, 0.96), vLightVector, viewDir);\n    vec3 envFresnel = Specular_F_Roughness(realSpecularColor, vRoughness * vRoughness, normal, viewDir);\n   gl_FragColor = vec4(vec3(lightIntensity) * light1 + 1.0 * envFresnel * envColor + realAlbedo * 0.01, 1.0);\n#ifdef GL_OES_standard_derivatives\n    gl_FragColor.rgb = mix(vec3(1.0,0.46,0.06), gl_FragColor.rgb, edgeFactor(vBarycentric)); \n#else\n   if(any(lessThan(vBarycentric, vec3(0.02)))){\n       gl_FragColor = vec4(vec3(1.0,0.46,0.06), 1.0);\n   }\n   else{\n       gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);\n   }\n#endif\n}"
					});
				b.derivatives = !0;
				e.mat = b
			} else
				d(e);
			return b
		}
	}
	()
};
skim.getPhysicalMaterialFunction = function (a, b, c) {
	return function () {
		var d = [b ? "attribute float roughness;" : "", c ? "attribute float metallic;" : "", "/**uniform vec3 lightPosition;*/\nvarying vec3 vLightVector;\nvarying vec3 vTestNormal;\nvarying vec3 vPosition;", a ? "varying vec3 baseColor;" : "", b ? "varying float vRoughness;" : "", c ? "varying float vMetallic;" : "", "void main()\n{\n   vec3 vNormal = normalize(normalMatrix * normal);\n   vLightVector = normalize(vec3(0.4, 0.2 ,0.2));\n   vPosition = position;\n   vTestNormal = normal;", a ?
			" baseColor = color;" : "", b ? " vRoughness = roughness;" : "", c ? " vMetallic = metallic;" : "", "   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"].join("\n"),
		e = ["#define PI 3.14159265359\nuniform samplerCube envMap0;\nuniform samplerCube envMap1;\nuniform samplerCube envMap2;\nuniform samplerCube envMap3;\nuniform samplerCube envMap4;\nuniform samplerCube envMap5;\nuniform samplerCube diffuseMap;\nuniform float lightIntensity;\nuniform float saturation;\nvarying vec3 vLightVector;\nvarying vec3 vTestNormal;\nvarying vec3 vPosition;",
			a ? "varying vec3 baseColor;" : "uniform vec3 baseColor;", b ? "varying float vRoughness;" : "uniform float vRoughness;", c ? "varying float vMetallic;" : "uniform float vMetallic;", "vec3 Diffuse(vec3 pAlbedo)\n{\n    return pAlbedo/PI;\n}\n//-------------------------- Normal distribution functions --------------------------------------------\nfloat NormalDistribution_GGX(float a, float NdH)\n{\n    // Isotropic ggx.\n   float a2 = a*a;\n    float NdH2 = NdH * NdH;\n    float denominator = NdH2 * (a2 - 1.0) + 1.0;\n    denominator *= denominator;\n    denominator *= PI;\n    return a2 / denominator;\n}\n//-------------------------- Geometric shadowing -------------------------------------------\nfloat Geometric_Smith_Schlick_GGX(float a, float NdV, float NdL)\n{\n        // Smith schlick-GGX.\n    float k = a * 0.5;\n    float GV = NdV / (NdV * (1.0 - k) + k);\n    float GL = NdL / (NdL * (1.0 - k) + k);\n    return GV * GL;\n}\n//-------------------------- Fresnel ------------------------------------\nvec3 Fresnel_Schlick(vec3 specularColor, vec3 h, vec3 v)\n{\n    return (specularColor + (1.0 - specularColor) * pow((1.0 - clamp(dot(v, h), 0.0, 1.0)), 5.0));\n}\n//-------------------------- BRDF terms ------------------------------------\nfloat Specular_D(float a, float NdH)\n{\n    return NormalDistribution_GGX(a, NdH);\n}\nvec3 Specular_F(vec3 specularColor, vec3 h, vec3 v)\n{\n     return Fresnel_Schlick(specularColor, h, v);\n}\nvec3 Specular_F_Roughness(vec3 specularColor, float a, vec3 h, vec3 v)\n{\n    return (specularColor + (max(vec3(1.0 - a), specularColor) - specularColor) * pow((1.0 - clamp(dot(v, h), 0.0, 1.0)), 5.0));\n}\nfloat Specular_G(float a, float NdV, float NdL, float NdH, float VdH, float LdV)\n{\n   return Geometric_Smith_Schlick_GGX(a, NdV, NdL);\n}\nvec3 Specular(vec3 specularColor, vec3 h, vec3 v, vec3 l, float a, float NdL, float NdV, float NdH, float VdH, float LdV)\n{\n    return ((Specular_D(a, NdH) * Specular_G(a, NdV, NdL, NdH, VdH, LdV)) * Specular_F(specularColor, v, h) ) / (4.0 * NdL * NdV + 0.0001);\n}\nvec3 ComputeLight(vec3 albedoColor,vec3 specularColor, vec3 normal, vec3 diffuseMapColor, vec3 lightColor, vec3 lightDir, vec3 viewDir)\n{\n    // Compute some useful values.\n    float NdL = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float NdV = clamp(dot(normal, viewDir), 0.0, 1.0);\n    vec3 h = normalize(lightDir + viewDir);\n    float NdH = clamp(dot(normal, h), 0.0, 1.0);\n    float VdH = clamp(dot(viewDir, h), 0.0, 1.0);\n    float LdV = clamp(dot(lightDir, viewDir), 0.0, 1.0);\n    float a = max(0.001, vRoughness * vRoughness);\n    vec3 cDiff = Diffuse(albedoColor);\n    vec3 cSpec = Specular(specularColor, h, viewDir, lightDir, a, NdL, NdV, NdH, VdH, LdV);\n   return lightColor * NdL * (cDiff * (1.0-cSpec) + cSpec);\n}\n// Ok, this is ugly, but there is an explanation ...\n// WebGL need the extension EXT_shader_texture_lod in order to use textureCubeLod, and it's not yet implemented.\n// With textureCube the mipmap is automatically applied, and you can only add a bias.\n// To avoid that I saved each mip level in a separate cubemap.\n// If there is a less awfull way to do this I'd be happy to know !\nvec3 ComputeEnvColor(float roughness, vec3 reflectionVector)\n{\n    float a = roughness * roughness * 6.0;\n    if ( a < 1.0)\n    {\n        return mix(textureCube(envMap0, reflectionVector).rgb, textureCube(envMap1, reflectionVector).rgb, a);\n    }\n    if ( a < 2.0)\n    {\n        return mix(textureCube(envMap1, reflectionVector).rgb, textureCube(envMap2, reflectionVector).rgb, a - 1.0);\n    }\n    if ( a < 3.0)\n    {\n        return mix(textureCube(envMap2, reflectionVector).rgb, textureCube(envMap3, reflectionVector).rgb, a - 2.0);\n    }\n    if ( a < 4.0)\n    {\n        return mix(textureCube(envMap3, reflectionVector).rgb, textureCube(envMap4, reflectionVector).rgb, a - 3.0);\n    }\n    if ( a < 5.0)\n    {\n        return mix(textureCube(envMap4, reflectionVector).rgb, textureCube(envMap5, reflectionVector).rgb, a - 4.0);\n    }\n    return textureCube(envMap5, reflectionVector).rgb;\n}\nvec3 changeSaturation(vec3 c, float change)\n{\n   float P = sqrt(c.r*c.r*0.299+c.g*c.g*0.587+c.b*c.b*0.114);\n   return vec3(P+(c.r-P)*change,P+(c.g-P)*change,P+(c.b-P)*change);\n}\nvoid main()\n{\n    vec3 normal = vTestNormal;\n    vec3 viewDir = normalize(cameraPosition - vPosition);\n    vec3 albedoCorrected = pow(abs(baseColor.rgb), vec3(2.2));\n    vec3 realAlbedo = baseColor - baseColor * vMetallic;\n    vec3 realSpecularColor = mix(vec3(0.03, 0.03, 0.03), baseColor, vMetallic);\n    vec3 reflectVector = reflect(-viewDir, normal);\n    vec3 envColor = changeSaturation(ComputeEnvColor(vRoughness, reflectVector),saturation);\n    vec3 lightColor = changeSaturation(textureCube(diffuseMap, normal).rgb,saturation);\n    vec3 light1 = ComputeLight( realAlbedo, realSpecularColor, normal, lightColor, vec3(1.0, 1.0, 0.96), vLightVector, viewDir);\n    vec3 light2 = ComputeLight( realAlbedo, realSpecularColor, normal, lightColor, vec3(1.0, 1.0, 0.96), -vLightVector, viewDir);\n    vec3 allLight = lightColor*Diffuse(realAlbedo) + light1 + light2;\n    vec3 envFresnel = Specular_F_Roughness(realSpecularColor, vRoughness * vRoughness, normal, viewDir);\n   gl_FragColor = vec4(vec3(lightIntensity) * allLight + 1.0 * envFresnel * envColor + realAlbedo * 0.01, 1.0);\n}"].join("\n"),
		f = 0,
		g = null,
		h = null,
		k = [null, null, null, null, null, null];
		return function (l, m) {
			var n = {
				mat : g,
				textures : k
			},
			p = skim.instances.ressourcesPath + "img/cubeMaps/LandscapeMountain/";
			if (null === g || void 0 !== m && h !== m || void 0 === m && h !== p) {
				h = void 0 === m ? p : m;
				for (var p = function () {
					f++;
					6 === f && l(n)
				}, q = 0; 7 > q; ++q) {
					var r = h,
					r = 6 > q ? r + "specular/0" + q + "_" : r + "diffuse/";
					k[q] = THREE.ImageUtils.loadTextureCube([r + "px.png", r + "nx.png", r + "py.png", r + "ny.png", r + "pz.png", r + "nz.png"], THREE.Texture.DEFAULT_MAPPING, p);
					k[q].format = THREE.RGBFormat
				}
				p = {
					envMap0 : {
						type : "t",
						value : k[0]
					},
					envMap1 : {
						type : "t",
						value : k[1]
					},
					envMap2 : {
						type : "t",
						value : k[2]
					},
					envMap3 : {
						type : "t",
						value : k[3]
					},
					envMap4 : {
						type : "t",
						value : k[4]
					},
					envMap5 : {
						type : "t",
						value : k[5]
					},
					diffuseMap : {
						type : "t",
						value : k[6]
					},
					lightIntensity : {
						type : "f",
						value : 1.5
					},
					saturation : {
						type : "f",
						value : 0.1
					}
				};
				a || (p.baseColor = {
						type : "c",
						value : new THREE.Color(10066329)
					});
				b || (p.vRoughness = {
						type : "f",
						value : 0.3
					});
				c || (p.vMetallic = {
						type : "f",
						value : 0.5
					});
				g = new THREE.ShaderMaterial({
						uniforms : p,
						vertexShader : d,
						fragmentShader : e,
						vertexColors : THREE.FaceColors
					});
				skim.utils.assert(void 0 !== g.defaultAttributeValues, "Ouhou have you updated THREEJS? defaultAttributeValues is not available... This may cause issues");
				g.defaultAttributeValues.roughness = [0];
				g.defaultAttributeValues.metallic = [0];
				n.mat = g
			} else
				l(n);
			return g
		}
	}
	()
};
skim.getWireframeMaterialFunction = function () {
	return function () {
		var a = null;
		return function (b) {
			null === a && (a = new THREE.ShaderMaterial({
						uniforms : {},
						vertexShader : "attribute vec3 barycentric;\nvarying vec3 vTestNormal;\nvarying vec3 vPosition;\nvarying vec3 vBarycentric;\nvoid main()\n{\n   vec3 vNormal = normalize(normalMatrix * normal);\n   vPosition = position;\n   vTestNormal = normal;\n   vBarycentric = barycentric;\n   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
						fragmentShader : "varying vec3 vTestNormal;\nvarying vec3 vPosition;\nvarying vec3 vBarycentric;\n#ifdef GL_OES_standard_derivatives\n   float edgeFactor(vec3 vBarycentric){                 \n       vec3 d = fwidth(vBarycentric);                 \n       vec3 a3 = smoothstep(vec3(0.0), d, vBarycentric);   \n       return min(min(a3.x, a3.y), a3.z);             \n   }\n#endif\nvoid main()\n{\n#ifdef GL_OES_standard_derivatives\n    gl_FragColor.rgb = mix(vec3(0.0), vec3(0.5), edgeFactor(vBarycentric)); \n#else\n   if(any(lessThan(vBarycentric, vec3(0.02)))){\n       gl_FragColor = vec4(vBarycentric, 1.0);\n   }\n   else{\n       gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);\n   }\n#endif\n    gl_FragColor.rgb = mix(vec3(0.0), vec3(0.5), edgeFactor(vBarycentric)); \n}"
					}),
				skim.utils.assert(void 0 !== a.defaultAttributeValues, "Ouhou have you updated THREEJS? defaultAttributeValues is not available... This may cause issues"), a.derivatives = !0);
			b({
				mat : a,
				textures : []
			});
			return a
		}
	}
	()
};
skim.getMedicalGhost = function (a) {
	return function () {
		var b = null;
		return function (c) {
			null === b && (b = new THREE.ShaderMaterial({
						uniforms : {
							transparency : {
								type : "f",
								value : a
							},
							limit : {
								type : "f",
								value : 25
							},
							green_l : {
								type : "f",
								value : 22
							},
							red_l : {
								type : "f",
								value : 1
							},
							level_pow : {
								type : "f",
								value : 4
							},
							lumin_var : {
								type : "f",
								value : 0.3
							}
						},
						vertexShader : "varying vec3 vNormal;\nvarying float zCoord;\nvoid main ()\n{\n    zCoord = position.z;\n    vNormal = normalize(normalMatrix * normal);\n    gl_Position = projectionMatrix * modelViewMatrix  * vec4(position,1.);\n}",
						fragmentShader : "varying vec3 vNormal;\nvarying float zCoord;\nuniform float transparency;\nuniform float limit;\nuniform float green_l;\nuniform float red_l;\nuniform float level_pow;\nuniform float lumin_var;\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid main ()\n{\nfloat level = length(normalize(vNormal).xy);\nlevel = pow(level,level_pow);\nif(zCoord>limit+2.0){\n   gl_FragColor = vec4(vec3(0.35),1.0)*level + (1.0-level)*vec4(1.0);\n}else if(zCoord>limit){\n   vec4 fc_above = vec4(vec3(0.35),1.0)*level + (1.0-level)*vec4(1.0);\n   vec4 fc_under = vec4(hsv2rgb(vec3(0.61, 0.75,0.75+0.15*level)), 1.0);\n   float t = (zCoord-limit)/2.0;\n   gl_FragColor = fc_above*t+ (1.0-t)*fc_under;\n}else if(zCoord>green_l){\n   gl_FragColor = vec4(hsv2rgb(vec3(0.32+0.29*(zCoord-green_l)/(limit-green_l), 0.75,1.0+lumin_var*(level-1.0))), 1.0);\n}else if(zCoord>red_l){\n   gl_FragColor = vec4(hsv2rgb(vec3(0.04+0.28*(zCoord-red_l)/(green_l-red_l), 0.75,1.0+lumin_var*(level-1.0))), 1.0);\n}else{\n   gl_FragColor = vec4(hsv2rgb(vec3(0.04*clamp(zCoord,0.0,red_l)/red_l, 0.75,1.0+lumin_var*(level-1.0))), 1.0);\n}\n}"
					}),
				skim.utils.assert(void 0 !== b.defaultAttributeValues, "Ouhou have you updated THREEJS? defaultAttributeValues is not available... This may cause issues"), b.transparent = !0, b.side = THREE.FrontSide);
			c({
				mat : b,
				textures : []
			});
			return b
		}
	}
	()
};
skim.getHeightMapMaterialFunction = function () {
	return function () {
		var a = null;
		return function (b) {
			null === a && (a = new THREE.ShaderMaterial({
						uniforms : {
							limit : {
								type : "f",
								value : 25
							},
							green_l : {
								type : "f",
								value : 22
							},
							red_l : {
								type : "f",
								value : 1
							},
							level_pow : {
								type : "f",
								value : 3
							},
							lumin_var : {
								type : "f",
								value : 0.2
							}
						},
						vertexShader : "varying vec3 vNormal;\nvarying vec3 posOrigin;\nvoid main ()\n{\n    posOrigin = position;\n    vNormal = normalize(normalMatrix * normal);\n    gl_Position = projectionMatrix * modelViewMatrix  * vec4(position,1.);\n}",
						fragmentShader : "varying vec3 vNormal;\nvarying vec3 posOrigin;\nuniform float limit;\nuniform float green_l;\nuniform float red_l;\nuniform float level_pow;\nuniform float lumin_var;\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid main ()\n{\nfloat level = length(normalize(vNormal).xy);\nlevel = pow(level,level_pow);\nif(posOrigin.z>limit+2.0){\n       gl_FragColor = vec4(vec3(0.35),1.0)*level + (1.0-level)*vec4(1.0);\n}else if(posOrigin.z>limit){\n   vec4 fc_above = vec4(vec3(0.35),1.0)*level + (1.0-level)*vec4(1.0);\n   vec4 fc_under = vec4(hsv2rgb(vec3(0.61, 0.75,0.75+0.15*level)), 1.0);\n   float t = (posOrigin.z-limit)/2.0;\n   gl_FragColor = fc_above*t+ (1.0-t)*fc_under;\n}else if(posOrigin.z>green_l){\n   gl_FragColor = vec4(hsv2rgb(vec3(0.32+0.29*(posOrigin.z-green_l)/(limit-green_l), 0.75,1.0+lumin_var*(level-1.0))), 1.0);\n}else if(posOrigin.z>red_l){\n   gl_FragColor = vec4(hsv2rgb(vec3(0.04+0.28*(posOrigin.z-red_l)/(green_l-red_l), 0.75,1.0+lumin_var*(level-1.0))), 1.0);\n}else{\n   gl_FragColor = vec4(hsv2rgb(vec3(0.04*clamp(posOrigin.z,0.0,red_l)/red_l, 0.75,1.0+lumin_var*(level-1.0))), 1.0);\n}\n}"
					}),
				skim.utils.assert(void 0 !== a.defaultAttributeValues, "Ouhou have you updated THREEJS? defaultAttributeValues is not available... This may cause issues"), a.transparent = !0, a.side = THREE.FrontSide);
			b({
				mat : a,
				textures : []
			});
			return a
		}
	}
	()
};
skim.getNormalGradientFunction = function () {
	return function () {
		var a = null;
		return function (b) {
			null === a && (a = new THREE.ShaderMaterial({
						uniforms : {
							level_pow : {
								type : "f",
								value : 3
							},
							lumin_var : {
								type : "f",
								value : 0.2
							}
						},
						vertexShader : "varying vec3 vNormal;\nvoid main ()\n{\n    vNormal = normalize(normalMatrix * normal);\n    gl_Position = projectionMatrix * modelViewMatrix  * vec4(position,1.);\n}",
						fragmentShader : "varying vec3 vNormal;\nuniform float level_pow;\nuniform float lumin_var;\nvoid main ()\n{\nfloat level = length(normalize(vNormal).xy);\nlevel = pow(level,level_pow);\n       gl_FragColor = vec4(vec3(0.35),1.0)*level + (1.0-level)*vec4(1.0);\n}"
					}),
				skim.utils.assert(void 0 !== a.defaultAttributeValues, "Ouhou have you updated THREEJS? defaultAttributeValues is not available... This may cause issues"), a.transparent = !0, a.side = THREE.FrontSide);
			b({
				mat : a,
				textures : []
			});
			return a
		}
	}
	()
};
skim.getGeneralBackgroundFunction = function (a) {
	return function () {
		return function (b, c) {
			var d = "background" + a[0].toUpperCase() + a.substring(1, a.length).toLowerCase();
			skim.utils.assert(void 0 !== skim.shaders.background && void 0 !== skim.shaders[d] && void 0 !== skim.shaders.background.vert && void 0 !== skim.shaders[d].frag, "Error : getGeneralBackgroundFunction : background shaders undefined");
			d = new BackgroundMaterial(skim.shaders.background.vert, skim.shaders[d].frag, {
					colorBack : void 0 !== b.colorBack ? b.colorBack.clone() :
					new THREE.Color,
					colorPoint : void 0 !== b.colorPoint ? b.colorPoint.clone() : new THREE.Color,
					pointPos : void 0 !== b.pointPos ? b.pointPos.clone() : new THREE.Vector2(0, 0),
					a : void 0 !== b.a ? b.a : 5
				});
			c({
				mat : d,
				textures : []
			});
			return d
		}
	}
	()
};
skim.gl_materials = {
	"Brass (Printable)" : {
		get : skim.getGeneralEnvMapFunction("brass", 10066329, "OBJECT")
	},
	"Bronze (Printable)" : {
		get : skim.getGeneralEnvMapFunction("bronze", 10066329, "OBJECT")
	},
	"Silver High Gloss (Printable)" : {
		get : skim.getGeneralEnvMapFunction("silverhg", 10066329, "OBJECT")
	},
	"Silver Gloss (Printable)" : {
		get : skim.getGeneralEnvMapFunction("silverg", 10066329, "OBJECT")
	},
	"Silver Sandblasted (Printable)" : {
		get : skim.getGeneralEnvMapFunction("silversb", 10066329, "OBJECT")
	},
	"Steel (Printable)" : {
		get : skim.getGeneralEnvMapFunction("steel",
			10066329, "OBJECT")
	},
	"Titanium (Printable)" : {
		get : skim.getGeneralEnvMapFunction("titanium", 10066329, "OBJECT")
	},
	"Gold (Printable)" : {
		get : skim.getGeneralEnvMapFunction("gold", 10066329, "OBJECT")
	},
	"Gold Red (Printable)" : {
		get : skim.getGeneralEnvMapFunction("gold_red", 10066329, "OBJECT")
	},
	"Gold White (Printable)" : {
		get : skim.getGeneralEnvMapFunction("gold_white", 10066329, "OBJECT")
	},
	"Gold Plated (Printable)" : {
		get : skim.getGeneralEnvMapFunction("gold_plated", 10066329, "OBJECT")
	},
	"Silver Oxydized (Printable)" : {
		get : skim.getGeneralEnvMapDarkenFunction("silverhg")
	},
	"Skim Vertices Widget" : {
		get : skim.getGeneralEnvMapFunction("skim_vertices_widget", 10066329, "VERTEX")
	},
	"Skim Primitives Widget" : {
		get : skim.getGeneralEnvMapFunction("skim_primitives_widget", 10066329, "VERTEX")
	},
	BackgroundExp : {
		get : skim.getGeneralBackgroundFunction("Exp")
	},
	BackgroundLinear : {
		get : skim.getGeneralBackgroundFunction("Linear")
	},
	BackgroundSin : {
		get : skim.getGeneralBackgroundFunction("Sin")
	},
	"Save Normals" : {
		get : skim.getGeneralSaveEnvMapNormalsFunction()
	},
	"Physical Material" : {
		get : skim.getPhysicalMaterialFunction(!0,
			!0, !0)
	},
	"Physical Material uColor" : {
		get : skim.getPhysicalMaterialFunction(!1, !0, !0)
	},
	"Physical Material uRoughness" : {
		get : skim.getPhysicalMaterialFunction(!0, !1, !0)
	},
	"Physical Material uMetallic" : {
		get : skim.getPhysicalMaterialFunction(!0, !0, !1)
	},
	"Physical Material uColor uRoughness" : {
		get : skim.getPhysicalMaterialFunction(!1, !1, !0)
	},
	"Physical Material uColor uMetallic" : {
		get : skim.getPhysicalMaterialFunction(!1, !0, !1)
	},
	"Physical Material uRoughness uMetallic" : {
		get : skim.getPhysicalMaterialFunction(!0, !1,
			!1)
	},
	"Uniform Physical Material" : {
		get : skim.getPhysicalMaterialFunction(!1, !1, !1)
	},
	Wireframe : {
		get : skim.getWireframeMaterialFunction()
	},
	"Physical Wireframe" : {
		get : skim.getUniformPhysicalWireframeMaterialFunction()
	}
};
skim.Material_source = {
	Base : "img/envMaps/SKdefault.png",
	Wax : "img/envMaps/ZBrush_RedWax_DESAT.png",
	Polish : "img/envMaps/polish.png",
	Glaze : "img/envMaps/glaze.png",
	Clay : "img/envMaps/clay.png",
	Snow : "img/envMaps/whitefluff.png",
	Carbon : "img/envMaps/carbon.png",
	Chrome : "img/envMaps/droplet_01.png",
	Metal : "img/envMaps/metal.png",
	"Blue glass" : "img/envMaps/JG_Drink01.png",
	"Soft gold" : "img/envMaps/JG_Gold.png",
	Lipstick : "img/envMaps/JG_Red.png",
	Matte : "img/envMaps/material4.png",
	"Bright Pearl" : "img/envMaps/brightpearl.png",
	"Chrome Gold" : "img/envMaps/chromegold.png",
	"Chrome Steel" : "img/envMaps/chromesteel.png"
};
skim.ringUtils = {};
skim.ringUtils.Convert3DPointToRZ = function (a) {
	return new THREE.Vector3(Math.sqrt(a.x * a.x + a.y * a.y), a.z, 0)
};
skim.ringUtils.RZProjector = function () {};
skim.ringUtils.RZProjector.prototype.project = function (a) {
	return skim.ringUtils.Convert3DPointToRZ(a)
};
skim.ringUtils.RSqExtractor = function () {};
skim.ringUtils.RSqExtractor.prototype.extract = function (a) {
	return skim.geometry.computeRadialDistSq(a)
};
skim.ringUtils.RExtractor = function () {};
skim.ringUtils.RExtractor.prototype.extract = function (a) {
	return skim.geometry.computeRadialDist(a)
};
skim.ringUtils.computeRoundedAngle = function (a, b) {
	return 2 * Math.round(a * b / (2 * Math.PI)) * Math.PI / b
};
skim.ringUtils.GetCeiledIndexFromAngle = function (a, b) {
	return Math.min(Math.ceil(b * a / (2 * Math.PI)), b - 1)
};
skim.ringUtils.GetFlooredIndexFromAngle = function (a, b) {
	return Math.min(Math.floor(b * a / (2 * Math.PI)), b - 1)
};
skim.ringUtils.sortConstraintsByTheta = function (a) {
	var b = a.v.length;
	a.theta.length = b / 4;
	for (var c = [], d = 0; d < b; d += 4)
		a.theta[d / 4] = skim.geometry.GetXAngleFromPoint(a.v[d].getPos()), c.push([[a.v[d], a.v[d + 1], a.v[d + 2], a.v[d + 3]], a.theta[d / 4]]);
	c.sort(function (a, b) {
		return a[1] - b[1]
	});
	c[0][1] != a.theta[0] && console.log("Constraints have to be sorted");
	for (var d = Array(b), e = Array(b / 4), f = 0; f < b / 4; f++)
		d[4 * f] = c[f][0][0], d[4 * f + 1] = c[f][0][1], d[4 * f + 2] = c[f][0][2], d[4 * f + 3] = c[f][0][3], e[f] = c[f][1];
	a.v = d;
	a.theta = e
};
skim.ringUtils.computeConstraints = function (a) {
	skim.ringUtils.sortConstraintsByTheta(a);
	var b = a.v.length;
	a.rz.length = b;
	a.rMin = skim.geometry.Max;
	a.rMax = -skim.geometry.Max;
	a.zMax = -skim.geometry.Max;
	a.zMin = skim.geometry.Max;
	a.lMax = -skim.geometry.Max;
	a.thickMin = skim.geometry.Max;
	a.thickMax = -skim.geometry.Max;
	var c = Array(4),
	d = Array(4);
	new THREE.Vector3;
	for (var e = 0; e < a.v.length; e += 4) {
		for (var f = 0; 4 > f; ++f)
			c[f] = a.v[e + f].getPos(), d[f] = skim.geometry.GetXAngleFromPoint(a.v[e].getPos()), a.rz[e + f] = skim.ringUtils.Convert3DPointToRZ(c[f]);
		skim.utils.assert(1E-6 > Math.abs(d[0] - d[1]) && 1E-6 > Math.abs(d[0] - d[2]) && 1E-6 > Math.abs(d[0] - d[3]), "Ring: 4 points making a constraint must belong to the same plane passing through z axis");
		skim.utils.assert(skim.geometry.IsTrigoOriented(a.rz[e], a.rz[e + 1], a.rz[e + 2], a.rz[e + 3]), "RingReactor : 4 points making a constraint must be direct oriented in (r,z)");
		skim.utils.assert(skim.geometry.IsConvex(a.rz[e], a.rz[e + 1], a.rz[e + 2], a.rz[e + 3]), "RingReactor : 4 points making a constraint must make a convex 2D form");
		for (f = 0; 4 > f; f++) {
			a.rMin > a.rz[e + f].x && (a.rMin = a.rz[e + f].x);
			a.rMax < a.rz[e + f].x && (a.rMax = a.rz[e + f].x);
			a.zMin > a.rz[e + f].y && (a.zMin = a.rz[e + f].y);
			a.zMax < a.rz[e + f].y && (a.zMax = a.rz[e + f].y);
			var g = a.v[e + f].getThickness();
			a.thickMin > g && (a.thickMin = g);
			a.thickMax < g && (a.thickMax = g)
		}
	}
	a.lMax = a.zMax - a.zMin;
	f = 2 * Math.PI;
	c = a.theta.length;
	d = [];
	d.length = c;
	if (4 < b) {
		for (e = 0; e < c - 1; e++)
			d[e] = Math.abs(a.theta[e + 1] - a.theta[e]), 0 !== d[e] && (f = Math.min(f, d[e]));
		d[e] = Math.abs(2 * Math.PI + a.theta[0]) - a.theta[c - 1];
		0 !== d[e] && (f = Math.min(f,
					d[e]))
	}
	if (1E-5 > f)
		if (8 === b || 4 === b)
			b = 4, a.arcStep = 1;
		else
			for (skim.utils.assert(8 === b, "Rings constraints are too close to one another!"), d.sort(function (a, b) {
					return a - b
				}), e = 0; e < d.length; e++) {
				if (0.01 < d[e]) {
					a.arcStep = Math.ceil(2 * Math.PI / d[e]);
					break
				}
			}
	else
		a.arcStep = Math.ceil(2 * Math.PI / f);
	if (1 == b / 4)
		a.constraintsIndices.length = 1, a.constraintsIndices[0] = [0, 0];
	else {
		a.constraintsIndices.length = a.arcStep;
		for (var h, e = 0; e < a.arcStep; e++) {
			c = 2 * Math.PI * e / a.arcStep;
			for (f = 0; c > a.theta[f]; )
				f++;
			Math.abs(c - (0 === f ? a.theta[b /
						4 - 1] - 2 * Math.PI : a.theta[f - 1])) < 2 * Math.PI / a.arcStep ? 0 === e ? h = [4 * this.cleanIndex(f - 2, b / 4), 4 * this.cleanIndex(f - 1, b / 4), 4 * this.cleanIndex(f, b / 4)] : a.constraintsIndices[e - 1] = [4 * this.cleanIndex(f - 2, b / 4), 4 * this.cleanIndex(f - 1, b / 4), 4 * this.cleanIndex(f, b / 4)] : 0 === e ? h = [4 * this.cleanIndex(f - 1, b / 4), 4 * this.cleanIndex(f, b / 4)] : a.constraintsIndices[e - 1] = [4 * this.cleanIndex(f - 1, b / 4), 4 * this.cleanIndex(f, b / 4)]
		}
		a.constraintsIndices[a.arcStep - 1] = h
	}
	skim.ringUtils.computeInterpolants(a)
};
skim.ringUtils.computeInterpolants = function (a) {
	for (var b = 0; 4 > b; b++) {
		var c = [],
		d = [],
		e = [],
		f = [],
		g = a.v.length - 4;
		d.push(a.rz[g + b].x);
		e.push(a.rz[g + b].y);
		f.push(a.v[g + b].getThickness());
		c.push(a.theta[g / 4] - 2 * Math.PI);
		for (g = 0; g < a.v.length; g += 4)
			d.push(a.rz[g + b].x), e.push(a.rz[g + b].y), f.push(a.v[g + b].getThickness()), c.push(a.theta[g / 4]);
		d.push(a.rz[b].x);
		e.push(a.rz[b].y);
		f.push(a.v[b].getThickness());
		c.push(a.theta[0] + 2 * Math.PI);
		8 <= a.v.length && (d.push(a.rz[b + 4].x), e.push(a.rz[b + 4].y), f.push(a.v[b + 4].getThickness()),
			c.push(a.theta[1] + 2 * Math.PI));
		a.interpolantFunctions.radial.push(skim.geometry.createInterpolant(c, d));
		a.interpolantFunctions.height.push(skim.geometry.createInterpolant(c, e));
		a.interpolantFunctions.thickness.push(skim.geometry.createInterpolant(c, f))
	}
};
skim.ringUtils.getRZTFromAngle = function (a, b, c) {
	var d = a.rz[c - 1].x,
	e = a.rz[c - 1].y,
	f = a.v[c - 1].getThickness();
	if (1 === a.rz.length / 4 || 1 === a.constraintsIndices.length)
		return new THREE.Vector3(d, e, f);
	d = skim.ringUtils.getIntervalConstraints(a, b);
	e = a.theta[d[0] / 4];
	f = a.theta[d[1] / 4];
	e > f && (f >= b && 0 <= b && (b = 2 * Math.PI + b), f = 2 * Math.PI + f);
	skim.utils.assert(e <= b, "angle not big enough");
	skim.utils.assert(b <= f, "angle is too big");
	f = d[0] / 4 + 1;
	d = a.interpolantFunctions.radial[c - 1](b, f);
	e = a.interpolantFunctions.height[c - 1](b,
			f);
	f = a.interpolantFunctions.thickness[c - 1](b, f);
	return new THREE.Vector3(d, e, f)
};
skim.ringUtils.getIntervalConstraints = function (a, b) {
	var c = skim.ringUtils.GetFlooredIndexFromAngle(b, a.arcStep),
	c = a.constraintsIndices[c];
	3 === c.length && (c = b > a.theta[c[1] / 4] ? [c[1], c[2]] : [c[0], c[1]]);
	skim.utils.assert(2 == c.length, "we should only be between two constraints");
	return c
};
skim.ringUtils.cleanIndex = function (a, b) {
	var c = a;
	if (0 === b)
		return skim.error("Lenght of the array should not be null"), c;
	if (1 === b)
		return 0;
	0 > a && (c = (b + a) % b);
	a >= b && (c = a % b);
	return c
};
skim.ringUtils.getSetIdxFromId = function (a, b) {
	for (var c = 0; c < a.v.length; c++)
		if (a.v[c].id == b)
			return c = 4 * Math.floor(c / 4);
	skim.utils.assert(!1, "Did not find the vertex id in the ring vertices array");
	return -1
};
skim.ringUtils.getMaxZDist = function (a) {
	for (var b = new THREE.Vector3, c = 0, d = 0, e; c < a.length; c += 4)
		e = b.subVectors(a[c].getPos(), a[c + 3].getPos()).length(), d = e > d ? e : d, e = b.subVectors(a[c + 1].getPos(), a[c + 2].getPos()).length(), d = e > d ? e : d;
	return d
};
skim.ringUtils.hasChanged = function (a, b) {
	if (a.v.length != b.v.length)
		return !0;
	for (var c = 0; c < a.v.length; c++) {
		var d = a.v[c].getPos(),
		e = b.v[c].getPos();
		if (!d.equals(e))
			return !0;
		d = a.v[c].getThickness();
		e = b.v[c].getThickness();
		if (d != e)
			return !0
	}
	return !1
};
skim.ringUtils.hasVert = function (a, b) {
	for (var c = 0; c < a.v.length; c++)
		if (a.v[c].id == b)
			return !0;
	return !1
};
skim.ringUtils.createVertControlSet = function (a, b, c, d, e, f) {
	var g = [];
	a = this.createVertControlSetPos(a, b, c, d, e);
	for (b = 0; 4 > b; b++)
		g.push(new skim.engine.VertexDef(a[b], f, skim.instances.defaultMaterial, skim.VolType.Mech));
	return {
		vert : g,
		pos : a
	}
};
skim.ringUtils.createVertControlSetPos = function (a, b, c, d, e) {
	var f,
	g,
	h = [];
	f = b + c / 2;
	g = e + d / 2;
	h.push(new THREE.Vector3(f * Math.cos(a), f * Math.sin(a), g));
	f = b - c / 2;
	g = e + d / 2;
	h.push(new THREE.Vector3(f * Math.cos(a), f * Math.sin(a), g));
	f = b - c / 2;
	g = e - d / 2;
	h.push(new THREE.Vector3(f * Math.cos(a), f * Math.sin(a), g));
	f = b + c / 2;
	g = e - d / 2;
	h.push(new THREE.Vector3(f * Math.cos(a), f * Math.sin(a), g));
	return h
};
skim.ringUtils.evalMechForRing = function (a, b, c, d) {
	var e,
	f,
	g,
	h = new THREE.Vector3,
	k = new THREE.Vector3;
	k.set(0, 0, 0);
	k.subVectors(b, new THREE.Vector3);
	h.set(k.x, k.y, 0);
	e = skim.geometry.GetXAngleFromPoint(h);
	f = Math.cos(e);
	g = Math.sin(e);
	var h = skim.ringUtils.getRZTFromAngle(a, e, 1),
	k = skim.ringUtils.getRZTFromAngle(a, e, 2),
	l = skim.ringUtils.getRZTFromAngle(a, e, 3);
	e = skim.ringUtils.getRZTFromAngle(a, e, 4);
	var m = skim.geometry.isInsidePolygon(skim.ringUtils.Convert3DPointToRZ(b), h, k, l, e),
	n = h.z,
	p = k.z,
	q = l.z,
	r = e.z;
	h.set(h.x *
		f, h.x * g, h.y);
	k.set(k.x * f, k.x * g, k.y);
	l.set(l.x * f, l.x * g, l.y);
	e.set(e.x * f, e.x * g, e.y);
	m ? (m = [], f = [], g = new THREE.Vector3, n = skim.geometry.getBarycenter([h, k, l, e], [n, p, q, r]), m[0] = skim.geometry.GetIntersectionFiniteSegmentAndLine(n, b, h, k), m[1] = skim.geometry.GetIntersectionFiniteSegmentAndLine(n, b, k, l), m[2] = skim.geometry.GetIntersectionFiniteSegmentAndLine(n, b, l, e), m[3] = skim.geometry.GetIntersectionFiniteSegmentAndLine(n, b, e, h), f[0] = g.subVectors(m[0], n).length(), f[1] = g.subVectors(m[1], n).length(), f[2] = g.subVectors(m[2],
				n).length(), f[3] = g.subVectors(m[3], n).length(), h = f.indexOf(Math.min.apply(Math, f)), l = g.clone().subVectors(b, n).length(), k = skim.blobtree.Poly6Eval(0) * skim.blobtree.Poly6NF0D, d.v = k + skim.blobtree.Poly6Eval(skim.blobtree.KS * (1 - l / f[h])) * skim.blobtree.Poly6NF0D, c & skim.blobtree.EvalTags.Mat && d.m.copy(a.materials[0]), c & skim.blobtree.EvalTags.Grad && (a.p_eps.copy(b), a.p_eps.x += 1E-5, a.evalMech(a.p_eps, skim.blobtree.EvalTags.Value, a.ev_eps), d.g.x = (a.ev_eps.v - d.v) / 1E-5, a.p_eps.x -= 1E-5, a.p_eps.y += 1E-5, a.evalMech(a.p_eps,
				skim.blobtree.EvalTags.Value, a.ev_eps), d.g.y = (a.ev_eps.v - d.v) / 1E-5, a.p_eps.y -= 1E-5, a.p_eps.z += 1E-5, a.evalMech(a.p_eps, skim.blobtree.EvalTags.Value, a.ev_eps), d.g.z = (a.ev_eps.v - d.v) / 1E-5)) : (d.v = skim.blobtree.neutral_value, skim.ringUtils.evalMechForSegment(a, b, h, k, n, p, c, d), skim.ringUtils.evalMechForSegment(a, b, k, l, p, q, c, d), skim.ringUtils.evalMechForSegment(a, b, l, e, q, r, c, d), skim.ringUtils.evalMechForSegment(a, b, e, h, r, n, c, d))
};
skim.ringUtils.isSphereInsideCylinders = function (a, b, c, d, e, f, g, h) {
	skim.utils.assert(c >= d, "radial definition is slanted");
	skim.utils.assert(e >= f, "height definition is slanted");
	skim.utils.assert(g >= h, "thickness definition is slanted");
	h = Math.sqrt(a.x * a.x + a.y * a.y);
	a = a.z;
	g *= skim.blobtree.KS;
	return h + b < d - g || h - b > c + g || a + b < f - g || a - b > e + g ? !1 : !0
};
skim.ringUtils.isInsideCappedCylinders = function (a, b, c, d, e, f, g, h) {
	var k = Math.sqrt(a.x * a.x + a.y * a.y);
	a = Math.sqrt(a.z * a.z);
	if (0 === b)
		return k < c + g * skim.blobtree.KS && k > d - h * skim.blobtree.KS && a < e + g * skim.blobtree.KS && a > f - h * skim.blobtree.KS;
	d = k > d - h * skim.blobtree.KS + b || k > d - h * skim.blobtree.KS - b;
	return (k < c + g * skim.blobtree.KS + b || k < c + g * skim.blobtree.KS - b) && d ? (c = a > f - h * skim.blobtree.KS + b || a > f - h * skim.blobtree.KS - b, (a < e + g * skim.blobtree.KS + b || a < e + g * skim.blobtree.KS - b) && c) : !1
};
skim.ringUtils.evalMechForSegment = function (a, b, c, d, e, f, g, h) {
	var k = 0,
	l = 0,
	m = 0,
	n = 0,
	p = n = 0,
	l = new THREE.Vector3;
	l.subVectors(d, c);
	var m = l.lengthSq(),
	q = Math.sqrt(m),
	r = new THREE.Vector3(l.x, l.y, l.z);
	r.multiplyScalar(1 / q);
	n = e;
	p = f - e;
	q = new THREE.Vector3;
	q.subVectors(b, c);
	var t = q.dot(l),
	s = q.lengthSq(),
	k = m * n + t * p,
	l = 0 > p ? 0 : 1;
	0 < k && (l = t * n + s * p, l = 0 > l ? 0 : l > k ? 1 : l / k);
	m = Math.sqrt(l * (l * m - 2 * t) + s);
	n = skim.blobtree.Poly6Eval(m / (n + l * p)) * skim.blobtree.Poly6NF0D;
	n > h.v && (h.v = n, g & skim.blobtree.EvalTags.Mat && (r.dot(q), h.m.copy(a.materials[0])),
		g & skim.blobtree.EvalTags.Grad && (a.p_eps.copy(b), a.p_eps.x += 1E-5, a.ev_eps = {
				v : -1
			}, skim.ringUtils.evalMechForSegment(a, a.p_eps, c, d, e, f, skim.blobtree.EvalTags.Value, a.ev_eps), h.g.x = (a.ev_eps.v - h.v) / 1E-5, a.p_eps.x -= 1E-5, a.p_eps.y += 1E-5, a.ev_eps = {
				v : -1
			}, skim.ringUtils.evalMechForSegment(a, a.p_eps, c, d, e, f, skim.blobtree.EvalTags.Value, a.ev_eps), h.g.y = (a.ev_eps.v - h.v) / 1E-5, a.p_eps.y -= 1E-5, a.p_eps.z += 1E-5, a.ev_eps = {
				v : -1
			}, skim.ringUtils.evalMechForSegment(a, a.p_eps, c, d, e, f, skim.blobtree.EvalTags.Value, a.ev_eps),
			h.g.z = (a.ev_eps.v - h.v) / 1E-5))
};
skim.ringUtils.uniqControlSets = function (a) {
	for (var b = a.v.slice(0, 4), c = 1; c < a.theta.length; c++)
		if (skim.utils.assert(0 !== a.theta.length && a.theta[c - 1] <= a.theta[c], "ring theta values must be defined and sorted!"), a.theta[c - 1] !== a.theta[c])
			for (var d = 0; 4 > d; d++)
				b.push(a.v[4 * c + d]);
	a.v = b
};
skim.ringUtils.RingNode = function (a) {
	this.v = a;
	this.rMin = 1E17;
	this.zMax = this.rMax = 0;
	this.zMin = 1E17;
	this.lMax = 0;
	this.thickMin = 1E18;
	this.thickMax = 0;
	this.theta = [];
	this.rz = [];
	this.arcStep = 0;
	this.constraintsIndices = [];
	this.ev_eps = {
		v : 0
	};
	this.p_eps = new THREE.Vector3;
	this.interpolantFunctions = {
		radial : [],
		height : [],
		thickness : []
	};
	skim.ringUtils.sortConstraintsByTheta(this);
	skim.ringUtils.uniqControlSets(this);
	skim.ringUtils.computeConstraints(this)
};
skim.textUtils = {};
skim.textUtils.compareImageDatas = function (a, b) {
	if (a.data.length !== b.data.length)
		return !1;
	for (var c = 0; c < a.data.length; ++c)
		if (a.data[c] !== b.data[c])
			return !1;
	return !0
};
skim.textUtils.SSEDT8 = function (a, b, c) {
	this.width = b;
	this.height = c;
	this.grid = a;
	this.outside = 1E4;
	this.outofrange = {
		x : this.outside,
		y : this.outside
	};
	this.inc = 0;
	this.incMaxSize = 100
};
skim.textUtils.SSEDT8.prototype.grid_get = function (a, b, c) {
	return 0 > b || 0 > c || b > this.width - 1 || c > this.height - 1 ? this.outofrange : a[c * this.width + b]
};
skim.textUtils.SSEDT8.prototype.grid_put = function (a, b, c, d) {
	a[c * this.width + b] = d
};
skim.textUtils.SSEDT8.prototype.lengthSq = function (a) {
	return a.x * a.x + a.y * a.y
};
skim.textUtils.SSEDT8.prototype.grid_compare = function (a, b, c, d, e, f) {
	var g = {
		x : 0,
		y : 0
	};
	a = this.grid_get(a, c + e, d + f);
	g.x = a.x + e;
	g.y = a.y + f;
	this.lengthSq(g) < this.lengthSq(b) && (b.x = g.x, b.y = g.y);
	return b
};
skim.textUtils.SSEDT8.prototype.propagate = function (a) {
	var b,
	c,
	d;
	for (d = 0; d < this.height; d++) {
		for (c = 0; c < this.width; c++)
			b = this.grid_get(a, c, d), b = this.grid_compare(a, b, c, d, -1, 0), b = this.grid_compare(a, b, c, d, 0, -1), b = this.grid_compare(a, b, c, d, -1, -1), b = this.grid_compare(a, b, c, d, 1, -1), this.grid_put(a, c, d, b);
		for (c = this.width - 1; 0 <= c; c--)
			b = this.grid_get(a, c, d), b = this.grid_compare(a, b, c, d, 1, 0), this.grid_put(a, c, d, b);
		skim.textUtils.sendProgressSDF(this.inc++, this.incMaxSize, 10)
	}
	for (d = this.height - 1; 0 <= d; d--) {
		for (c =
				this.width - 1; 0 <= c; c--)
			b = this.grid_get(a, c, d), b = this.grid_compare(a, b, c, d, 1, 0), b = this.grid_compare(a, b, c, d, 0, 1), b = this.grid_compare(a, b, c, d, -1, 1), b = this.grid_compare(a, b, c, d, 1, 1), this.grid_put(a, c, d, b);
		for (c = 0; c < this.width; c++)
			b = this.grid_get(a, c, d), b = this.grid_compare(a, b, c, d, -1, 0), this.grid_put(a, c, d, b);
		skim.textUtils.sendProgressSDF(this.inc++, this.incMaxSize, 10)
	}
};
skim.textUtils.SSEDT8.prototype.signedDistanceFieldsFromGrid = function () {
	var a,
	b,
	c = [],
	d = [],
	e;
	this.inc = 0;
	this.incMaxSize = 5 * this.height;
	skim.Proxy.sendProgress(4, 0);
	for (b = 0; b < this.height; b++) {
		for (a = 0; a < this.width; a++)
			e = b * this.width + a, this.grid[e] ? (this.grid_put(c, a, b, {
					x : 0,
					y : 0
				}), this.grid_put(d, a, b, {
					x : this.outside,
					y : this.outside
				})) : (this.grid_put(c, a, b, {
					x : this.outside,
					y : this.outside
				}), this.grid_put(d, a, b, {
					x : 0,
					y : 0
				}));
		skim.textUtils.sendProgressSDF(this.inc++, this.incMaxSize, 10)
	}
	this.propagate(c);
	this.propagate(d);
	var f = new Float32Array(this.height * this.width),
	g,
	h;
	for (b = 0; b < this.height; b++)
		for (a = 0; a < this.width; a++)
			e = b * this.width + a, g = Math.sqrt(this.lengthSq(this.grid_get(c, a, b))), h = Math.sqrt(this.lengthSq(this.grid_get(d, a, b))), g -= h, f[e] = g;
	return {
		data : f,
		width : this.width,
		height : this.height
	}
};
skim.textUtils.sendProgressSDF = function (a, b, c) {
	skim.Proxy.sendProgress(4, 100 * a / b)
};
skim.textUtils.SSEDT8.prototype.unsignedDistanceFieldsFromGrid = function () {
	var a,
	b,
	c = [],
	d;
	this.inc = 0;
	this.incMaxSize = 3 * this.height;
	skim.Proxy.sendProgress(4, 0);
	for (b = 0; b < this.height; b++) {
		for (a = 0; a < this.width; a++)
			d = b * this.width + a, this.grid[d] ? this.grid_put(c, a, b, {
				x : 0,
				y : 0
			}) : this.grid_put(c, a, b, {
				x : this.outside,
				y : this.outside
			});
		skim.textUtils.sendProgressSDF(this.inc++, this.incMaxSize, 10)
	}
	this.propagate(c);
	var e = new Float32Array(this.height * this.width);
	for (b = 0; b < this.height; b++)
		for (a = 0; a < this.width; a++)
			d =
				b * this.width + a, e[d] = Math.sqrt(this.lengthSq(this.grid_get(c, a, b)));
	return {
		data : e,
		width : this.width,
		height : this.height
	}
};
skim.textUtils.computeSignedDistanceField = function (a) {
	a = skim.textUtils.imageDataToBinary(a);
	return (new skim.textUtils.SSEDT8(a.data, a.width, a.height)).signedDistanceFieldsFromGrid()
};
skim.textUtils.computeUnsignedDistanceField = function (a) {
	a = skim.textUtils.imageDataToBinary(a);
	return (new skim.textUtils.SSEDT8(a.data, a.width, a.height)).unsignedDistanceFieldsFromGrid()
};
skim.textUtils.imageDataToBinary = function (a) {
	for (var b = {
			data : new Uint8Array(a.width * a.height),
			width : a.width,
			height : a.height
		}, c = 0, d = 0; d < a.height; d++)
		for (var e = 0; e < a.width; e++) {
			var f = 4 * (d * a.width + e);
			125 > a.data[f] && (125 > a.data[f + 1] && 125 > a.data[f + 2]) && (b.data[c] = 1);
			c++
		}
	return b
};
skim.textUtils.imageDataToBinaryImageData = function (a) {
	for (var b = 0; b < a.height; b++)
		for (var c = 0; c < a.width; c++) {
			var d = 4 * (b * a.width + c);
			if (255 !== a.data[d] || 255 !== a.data[d + 1] || 255 !== a.data[d + 2])
				if (0 !== a.data[d] || 0 !== a.data[d + 1] || 0 !== a.data[d + 2])
					a.data[d] = 255, a.data[d + 1] = 0, a.data[d + 2] = 0
		}
};
skim.textUtils.distanceFieldToGreyScale = function (a, b) {
	for (var c = new Uint8ClampedArray(4 * a.width * a.height), d = 0, e = 0; e < a.width * a.height; e++)
		d = a.data[e] > d ? a.data[e] : d;
	for (var f = 0, g = 0, h = 0; f < a.height; f++)
		for (e = 0; e < a.width; e++)
			h = f * a.width + e, -1 > a.data[h] ? (c[g] = 0, c[g + 1] = 0, c[g + 2] = 0) : -1 === a.data[h] ? (c[g] = 255, c[g + 1] = 0, c[g + 2] = 0) : (h = 255 * a.data[h] / d, c[g] = h, c[g + 1] = h, c[g + 2] = h), c[g + 3] = 255, g += 4;
	d = b.createImageData(a.width, a.height);
	d.data.set(c);
	return d
};
skim.textUtils.AntiAliasedInfo = function (a) {
	this.sourcealpha = 1 - a / 255 || 0;
	this.distance = this.alpha = this.destinationalpha = 0;
	this.gradient = new THREE.Vector2;
	this.dY = this.dX = 0
};
skim.textUtils.AntiAliasedComputer = function () {
	this.height = this.width = 0;
	this.dataInfo = [];
	this.inc = 0
};
skim.textUtils.AntiAliasedComputer.prototype.initAntiAliasedComputer = function (a) {
	this.width = a.width;
	this.height = a.height;
	for (var b = 0, c; b < this.width; b++) {
		this.dataInfo[b] = [];
		for (var d = 0; d < this.height; d++)
			c = 4 * (d * this.width + b), this.dataInfo[b][d] = new skim.textUtils.AntiAliasedInfo(a.data[c])
	}
};
skim.textUtils.AntiAliasedComputer.prototype.Generate = function (a) {
	this.initAntiAliasedComputer(a);
	skim.Proxy.sendProgress(4, 0);
	var b;
	for (a = 0; a < this.width; a++) {
		for (b = 0; b < this.height; b++)
			this.dataInfo[a][b].alpha = 1 - this.dataInfo[a][b].sourcealpha;
		skim.textUtils.sendProgressSDF(this.inc++, 2 * this.height, 10)
	}
	this.ComputeEdgeGradients();
	this.GenerateDistanceTransform();
	this.PostProcess(4);
	for (a = 0; a < this.width; a++) {
		for (b = 0; b < this.height; b++)
			this.dataInfo[a][b].alpha = this.dataInfo[a][b].sourcealpha;
		skim.textUtils.sendProgressSDF(this.inc++,
			2 * this.height, 10)
	}
	this.ComputeEdgeGradients();
	this.GenerateDistanceTransform();
	this.PostProcess(4);
	var c = {
		data : new Float32Array(this.width * this.height),
		width : this.width,
		height : this.height
	};
	for (b = 0; b < this.height; b++)
		for (a = 0; a < this.width; a++)
			c.data.push(this.dataInfo[a][b].distance);
	return c
};
skim.textUtils.AntiAliasedComputer.prototype.ComputeEdgeGradients = function () {
	for (var a = Math.sqrt(2), b = 1; b < this.width - 1; b++)
		for (var c = 1; c < this.height - 1; c++)
			if (0 < this.dataInfo[b][c].alpha && 1 > this.dataInfo[b][c].alpha) {
				var d = -this.dataInfo[b - 1][c - 1].alpha - this.dataInfo[b - 1][c + 1].alpha + this.dataInfo[b + 1][c - 1].alpha + this.dataInfo[b + 1][c + 1].alpha;
				this.dataInfo[b][c].gradient.x = d + (this.dataInfo[b + 1][c].alpha - this.dataInfo[b - 1][c].alpha) * a;
				this.dataInfo[b][c].gradient.y = d + (this.dataInfo[b][c + 1].alpha - this.dataInfo[b][c -
							1].alpha) * a;
				this.dataInfo[b][c].gradient.normalize()
			}
};
skim.textUtils.AntiAliasedComputer.prototype.ApproximateEdgeDelta = function (a, b, c) {
	if (0 === a || 0 === b)
		return 0.5 - c;
	var d = Math.sqrt(a * a + b * b);
	b /= d;
	a = Math.abs(a / d);
	b = Math.abs(b);
	a < b && (d = a, a = b, b = d);
	d = 0.5 * b / a;
	return c < d ? 0.5 * (a + b) - Math.sqrt(2 * a * b * c) : c < 1 - d ? (0.5 - c) * a : -0.5 * (a + b) + Math.sqrt(2 * a * b * (1 - c))
};
skim.textUtils.AntiAliasedComputer.prototype.UpdateDistance = function (a, b, c, d, e) {
	var f = this.dataInfo[b + d][c + e];
	b = this.dataInfo[b + d - f.dX][c + e - f.dY];
	0 !== b.alpha && b !== a && (d = f.dX - d, e = f.dY - e, f = Math.sqrt(d * d + e * e) + this.ApproximateEdgeDelta(d, e, b.alpha), f < a.distance && (a.distance = f, a.dX = d, a.dY = e))
};
skim.textUtils.AntiAliasedComputer.prototype.GenerateDistanceTransform = function () {
	var a,
	b,
	c;
	for (a = 0; a < this.width; a++)
		for (b = 0; b < this.height; b++)
			c = this.dataInfo[a][b], c.dX = 0, c.dY = 0, c.distance = 0 >= c.alpha ? 1E6 : 1 > c.alpha ? this.ApproximateEdgeDelta(c.gradient.x, c.gradient.y, c.alpha) : 0;
	for (b = 1; b < this.height; b++) {
		c = this.dataInfo[0][b];
		0 < c.distance && (this.UpdateDistance(c, 0, b, 0, -1), this.UpdateDistance(c, 0, b, 1, -1));
		for (a = 1; a < this.width - 1; a++)
			c = this.dataInfo[a][b], 0 < c.distance && (this.UpdateDistance(c, a, b, -1, 0),
				this.UpdateDistance(c, a, b, -1, -1), this.UpdateDistance(c, a, b, 0, -1), this.UpdateDistance(c, a, b, 1, -1));
		c = this.dataInfo[this.width - 1][b];
		0 < c.distance && (this.UpdateDistance(c, this.width - 1, b, -1, 0), this.UpdateDistance(c, this.width - 1, b, -1, -1), this.UpdateDistance(c, this.width - 1, b, 0, -1));
		for (a = this.width - 2; 0 <= a; a--)
			c = this.dataInfo[a][b], 0 < c.distance && this.UpdateDistance(c, a, b, 1, 0)
	}
	for (b = this.height - 2; 0 <= b; b--) {
		c = this.dataInfo[this.width - 1][b];
		0 < c.distance && (this.UpdateDistance(c, this.width - 1, b, 0, 1), this.UpdateDistance(c,
				this.width - 1, b, -1, 1));
		for (a = this.width - 2; 0 < a; a--)
			c = this.dataInfo[a][b], 0 < c.distance && (this.UpdateDistance(c, a, b, 1, 0), this.UpdateDistance(c, a, b, 1, 1), this.UpdateDistance(c, a, b, 0, 1), this.UpdateDistance(c, a, b, -1, 1));
		c = this.dataInfo[0][b];
		0 < c.distance && (this.UpdateDistance(c, 0, b, 1, 0), this.UpdateDistance(c, 0, b, 1, 1), this.UpdateDistance(c, 0, b, 0, 1));
		for (a = 1; a < this.width; a++)
			c = this.dataInfo[a][b], 0 < c.distance && this.UpdateDistance(c, a, b, -1, 0)
	}
};
skim.textUtils.AntiAliasedComputer.prototype.PostProcess = function (a) {
	for (var b = 0; b < this.width; b++)
		for (var c = 0; c < this.height; c++) {
			var d = this.dataInfo[b][c];
			if (!(0 === d.dX && 0 === d.dY || d.distance >= a)) {
				var e = d.dX,
				f = d.dY,
				g = this.dataInfo[b - d.dX][c - d.dY],
				d = g.gradient;
				if (0 !== d.x || 0 !== d.y) {
					var h = this.ApproximateEdgeDelta(d.x, d.y, g.alpha),
					k = f * d.x - e * d.y,
					g = -h * d.x + k * d.y,
					d = -h * d.y - k * d.x;
					0.5 >= Math.abs(g) && 0.5 >= Math.abs(d) && (this.dataInfo[b][c].distance = Math.sqrt((e + g) * (e + g) + (f + d) * (f + d)))
				}
			}
		}
};
skim.textUtils.AntiAliasedComputer.prototype.clamp01 = function (a) {
	return Math.min(Math.max(a, 0), 1)
};
skim.textUtils.computeRadius = function (a) {
	return 0 + (skim.geometry.computeRadialDist(a[0].getPos()) + skim.geometry.computeRadialDist(a[1].getPos())) / 2
};
skim.textUtils.computeHeight = function (a) {
	return (new THREE.Vector3).subVectors(a[3].getPos(), a[0].getPos()).length()
};
skim.textUtils.computeThickness = function (a) {
	return a[0].getThickness()
};
skim.textUtils.computeLength = function (a) {
	return (new THREE.Vector3).subVectors(a[1].getPos(), a[0].getPos()).length()
};
skim.textUtils.computeSDFLength = function (a) {
	a = (new THREE.Vector3).subVectors(a[1].getPos(), a[0].getPos()).length();
	return 1 < a ? a : 1
};
skim.triangleUtils = {};
skim.triangleUtils.computeVectorsDirs = function (a) {
	var b = a.v[0].getPos(),
	c = a.v[1].getPos(),
	d = a.v[2].getPos();
	a.p0p1.subVectors(c, b);
	a.p1p2.subVectors(d, c);
	a.p2p0.subVectors(b, d);
	a.unit_normal.crossVectors(a.p0p1, a.p2p0);
	a.unit_normal.normalize();
	a.length_p0p1 = a.p0p1.length();
	a.unit_p0p1.copy(a.p0p1);
	a.unit_p0p1.divideScalar(a.length_p0p1);
	a.diffThick_p0p1 = a.v[0].getThickness() - a.v[1].getThickness();
	a.length_p1p2 = a.p1p2.length();
	a.unit_p1p2.copy(a.p1p2);
	a.unit_p1p2.divideScalar(a.length_p1p2);
	a.diffThick_p1p2 =
		a.v[1].getThickness() - a.v[2].getThickness();
	a.length_p2p0 = a.p2p0.length();
	a.unit_p2p0.copy(a.p2p0);
	a.unit_p2p0.divideScalar(a.length_p2p0);
	a.diffThick_p2p0 = a.v[2].getThickness() - a.v[0].getThickness();
	c = [];
	c.push({
		vert : a.v[0].getPos(),
		thick : a.v[0].getThickness(),
		idx : 0
	});
	c.push({
		vert : a.v[1].getPos(),
		thick : a.v[1].getThickness(),
		idx : 1
	});
	c.push({
		vert : a.v[2].getPos(),
		thick : a.v[2].getThickness(),
		idx : 2
	});
	c.sort(function (a, b) {
		return a.thick - b.thick
	});
	a.point_min = c[0].vert;
	a.weight_min = c[0].thick;
	var d = skim.ringUtils.cleanIndex(c[0].idx +
			1, 3),
	b = a.v[d].getPos(),
	e = a.v[d].getThickness(),
	d = skim.ringUtils.cleanIndex(c[0].idx + 2, 3),
	c = a.v[d].getPos(),
	f = a.v[d].getThickness(),
	d = new THREE.Vector3,
	d = d.subVectors(b, a.point_min),
	g = new THREE.Vector3,
	g = g.subVectors(c, a.point_min),
	e = e - a.weight_min,
	f = f - a.weight_min;
	if (e < skim.geometry.Epsilon || f < skim.geometry.Epsilon) {
		if (e < f) {
			a.ortho_dir = d.clone();
			a.ortho_dir.normalize();
			a.main_dir.crossVectors(a.ortho_dir, a.unit_normal);
			a.main_dir.normalize();
			0 > a.main_dir.dot(g) && a.main_dir.multiplyScalar(-1);
			var h =
				-a.weight_min / f;
			a.point_iso_zero = new THREE.Vector3(a.point_min.x + h * g.x, a.point_min.y + h * g.y, a.point_min.z + h * g.z)
		} else
			a.ortho_dir = g.clone(), a.ortho_dir.normalize(), a.main_dir.crossVectors(a.ortho_dir, a.unit_normal), a.main_dir.normalize(), 0 > a.main_dir.dot(d) && a.main_dir.multiplyScalar(-1), h = -a.weight_min / e, a.point_iso_zero = new THREE.Vector3(a.point_min.x + h * d.x, a.point_min.y + h * d.y, a.point_min.z + h * d.z);
		Math.abs(e - f) < skim.geometry.Epsilon && (a.proj_dir = a.unit_normal.clone().multiplyScalar(-1), a.equal_weights =
				!0)
	} else {
		h = -a.weight_min / e;
		h = new THREE.Vector3(a.point_min.x + h * d.x, a.point_min.y + h * d.y, a.point_min.z + h * d.z);
		a.point_iso_zero = h;
		var k = -a.weight_min / f,
		k = new THREE.Vector3(a.point_min.x + k * g.x, a.point_min.y + k * g.y, a.point_min.z + k * g.z);
		a.ortho_dir.subVectors(k, h);
		a.ortho_dir.normalize();
		a.main_dir.crossVectors(a.ortho_dir, a.unit_normal);
		a.main_dir.normalize();
		(0 > a.main_dir.dot(d) || 0 > a.main_dir.dot(g)) && a.main_dir.multiplyScalar(-1)
	}
	var h = d.dot(a.main_dir),
	k = g.dot(a.main_dir),
	h = 0 > h ? 0 : h,
	k = 0 > k ? 0 : k,
	l = null;
	h > k ? (l = d, a.half_dir_1 = g, a.point_half = c, a.half_dir_2 = b.clone().subVectors(b, c), a.coord_max = h, a.coord_middle = k / h * a.coord_max, a.unit_delta_weight = e / a.coord_max) : (l = g, a.half_dir_1 = d, a.point_half = b, a.half_dir_2 = c.clone().subVectors(c, b), a.coord_max = k, a.coord_middle = h / k * a.coord_max, a.unit_delta_weight = f / a.coord_max);
	a.longest_dir_special = l.divideScalar(a.coord_max);
	b = new THREE.Vector3;
	b.subVectors(a.half_dir_1, a.longest_dir_special.clone().multiplyScalar(a.coord_middle));
	a.max_seg_length = b.length();
	a.unsigned_ortho_dir =
		a.ortho_dir.clone();
	0 > a.ortho_dir.dot(b) && a.ortho_dir.multiplyScalar(-1)
};
skim.triangleUtils.getParametrisedVertexAttr = function (a, b, c) {
	var d = skim.triangleUtils.getMeanThick(a, b, c),
	e = new THREE.Vector3;
	b = e.subVectors(a.v[1].getPos(), a.v[0].getPos()).multiplyScalar(b);
	c = e.clone().subVectors(a.v[2].getPos(), a.v[0].getPos()).multiplyScalar(c);
	e.addVectors(a.v[0].getPos(), b);
	e.addVectors(e, c);
	return {
		pos : e,
		thick : d
	}
};
skim.triangleUtils.getMeanThick = function (a, b, c) {
	return a.v[0].getThickness() * (1 - b - c) + a.v[1].getThickness() * b + a.v[2].getThickness() * c
};
skim.triangleUtils.getMeanMat = function (a, b, c) {
	var d = new skim.Material(null, null, null);
	a = null === a.materials ? [a.v[0].getMaterial(), a.v[0].getMaterial(), a.v[0].getMaterial()] : [a.materials[0], a.materials[1], a.materials[2]];
	d.weightedMean(a, [1 - b - c, b, c]);
	return d
};
skim.triangleUtils.getTriBaryCoord = function (a, b, c, d) {
	b = b.clone().multiplyScalar(-1);
	var e = (new THREE.Vector3).subVectors(d, c);
	c = a.lengthSq();
	d = a.dot(b);
	a = e.dot(a);
	var f = b.lengthSq();
	b = e.dot(b);
	b = (c * b - d * a) / (c * f - d * d);
	return {
		u : (a - b * d) / c,
		v : b
	}
};
skim.triangleUtils.getUVCoord = function (a, b, c, d) {
	var e = new THREE.Vector3;
	e.crossVectors(a, b);
	var f = new THREE.Matrix4;
	f.set(a.x, b.x, e.x, 0, a.y, b.y, e.y, 0, a.z, b.z, e.z, 0, 0, 0, 0, 1);
	a = new THREE.Matrix4;
	a.getInverse(f);
	c = (new THREE.Vector3).subVectors(d, c);
	c.applyMatrix4(a);
	return {
		u : c.x,
		v : c.y
	}
};
skim.object3DIds = 0;
skim.Object3D = function () {
	this.aabb = new skim.geometry.AABBox;
	this.id = skim.object3DIds++
};
skim.Object3D.prototype.constructor = skim.Object3D;
skim.Object3D.prototype.getAABB = function () {
	skim.utils.assert(!1, "Error : skim.Object3D.prototype.getAABB should be reimplemented in subclasses");
	return this.aabb
};
skim.utils = {};
skim.utils.ltrim = function (a) {
	return a.replace(/^\s+/, "")
};
skim.utils.trim = function (a) {
	return a.replace(/^\s+|\s+$/g, "")
};
skim.utils.remove_prefix = function (a, b) {
	return a.substring(b.length)
};
skim.utils.is_prefix = function (a, b) {
	return 0 === a.indexOf(b)
};
skim.utils.readword = function (a) {
	return a.split(" ")[0]
};
skim.utils.ab2str = function (a) {
	return String.fromCharCode.apply(null, new Uint16Array(a))
};
skim.utils.str2ab = function (a) {
	for (var b = new ArrayBuffer(2 * a.length), c = new Uint16Array(b), d = 0, e = a.length; d < e; d++)
		c[d] = a.charCodeAt(d);
	return b
};
skim.utils.getElementStyle = function (a, b) {
	return window.getComputedStyle ? document.defaultView.getComputedStyle(a, null).getPropertyValue(b) : a.currentStyle ? a.currentStyle[b] : "unknown"
};
skim.utils.debounce = function (a, b, c) {
	var d;
	return function () {
		var e = this,
		f = arguments,
		g = c && !d;
		clearTimeout(d);
		d = setTimeout(function () {
				d = null;
				c || a.apply(e, f)
			}, b);
		g && a.apply(e, f)
	}
};
skim.utils.assert = function (a, b) {
	a || console.error(b)
};
skim.utils.isEmpty = function (a) {
	return 0 === Object.keys(a).length
};
skim.utils.mergeMapObjects = function (a) {
	for (var b = {}, c = 0; c < a.length; ++c)
		for (var d = Object.keys(a[c]), e = 0; e < d.length; ++e)
			b[d[e]] = a[c][d[e]];
	return b
};
skim.utils.getElOffset = function (a) {
	for (var b = 0, c = 0; a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop); )
		b += a.offsetLeft, c += a.offsetTop, a = a.offsetParent;
	return {
		top : c,
		left : b
	}
};
skim.utils.isApproxEqual = function (a, b, c) {
	return Math.abs(a - b) <= c
};
skim.utils.maxSec = 9E3;
skim.utils.Security = function (a) {
	this.counter = 0;
	this.maxSec = a || skim.utils.maxSec;
	this.msg = "-unknown location-";
	this.hasBroken = !1
};
skim.utils.Security.prototype.init = function (a, b) {
	this.counter = 0;
	this.maxSec = a || skim.utils.maxSec;
	this.msg = b || "-unknown location-";
	this.hasBroken = !1
};
skim.utils.Security.prototype.valid = function () {
	if (this.counter < this.maxSec)
		return this.hasBroken = !1, !0;
	console.error("Security breach: " + this.msg);
	this.hasBroken = !0;
	return !1
};
skim.utils.Security.prototype.inc = function () {
	this.counter++
};
skim.utils.HeightMap = function (a, b) {
	this.width = a;
	this.height = b;
	this.data = new Float32Array(a * b);
	this.data_bicubic = new Float32Array((a + 2) * (b + 2));
	this.bicubic_ready = !0;
	this.min_height = this.max_height = 0
};
skim.utils.HeightMap.prototype.constructor = skim.utils.HeightMap;
skim.utils.HeightMap.prototype.buildFromImageData = function (a, b) {
	for (var c = a.data, d = 0; d < this.data.length; ++d)
		this.data[d] = 0.5 * b * (0.21 * c[4 * d] + 0.72 * c[4 * d + 1] + 0.07 * c[4 * d + 2] - 128) / 128, this.data[d] > this.max_height && (this.max_height = this.data[d]), this.data[d] < this.min_height && (this.min_height = this.data[d]);
	this.buildDataForBicubicinterpolation()
};
skim.utils.HeightMap.prototype.buildDataForBicubicinterpolation = function () {
	for (var a = 0, b = 0, a = 0; a < this.width; ++a)
		for (b = 0; b < this.height; ++b)
			this.data_bicubic[(b + 1) * (this.width + 2) + a + 1] = this.data[b * this.width + a];
	for (b = 0; b < this.height; ++b)
		this.data_bicubic[(b + 1) * (this.width + 2)] = this.data[b * this.width], this.data_bicubic[(b + 1) * (this.width + 2) + this.width + 1] = this.data[b * this.width + this.width - 1];
	for (a = 0; a < this.width; ++a)
		this.data_bicubic[a + 1] = this.data[(this.height - 1) * this.width + a], this.data_bicubic[(this.height +
				2 - 1) * (this.width + 2) + a + 1] = this.data[a];
	this.data_bicubic[0] = this.data[this.height * this.width - 1];
	this.data_bicubic[this.width + 2 - 1] = this.data[(this.height - 1) * this.width];
	this.data_bicubic[(this.height + 2 - 1) * (this.width + 2)] = this.data[this.width - 1];
	this.data_bicubic[(this.height + 2) * (this.width + 2) - 1] = this.data[0];
	this.bicubic_ready = !0
};
skim.utils.HeightMap.prototype.buildFromHeightMapData = function (a) {
	this.data = a;
	for (a = 0; a < this.data.length; ++a)
		this.data[a] > this.max_height && (this.max_height = this.data[a]), this.data[a] < this.min_height && (this.min_height = this.data[a]);
	this.buildDataForBicubicinterpolation()
};
skim.utils.HeightMap.prototype.computeMinMaxHeight = function () {
	for (var a = 0; a < this.data.length; ++a)
		this.data[a] > this.max_height && (this.max_height = this.data[a]), this.data[a] < this.min_height && (this.min_height = this.data[a])
};
skim.utils.HeightMap.prototype.getMinHeight = function () {
	return this.min_height
};
skim.utils.HeightMap.prototype.getMaxHeight = function () {
	return this.max_height
};
skim.utils.HeightMap.prototype.setHeight = function (a, b, c) {
	this.data[a + this.width * b] = c;
	this.bicubic_ready = !1
};
skim.utils.HeightMap.prototype.getHeight = function (a, b) {
	return this.data[Math.round(a) + this.width * Math.round(b)]
};
skim.utils.HeightMap.prototype.getBilinearHeight = function (a, b) {
	return skim.geometry.bilinear2DInterp(a, b, this.data[Math.floor(a) + this.width * Math.floor(b)], this.data[Math.floor(a) + this.width * Math.ceil(b)], this.data[Math.ceil(a) + this.width * Math.floor(b)], this.data[Math.ceil(a) + this.width * Math.ceil(b)])
};
skim.utils.HeightMap.prototype.getBicubicHeight = function (a, b) {
	this.bicubic_ready || this.buildDataForBicubicinterpolation();
	a === this.width - 1 && (a -= 1E-9);
	b === this.height - 1 && (b -= 1E-8);
	return skim.geometry.bicubicOptim2DInterp(a + 1, b + 1, this.data_bicubic, this.width + 2)
};
skim.utils.HeightMap.prototype.getHeightFromUV = function (a, b) {
	return this.getHeight(a * (this.width - 1), (1 - b) * (this.height - 1))
};
skim.utils.HeightMap.prototype.getSmartHeightFromUV = function (a, b) {
	return this.getBicubicHeight(a * (this.width - 1), (1 - b) * (this.height - 1))
};
skim.utils.PrintableHeightMap = function (a, b, c) {
	skim.utils.HeightMap.call(this, a, b);
	this.data_ok = new Uint8Array(a * b);
	this.pix_dist = c
};
skim.utils.PrintableHeightMap.prototype = Object.create(skim.utils.HeightMap.prototype);
skim.utils.PrintableHeightMap.prototype.constructor = skim.utils.PrintableHeightMap;
skim.utils.HeightMap.prototype.getOKFromUV = function (a, b) {
	return this.getOK(a * (this.width - 1), (1 - b) * (this.height - 1))
};
skim.utils.HeightMap.prototype.setOK = function (a, b, c) {
	this.data_ok[a + this.width * b] = c ? 1 : 0
};
skim.utils.HeightMap.prototype.getOK = function (a, b) {
	return 0 !== this.data_ok[Math.round(a) + this.width * Math.round(b)]
};
skim.utils.HeightMap.prototype.checkHMapValidity = function () {
	for (var a = [[-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2], [-2, -1], [-1, -1], [0, -1], [1, -1], [2, -1], [-2, 0], [-1, 0], [0, 0], [1, 0], [2, 0], [-2, 1], [-1, 1], [0, 1], [1, 1], [2, 1], [-2, 2], [-1, 2], [0, 2], [1, 2], [2, 2]], b = [[2, 6, 7, 10, 11], [2, 7, 8, 13, 14], [13, 14, 17, 18, 22], [10, 11, 16, 17, 22], [6, 7, 8, 11, 13, 16, 17, 18], [16, 17, 18, 21, 22, 23], [5, 6, 10, 11, 15, 16], [1, 2, 3, 6, 7, 8], [8, 9, 13, 14, 18, 19]], c = 0, d = 2; d < this.width - 3 + 1; ++d)
		for (var e = 2; e < this.height - 3 + 1; ++e) {
			for (var f = this.getHeight(d, e), g = !1, h =
					0; h < b.length && !g; ++h) {
				for (var k = !0, l = 0; l < b[h].length; ++l)
					var m = a[b[h][l]], k = k && f - this.pix_dist <= this.getHeight(d + m[0], e + m[1]);
				g = g || k
			}
			c += g ? 0 : 1;
			this.setOK(d, e, g)
		}
	console.log("Height map checking done : " + 100 * c / (this.width * this.height) + "% of pixels not printable")
};
skim.utils.HeightMap.prototype.makeHMapValid = function () {
	for (var a = [[0, -1], [-1, 0], [1, 0], [0, 1], [-1, -1], [1, -1], [-1, 1], [1, 1]], b = 2; b < this.width - 3 + 1; ++b)
		for (var c = 2; c < this.height - 3 + 1; ++c)
			if (!this.getOK(b, c))
				for (var d = this.getHeight(b, c), e = 0; e < a.length; e++) {
					var f = b + a[e][0],
					g = c + a[e][1];
					this.getHeight(f, g) < d - this.pix_dist && (4 > e ? this.setHeight(f, g, d - 0.5 * this.pix_dist) : this.setHeight(f, g, d - this.pix_dist))
				}
};
skim.utils.ArrayBufferMesh = function (a) {
	this.vertices = new Float32Array(3 * a);
	this.normals = new Float32Array(3 * a);
	this.faces = new Int32Array(6 * a);
	this.metallic = this.roughness = this.colors = null;
	this.n_faces = this.n_vertices = 0
};
skim.utils.ArrayBufferMesh.prototype.enableVertexColor = function () {
	skim.utils.assert(null === this.colors, "Error : colors are already enabled on this mesh");
	this.colors = new Float32Array(this.vertices.length);
	for (var a = 0; a < this.colors.length; ++a)
		this.colors[a] = 0
};
skim.utils.ArrayBufferMesh.prototype.isVertexColorEnabled = function () {
	return null !== this.colors
};
skim.utils.ArrayBufferMesh.prototype.disableVertexColor = function () {
	this.colors = null
};
skim.utils.ArrayBufferMesh.prototype.enableVertexRoughness = function () {
	skim.utils.assert(null === this.roughness, "Error : colors are already enabled on this mesh");
	this.roughness = new Float32Array(this.vertices.length / 3);
	for (var a = 0; a < this.roughness.length; ++a)
		this.roughness[a] = 0
};
skim.utils.ArrayBufferMesh.prototype.disableVertexRoughness = function () {
	this.roughness = null
};
skim.utils.ArrayBufferMesh.prototype.isVertexRoughnessEnabled = function () {
	return null !== this.roughness
};
skim.utils.ArrayBufferMesh.prototype.enableVertexMetallic = function () {
	skim.utils.assert(null === this.metallic, "Error : colors are already enabled on this mesh");
	this.metallic = new Float32Array(this.vertices.length / 3);
	for (var a = 0; a < this.metallic.length; ++a)
		this.metallic[a] = 0
};
skim.utils.ArrayBufferMesh.prototype.disableVertexMetallic = function () {
	this.metallic = null
};
skim.utils.ArrayBufferMesh.prototype.isVertexMetallicEnabled = function () {
	return null !== this.metallic
};
skim.utils.ArrayBufferMesh.prototype.copyVertexInVector3 = function (a, b) {
	b.set(this.getVX(a), this.getVY(a), this.getVZ(a));
	return b
};
skim.utils.ArrayBufferMesh.prototype.copyNormalInVector3 = function (a, b) {
	b.set(this.getNX(a), this.getNY(a), this.getNZ(a));
	return b
};
skim.utils.ArrayBufferMesh.prototype.computeFaceNormals = function () {
	for (var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3, d = new THREE.Vector3, e = new THREE.Vector3, f = new Float32Array(this.n_faces), g = 0; g < this.n_faces; ++g) {
		var h = this.getFA(g);
		c.set(this.getVX(h), this.getVY(h), this.getVZ(h));
		h = this.getFB(g);
		d.set(this.getVX(h), this.getVY(h), this.getVZ(h));
		h = this.getFC(g);
		e.set(this.getVX(h), this.getVY(h), this.getVZ(h));
		a.subVectors(e, d);
		b.subVectors(c, d);
		a.cross(b);
		a.normalize();
		f[3 * g] = a.x;
		f[3 * g + 1] = a.y;
		f[3 * g + 2] = a.z
	}
	return f
};
skim.utils.ArrayBufferMesh.prototype.computeVertexNormals = function (a, b) {
	for (var c = new Float32Array(this.vertices.length), d = Array(this.n_vertices), e = 0; e < this.n_vertices; ++e)
		d[e] = new THREE.Vector3;
	if (a)
		for (var f = new THREE.Vector3, g = new THREE.Vector3, h = new THREE.Vector3, k = new THREE.Vector3, l = new THREE.Vector3, e = 0; e < this.n_faces; ++e) {
			var m = this.getFA(e);
			f.set(this.getVX(m), this.getVY(m), this.getVZ(m));
			var n = this.getFB(e);
			g.set(this.getVX(n), this.getVY(n), this.getVZ(n));
			var p = this.getFC(e);
			h.set(this.getVX(p),
				this.getVY(p), this.getVZ(p));
			k.subVectors(h, g);
			l.subVectors(f, g);
			k.cross(l);
			d[m].add(k);
			d[n].add(k);
			d[p].add(k)
		}
	else
		for (f = new THREE.Vector3, e = 0; e < this.n_faces; ++e)
			m = this.getFA(e), n = this.getFB(e), p = this.getFC(e), f.set(b[3 * e], b[3 * e + 1], b[3 * e + 2]), d[m].add(f), d[n].add(f), d[p].add(f);
	for (e = 0; e < this.n_vertices; ++e)
		d[e].normalize(), c[3 * e] = d[e].x, c[3 * e + 1] = d[e].y, c[3 * e + 2] = d[e].z;
	this.normals = c
};
skim.utils.ArrayBufferMesh.prototype.set = function (a, b, c, d, e, f, g, h) {
	this.vertices = a;
	this.faces = c;
	this.colors = d;
	this.roughness = e;
	this.metallic = f;
	this.n_vertices = g;
	this.n_faces = h;
	b.length !== this.vertices.length ? (0 !== b.length && console.warn("WARNING : ArrayBufferMesh set called with normals and vertices arrays of different sizes, normals will be recomputed"), this.computeVertexNormals(!0, null)) : this.normals = b;
	return this
};
skim.utils.ArrayBufferMesh.prototype.clone = function () {
	var a = new skim.utils.ArrayBufferMesh(10);
	a.copy(this);
	return a
};
skim.utils.ArrayBufferMesh.prototype.copy = function (a) {
	this.set(a.vertices.slice(0, a.vertices.length), a.normals.slice(0, a.normals.length), a.faces.slice(0, a.faces.length), null !== a.colors ? a.colors.slice(0, a.colors.length) : null, null !== a.roughness ? a.roughness.slice(0, a.roughness.length) : null, null !== a.metallic ? a.metallic.slice(0, a.metallic.length) : null, a.n_vertices, a.n_faces)
};
skim.utils.ArrayBufferMesh.prototype.initAB = function (a, b) {
	var c = b;
	void 0 === c && (c = 2 * a);
	this.vertices = new Float32Array(3 * a);
	this.normals = new Float32Array(3 * a);
	this.faces = new Int32Array(3 * c);
	this.isVertexColorEnabled() && (this.colors = new Float32Array(3 * a));
	this.isVertexRoughnessEnabled() && (this.roughness = new Float32Array(a));
	this.isVertexMetallicEnabled() && (this.metallic = new Float32Array(a));
	this.n_faces = this.n_vertices = 0
};
skim.utils.ArrayBufferMesh.prototype.clear = function () {
	this.initAB(16)
};
skim.utils.ArrayBufferMesh.prototype.resizeAB = function (a, b) {
	var c = this.vertices,
	d = this.normals,
	e = this.faces,
	f = this.n_vertices,
	g = this.n_faces,
	h = this.colors,
	k = this.roughness,
	l = this.metallic;
	this.initAB(a, b);
	this.n_vertices = f;
	this.n_faces = g;
	for (f = 0; f < 3 * this.n_vertices; ++f)
		this.vertices[f] = c[f], this.normals[f] = d[f];
	if (this.isVertexColorEnabled())
		for (f = 0; f < 3 * this.n_vertices; ++f)
			this.colors[f] = h[f];
	if (this.isVertexRoughnessEnabled())
		for (f = 0; f < this.n_vertices; ++f)
			this.roughness[f] = k[f];
	if (this.isVertexMetallicEnabled())
		for (f =
				0; f < this.n_vertices; ++f)
			this.metallic[f] = l[f];
	for (f = 0; f < 3 * this.n_faces; ++f)
		this.faces[f] = e[f]
};
skim.utils.ArrayBufferMesh.prototype.extendAB = function () {
	this.resizeAB(0 === this.n_vertices ? 16 : 2 * this.n_vertices, 0 === this.n_faces ? 16 : 2 * this.n_faces)
};
skim.utils.ArrayBufferMesh.prototype.minimizeAB = function () {
	this.resizeAB(this.n_vertices, this.n_faces)
};
skim.utils.ArrayBufferMesh.prototype.pushVertexAB = function (a, b, c, d, e) {
	var f = 3 * this.n_vertices;
	f + 3 > this.vertices.length && this.extendAB();
	this.vertices[f] = a.x;
	this.vertices[f + 1] = a.y;
	this.vertices[f + 2] = a.z;
	this.normals[f] = b.x;
	this.normals[f + 1] = b.y;
	this.normals[f + 2] = b.z;
	this.isVertexColorEnabled() && (null !== c ? (this.colors[f] = c.r, this.colors[f + 1] = c.g, this.colors[f + 2] = c.b) : (this.colors[f] = 0, this.colors[f + 1] = 0, this.colors[f + 2] = 0));
	this.isVertexRoughnessEnabled() && (this.roughness[this.n_vertices] = null !== d ?
			d : 0);
	this.isVertexMetallicEnabled() && (this.metallic[this.n_vertices] = null !== e ? e : 0);
	this.n_vertices++
};
skim.utils.ArrayBufferMesh.prototype.pushFaceAB = function (a, b, c) {
	var d = 3 * this.n_faces;
	d + 3 > this.faces.length && this.extendAB();
	this.faces[d] = a;
	this.faces[d + 1] = b;
	this.faces[d + 2] = c;
	this.n_faces++
};
skim.utils.ArrayBufferMesh.prototype.setVertex = function (a, b) {
	this.vertices[3 * a] = b.x;
	this.vertices[3 * a + 1] = b.y;
	this.vertices[3 * a + 2] = b.z
};
skim.utils.ArrayBufferMesh.prototype.setNormal = function (a, b) {
	this.normals[3 * a] = b.x;
	this.normals[3 * a + 1] = b.y;
	this.normals[3 * a + 2] = b.z
};
skim.utils.ArrayBufferMesh.prototype.setVColor = function (a, b) {
	this.colors[3 * a] = b.r;
	this.colors[3 * a + 1] = b.g;
	this.colors[3 * a + 2] = b.b
};
skim.utils.ArrayBufferMesh.prototype.setVRoughness = function (a, b) {
	this.roughness[a] = b
};
skim.utils.ArrayBufferMesh.prototype.setVMetallic = function (a, b) {
	this.metallic[a] = b
};
skim.utils.ArrayBufferMesh.prototype.getVX = function (a) {
	return this.vertices[3 * a]
};
skim.utils.ArrayBufferMesh.prototype.getVY = function (a) {
	return this.vertices[3 * a + 1]
};
skim.utils.ArrayBufferMesh.prototype.getVZ = function (a) {
	return this.vertices[3 * a + 2]
};
skim.utils.ArrayBufferMesh.prototype.getNX = function (a) {
	return this.normals[3 * a]
};
skim.utils.ArrayBufferMesh.prototype.getNY = function (a) {
	return this.normals[3 * a + 1]
};
skim.utils.ArrayBufferMesh.prototype.getNZ = function (a) {
	return this.normals[3 * a + 2]
};
skim.utils.ArrayBufferMesh.prototype.getFA = function (a) {
	return this.faces[3 * a]
};
skim.utils.ArrayBufferMesh.prototype.getFB = function (a) {
	return this.faces[3 * a + 1]
};
skim.utils.ArrayBufferMesh.prototype.getFC = function (a) {
	return this.faces[3 * a + 2]
};
skim.utils.ArrayBufferMesh.prototype.getVColorR = function (a) {
	return this.colors[3 * a]
};
skim.utils.ArrayBufferMesh.prototype.getVColorG = function (a) {
	return this.colors[3 * a + 1]
};
skim.utils.ArrayBufferMesh.prototype.getVColorB = function (a) {
	return this.colors[3 * a + 2]
};
skim.utils.ArrayBufferMesh.prototype.getVRoughness = function (a) {
	return this.roughness[a]
};
skim.utils.ArrayBufferMesh.prototype.getVMetallic = function (a) {
	return this.metallic[a]
};
skim.utils.ArrayBufferMesh.prototype.getAABB = function () {
	for (var a = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE], b = 0; b < this.n_vertices; ++b) {
		for (var c = 0; 3 > c; ++c)
			this.vertices[3 * b + c] < a[c] && (a[c] = this.vertices[3 * b + c]);
		for (c = 0; 3 > c; ++c)
			this.vertices[3 * b + c] > a[3 + c] && (a[3 + c] = this.vertices[3 * b + c])
	}
	return a
};
skim.utils.ArrayBufferMesh.prototype.getFaceSurface = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3,
	c = new THREE.Vector3,
	d = new THREE.Vector3,
	e = new THREE.Vector3,
	f = new THREE.Vector3;
	return function (g, h, k) {
		a.set(this.getVX(g), this.getVY(g), this.getVZ(g));
		b.set(this.getVX(h), this.getVY(h), this.getVZ(h));
		c.set(this.getVX(k), this.getVY(k), this.getVZ(k));
		d.subVectors(b, a);
		e.subVectors(c, a);
		f.crossVectors(d, e);
		return 0.5 * f.length()
	}
}
();
skim.utils.ArrayBufferMesh.prototype.getSurface = function () {
	for (var a = 0, b = 0; b < this.n_faces; ++b)
		a += this.getFaceSurface(this.getFA(b), this.getFB(b), this.getFC(b))
};
skim.utils.ArrayBufferMesh.prototype.removeOrphanVertices = function () {
	var a = {},
	b = new Float32Array(this.vertices.length),
	c = new Float32Array(this.normals.length),
	d = null,
	e = null,
	f = null;
	this.isVertexColorEnabled() && (d = new Float32Array(this.colors.length));
	this.isVertexRoughnessEnabled() && (e = new Float32Array(this.roughness.length));
	this.isVertexMetallicEnabled() && (f = new Float32Array(this.metallic.length));
	for (var g = 0, h = 0; h < this.n_faces; ++h)
		for (var k = 0; 3 > k; ++k) {
			var l = this.faces[3 * h + k];
			void 0 === a[l] && (b[3 *
					g] = this.getVX(l), b[3 * g + 1] = this.getVY(l), b[3 * g + 2] = this.getVZ(l), c[3 * g] = this.getNX(l), c[3 * g + 1] = this.getNY(l), c[3 * g + 2] = this.getNZ(l), this.isVertexColorEnabled() && (d[3 * g] = this.colors[3 * l], d[3 * g + 1] = this.colors[3 * l + 1], d[3 * g + 2] = this.colors[3 * l + 2]), this.isVertexRoughnessEnabled() && (e[g] = this.roughness[l]), this.isVertexMetallicEnabled() && (f[g] = this.metallic[l]), a[l] = g, g++)
		}
	this.vertices = b;
	this.normals = c;
	this.n_vertices = g;
	this.isVertexColorEnabled() && (this.colors = d);
	this.isVertexRoughnessEnabled() && (this.roughness =
			e);
	this.isVertexMetallicEnabled() && (this.metallic = f);
	for (h = 0; h < 3 * this.n_faces; ++h)
		this.faces[h] = a[this.faces[h]];
	return this
};
skim.utils.ArrayBufferMesh.prototype.merge = function (a) {
	a = a.slice(0, a.length);
	var b = new skim.utils.ArrayBufferMesh(0);
	b.set(this.vertices, this.normals, this.faces, this.colors, this.roughness, this.metallic, this.n_vertices, this.n_faces);
	a.push(b);
	for (var c = 0, d = 0, e = !1, f = !1, g = !1, b = 0; b < a.length; ++b)
		c += a[b].n_vertices, d += a[b].n_faces, e = e || a[b].isVertexColorEnabled(), f = f || a[b].isVertexRoughnessEnabled(), g = g || a[b].isVertexMetallicEnabled();
	e && this.enableVertexColor();
	f && this.enableVertexRoughness();
	g && this.enableVertexMetallic();
	this.initAB(c, d);
	d = 0;
	this.n_vertices = c;
	for (b = 0; b < a.length; ++b) {
		for (c = 0; c < 3 * a[b].n_vertices; ++c)
			this.vertices[3 * d + c] = a[b].vertices[c], this.normals[3 * d + c] = a[b].normals[c];
		if (this.isVertexColorEnabled())
			if (a[b].isVertexColorEnabled())
				for (c = 0; c < 3 * a[b].n_vertices; ++c)
					this.colors[3 * d + c] = a[b].colors[c];
			else
				for (c = 0; c < 3 * a[b].n_vertices; ++c)
					this.colors[3 * d + c] = 0;
		if (this.isVertexRoughnessEnabled())
			if (a[b].isVertexRoughnessEnabled())
				for (c = 0; c < a[b].n_vertices; ++c)
					this.roughness[d + c] = a[b].roughness[c];
			else
				for (c =
						0; c < a[b].n_vertices; ++c)
					this.roughness[d + c] = 0;
		if (this.isVertexMetallicEnabled())
			if (a[b].isVertexMetallicEnabled())
				for (c = 0; c < a[b].n_vertices; ++c)
					this.metallic[d + c] = a[b].metallic[c];
			else
				for (c = 0; c < a[b].n_vertices; ++c)
					this.metallic[d + c] = 0;
		for (c = 0; c < a[b].n_faces; ++c)
			this.pushFaceAB(d + a[b].getFA(c), d + a[b].getFB(c), d + a[b].getFC(c));
		d += a[b].n_vertices
	}
	return this
};
skim.utils.ArrayBufferMesh.prototype.translate = function (a) {
	for (var b = 0; b < this.n_vertices; ++b)
		this.vertices[3 * b] += a.x, this.vertices[3 * b + 1] += a.y, this.vertices[3 * b + 2] += a.z
};
skim.utils.ArrayBufferMesh.prototype.scale = function (a) {
	for (var b = 0; b < this.n_vertices; ++b)
		this.vertices[3 * b] *= a.x, this.vertices[3 * b + 1] *= a.y, this.vertices[3 * b + 2] *= a.z
};
skim.utils.ArrayBufferMesh.prototype.toOrthonormalBasis = function (a, b, c, d) {
	var e = new THREE.Matrix4;
	e.set(b.x, c.x, d.x, a.x, b.y, c.y, d.y, a.y, b.z, c.z, d.z, a.z, 0, 0, 0, 1);
	e.getInverse(e.clone());
	this.applyMatrix4(e)
};
skim.utils.ArrayBufferMesh.prototype.applyMatrix4 = function (a) {
	var b = new THREE.Vector3,
	c = new THREE.Vector3,
	d = new THREE.Vector4,
	e = new THREE.Matrix4;
	e.getInverse(a.clone());
	e.transpose();
	for (var f = 0; f < this.n_vertices; ++f)
		b.set(this.getVX(f), this.getVY(f), this.getVZ(f)), b.applyMatrix4(a), this.setVertex(f, b), d.set(this.getNX(f), this.getNY(f), this.getNZ(f), 0), d.applyMatrix4(e), c.set(d.x, d.y, d.z), this.setNormal(f, c)
};
skim.utils.ArrayBufferMesh.prototype.convertToTHREEBufferGeometry = function () {
	for (var a = new THREE.BufferGeometry, b = new Float32Array(9 * this.n_faces), c = new Float32Array(9 * this.n_faces), d = 0; d < this.n_faces; ++d)
		for (var e = 0; 3 > e; ++e)
			for (var f = 0; 3 > f; ++f)
				b[9 * d + 3 * e + f] = this.vertices[3 * this.faces[3 * d + e] + f], c[9 * d + 3 * e + f] = this.normals[3 * this.faces[3 * d + e] + f];
	a.addAttribute("position", new THREE.BufferAttribute(b, 3));
	a.addAttribute("normal", new THREE.BufferAttribute(c, 3));
	if (this.isVertexColorEnabled()) {
		b = new Float32Array(9 *
				this.n_faces);
		for (d = 0; d < this.n_faces; ++d)
			for (e = 0; 3 > e; ++e)
				for (f = 0; 3 > f; ++f)
					b[9 * d + 3 * e + f] = this.colors[3 * this.faces[3 * d + e] + f];
		a.addAttribute("color", new THREE.BufferAttribute(b, 3))
	}
	if (this.isVertexRoughnessEnabled()) {
		f = new Float32Array(3 * this.n_faces);
		for (d = 0; d < this.n_faces; ++d)
			for (e = 0; 3 > e; ++e)
				f[3 * d + e] = this.roughness[this.faces[3 * d + e]];
		a.addAttribute("roughness", new THREE.BufferAttribute(f, 1))
	}
	if (this.isVertexMetallicEnabled()) {
		f = new Float32Array(3 * this.n_faces);
		for (d = 0; d < this.n_faces; ++d)
			for (e = 0; 3 > e; ++e)
				f[3 *
					d + e] = this.metallic[this.faces[3 * d + e]];
		a.addAttribute("metallic", new THREE.BufferAttribute(f, 1))
	}
	return a
};
skim.utils.ArrayBufferMesh.prototype.convertToTHREEGeometry = function () {
	null === this.colors && null === this.roughness && null === this.metallic || console.warn("WARNING : convertToTHREEGeometry has not implemented colors/metallic/roughness.");
	var a = this.vertices,
	b = this.normals,
	c = this.faces,
	d = this.colors,
	e = this.n_vertices,
	f = this.n_faces,
	g = new THREE.Geometry;
	g.vertices.length = 0;
	for (var h = g.faces.length = 0, k = 0; k < e; ++k)
		h = 3 * k, g.vertices.push(new THREE.Vector3(a[h], a[h + 1], a[h + 2]));
	for (k = e = 0; k < f; ++k)
		e = 3 * k, h = c[e], a =
			c[e + 1], e = c[e + 2], g.faces.push(new THREE.Face3(h, a, e)), h *= 3, a *= 3, e *= 3, g.faces[k].vertexNormals = [new THREE.Vector3(b[h], b[h + 1], b[h + 2]), new THREE.Vector3(b[a], b[a + 1], b[a + 2]), new THREE.Vector3(b[e], b[e + 1], b[e + 2])], this.isVertexColorEnabled() && (g.faces[k].vertexColors = [new THREE.Color(d[h], d[h + 1], d[h + 2]), new THREE.Color(d[a], d[a + 1], d[a + 2]), new THREE.Color(d[e], d[e + 1], d[e + 2])]);
	g.verticesNeedUpdate = !0;
	g.elementsNeedUpdate = !0;
	g.normalsNeedUpdate = !0;
	g.colorsNeedUpdate = !0;
	g.buffersNeedUpdate = !0;
	return g
};
skim.utils.ArrayBufferMesh.prototype.getJSON = function (a) {
	var b = null;
	if (void 0 !== a && null !== a && 0 < a)
		var c = Math.pow(10, a), b = function () {
			var a = 0;
			return function (b) {
				a = Math.round(b);
				return a + Math.round((b - a) * c) / c
			}
		}
	();
	else
		b = function (a) {
			return a
		};
	a = {};
	a.vertices = Array(3 * this.n_vertices);
	a.normals = Array(3 * this.n_vertices);
	for (var d = 0; d < 3 * this.n_vertices; ++d)
		a.vertices[d] = b(this.vertices[d]), a.normals[d] = this.normals[d];
	a.faces = Array(3 * this.n_faces);
	for (d = 0; d < 3 * this.n_faces; ++d)
		a.faces[d] = this.faces[d];
	skim.utils.assert(null ===
		this.colors || null === this.roughness || null === this.metallic, "Error : ArrayBufferMesh.js : JSON export of colors, roughness and metallic not implemented");
	return a
};
skim.utils.ArrayBufferMesh.buildFromJSON = function (a) {
	var b = new skim.utils.ArrayBufferMesh(10);
	b.set(new Float32Array(a.vertices), new Float32Array(a.normals), new Int32Array(a.faces), null, null, null, Math.floor(a.length / 3), Math.floor(a.length / 3));
	return b
};
skim.utils.ArrayBufferMesh.prototype.serialize = function () {
	return {
		vertices : this.vertices,
		normals : this.normals,
		faces : this.faces,
		colors : this.colors,
		roughness : this.roughness,
		metallic : this.metallic,
		n_vertices : this.n_vertices,
		n_faces : this.n_faces
	}
};
skim.utils.ArrayBufferMesh.deserialize = function (a) {
	var b = new skim.utils.ArrayBufferMesh(0);
	b.set(a.vertices, a.normals, a.faces, a.colors, a.roughness, a.metallic, a.n_vertices, a.n_faces);
	return b
};
skim.utils.MeshFileFormat = {};
skim.utils.MeshFileFormat.fromOBJToJSON = function (a) {
	var b = [],
	c = [],
	d = [],
	e = [],
	f = [],
	g = [];
	a = a.split(/[\r\n]+/g);
	for (var h = 0; h < a.length; h++) {
		var k = a[h];
		if (0 !== k.length && "#" !== k.charAt(0)) {
			var l = k.split(" ");
			switch (l[0]) {
			case "v":
				if (3 > l.length)
					throw Error("parse-obj: Invalid vertex :" + k);
				b.push(parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3]));
				break;
			case "vn":
				if (3 > l.length)
					throw Error("parse-obj: Invalid vertex normal:" + k);
				c.push(parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3]));
				break;
			case "vt":
				if (2 >
					l.length)
					throw Error("parse-obj: Invalid vertex texture coord:" + k);
				d.push(parseFloat(l[1]), parseFloat(l[2]));
				break;
			case "f":
				for (var k = Array(l.length - 1), m = Array(l.length - 1), n = Array(l.length - 1), p = 1; p < l.length; ++p) {
					var q = l[p].split("/");
					k[p - 1] = (parseInt(q[0], 10) | 0) - 1;
					n[p - 1] = q[1] ? Math.floor(parseFloat(q[1])) - 1 : -1;
					m[p - 1] = q[2] ? Math.floor(parseFloat(q[2])) - 1 : -1
				}
				3 === k.length ? (e.push(k[0], k[1], k[2]), f.push(m[0], m[1], m[2]), g.push(n[0], n[2], n[2])) : 4 === k.length ? (e.push(k[0], k[1], k[2]), e.push(k[0], k[2], k[3]),
					f.push(m[0], m[1], m[2]), f.push(m[0], m[2], m[3]), g.push(n[0], n[1], n[2]), g.push(n[0], n[2], n[3])) : console.error("Cannot handle Faces with " + k.length + "vertices");
				break;
			case "vp":
			case "s":
			case "o":
			case "g":
			case "usemtl":
			case "mtllib":
				break;
			default:
				console.warn("Warning : parse-obj: Unrecognized directive: '" + l[0] + "'")
			}
		}
	}
	return {
		vertices : b,
		normals : c,
		uvs : d,
		faces : e,
		faces_normals : f,
		face_uvs : g
	}
};
skim.utils.BinaryEncoder = {};
skim.utils.BinaryEncoder.float32ToUint8Array = function (a) {
	var b = new Uint8Array(4),
	c = 0,
	d = a;
	0 > a && (b[3] = 128, d = -a);
	for (; 1 < d && 255 >= c; )
		d /= 10, c++;
	b[0] = c;
	b[1] = Math.floor(255 * d);
	d = 255 * d - b[1];
	b[2] = Math.floor(255 * d);
	d = 255 * d - b[2];
	b[3] += Math.floor(127 * d);
	return b
};
skim.utils.BinaryEncoder.float32FromUint8Array = function (a) {
	var b = 1,
	c = a[3];
	127 < a[3] && (b = -1, c -= 128);
	c = ((c / 127 + a[2]) / 255 + a[1]) / 255;
	c *= Math.pow(10, a[0]);
	return b * c
};
skim.utils.MeshData = function (a, b, c) {
	null === a || 0 === b || 0 === c ? (this.aabb = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE], this.volume = this.surface = 0) : (this.aabb = a, this.surface = b, this.volume = c)
};
skim.utils.MeshData.prototype.merge = function (a) {
	return new skim.utils.MeshData([Math.min(this.aabb[0], a.aabb[0]), Math.min(this.aabb[1], a.aabb[1]), Math.min(this.aabb[2], a.aabb[2]), Math.max(this.aabb[3], a.aabb[3]), Math.max(this.aabb[4], a.aabb[4]), Math.max(this.aabb[5], a.aabb[5])], this.surface + a.surface, this.volume + a.volume)
};
skim.utils.MeshData.prototype.setEmpty = function () {
	this.aabb = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
	this.volume = this.surface = 0
};
skim.utils.linearRegression = function (a) {
	for (var b = [0, 0, 0, 0, 0], c = 0; c < a.length; c++)
		null != a[c][1] && (b[0] += a[c][0], b[1] += a[c][1], b[2] += a[c][0] * a[c][0], b[3] += a[c][0] * a[c][1], b[4] += a[c][1] * a[c][1]);
	a = (c * b[3] - b[0] * b[1]) / (c * b[2] - b[0] * b[0]);
	return [a, b[1] / c - a * b[0] / c]
};
skim.geometry.inter1 = 0;
skim.geometry.inter2 = 0;
skim.geometry.vectX = new THREE.Vector3(1, 0, 0);
skim.geometry.vectY = new THREE.Vector3(0, 1, 0);
skim.geometry.vectZ = new THREE.Vector3(0, 0, 1);
skim.geometry.Max = 1E17;
skim.geometry.Epsilon = 1E-7;
skim.geometry.RaySphereIntersect = function (a, b, c, d) {
	var e = d.lengthSq(),
	f,
	g;
	g = c.x - a.x;
	f = 0 + d.x * g;
	b = -b * b + g * g;
	g = c.y - a.y;
	f += d.y * g;
	b += g * g;
	g = c.z - a.z;
	f += d.z * g;
	b += g * g;
	f *= 2;
	a = f * f - 4 * e * b;
	if (0 > a)
		return 0;
	if (0 === a)
		return this.inter1 = -f / (2 * e), 1;
	a = Math.sqrt(a);
	this.inter1 = (-f - a) / (2 * e);
	this.inter2 = (-f + a) / (2 * e);
	return 2
};
skim.geometry.RayCylinderIntersect = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3,
	c = new THREE.Vector3,
	d = new THREE.Vector3;
	return function (e, f, g, h) {
		a.subVectors(f, e.v);
		var k = a.dot(e.axis),
		l = g.dot(e.axis);
		c.set(g.x - l * e.axis.x, g.y - l * e.axis.y, g.z - l * e.axis.z);
		d.set(a.x - k * e.axis.x, a.y - k * e.axis.y, a.z - k * e.axis.z);
		var k = c.lengthSq(),
		l = 2 * c.dot(d),
		m = d.lengthSq() - e.r * e.r;
		h.inter_t = {};
		h.inter_p = {};
		h.inter_dot = {};
		var n = l * l - 4 * k * m;
		if (0 > n)
			return 0;
		if (0 === n)
			return h.inter_t[0] = (-l - Math.sqrt(n)) / (2 * k), h.inter_p[0] =
				new THREE.Vector3(f.x + h.inter_t[0] * g.x, f.y + h.inter_t[0] * g.y, f.z + h.inter_t[0] * g.z), b.subVectors(h.inter_p[0], e.v), n = b.dot(e.axis), n > e.inf && n < e.sup ? (h.inter_dot[0] = n, 1) : 0;
		var m = 1,
		p = Math.sqrt(n);
		h.inter_t[0] = (-l - p) / (2 * k);
		h.inter_p[0] = new THREE.Vector3(f.x + h.inter_t[0] * g.x, f.y + h.inter_t[0] * g.y, f.z + h.inter_t[0] * g.z);
		b.subVectors(h.inter_p[0], e.v);
		n = b.dot(e.axis);
		n > e.inf && n < e.sup ? h.inter_dot[0] = n : m = 0;
		h.inter_t[m] = (-l + p) / (2 * k);
		h.inter_p[m] = new THREE.Vector3(f.x + h.inter_t[m] * g.x, f.y + h.inter_t[m] * g.y, f.z +
				h.inter_t[m] * g.z);
		b.subVectors(h.inter_p[m], e.v);
		n = b.dot(e.axis);
		n > e.inf && n < e.sup ? h.inter_dot[m] = n : m = -1;
		return m + 1
	}
}
();
skim.geometry.RayConeIntersect = function () {
	var a = new THREE.Vector3;
	return function (b, c, d, e) {
		skim.utils.assert(void 0 !== b.v && void 0 !== b.axis && (void 0 !== b.theta || void 0 !== b.cos_theta) && void 0 !== b.inf && void 0 !== b.sup && 0 <= b.inf && 0 < b.sup, "Bad truncated cone object...");
		var f = void 0 === b.cos_theta ? Math.cos(b.theta) : b.cos_theta,
		g = b.axis.dot(d),
		h = f * f;
		a.subVectors(c, b.v);
		var k = b.axis.dot(a),
		l = d.dot(a),
		m = a.dot(a),
		f = g * g - h,
		g = g * k - h * l,
		h = k * k - h * m;
		e.inter_p = {};
		e.inter_t = {};
		e.inter_dot = {};
		if (0 <= Math.abs(f)) {
			h = g * g - h *
				f;
			if (0 > h)
				return 0;
			if (0 < h)
				return h = Math.sqrt(h), f = 1 / f, k = 0, m = (-g - h) * f, e.inter_t[k] = m, e.inter_p[k] = new THREE.Vector3(c.x + m * d.x, c.y + m * d.y, c.z + m * d.z), a.subVectors(e.inter_p[k], b.v), m = a.dot(b.axis), m > b.inf && m < b.sup && (e.inter_dot[k] = m, k++), m = (-g + h) * f, e.inter_t[k] = m, e.inter_p[k] = new THREE.Vector3(c.x + m * d.x, c.y + m * d.y, c.z + m * d.z), a.subVectors(e.inter_p[k], b.v), m = a.dot(b.axis), m > b.inf && m < b.sup && (e.inter_dot[k] = m, k++), 2 == k ? 2 : 1 == k ? 1 : 0;
			e.inter_t[0] = g / f;
			e.inter_p[0] = new THREE.Vector3(c.x - e.inter_t[0] * d.x, c.y - e.inter_t[0] *
					d.y, c.z - e.inter_t[0] * d.z);
			a.subVectors(e.inter_p[0], b.v);
			m = a.dot(b.axis);
			return m > b.inf && m < b.sup ? (e.inter_dot[0] = m, 1) : 0
		}
		return 0 <= Math.abs(g) && (e.inter_t[0] = 0.5 * h / g, e.inter_p[0] = new THREE.Vector3(c.x - e.inter_t[0] * d.x, c.y - e.inter_t[0] * d.y, c.z - e.inter_t[0] * d.z), a.subVectors(e.inter_p[0], b.v), m = a.dot(b.axis), m > b.inf && m < b.sup) ? (e.inter_dot[0] = m, 1) : 0
	}
}
();
skim.geometry.RayTorusIntersect = function () {
	var a = Array(5),
	b = Array(4),
	c = Array(4);
	return function (d, e, f, g) {
		var h = e.dot(e),
		k = e.dot(f),
		l = d.R * d.R,
		m = h - d.r * d.r - l,
		h = 2 * (2 * k * k + m + 2 * l * f.z * f.z),
		n = 4 * (m * k + 2 * l * e.z * f.z);
		d = m * m + 4 * l * (e.z * e.z - d.r * d.r);
		a[0] = 1;
		a[1] = 4 * k;
		a[2] = h;
		a[3] = n;
		a[4] = d;
		skim.geometry.Quad4Solve(a, b, c);
		g.n_inter = 0;
		g.inter_t = [];
		g.inter_p = [];
		if (0 < b.length)
			for (k = 0; 4 > k; k++)
				0 === c[k] && (g.inter_t.push(b[k]), g.inter_p.push(new THREE.Vector3(e.x + b[k] * f.x, e.y + b[k] * f.y, e.z + b[k] * f.z)), g.n_inter++);
		return g.n_inter
	}
}
();
skim.geometry.GetOrthogonalRandVect = function (a, b) {
	b.crossVectors(this.vectX, a);
	0.001 > b.lengthSq() && b.crossVectors(this.vectY, a);
	return b
};
skim.geometry.RotateVectAroundN = function (a, b, c, d) {
	skim.utils.assert(1.0001 > b.lengthSq() && 0.9999 < b.lengthSq(), "Not normalized");
	var e = Math.cos(c);
	d.crossVectors(b, a);
	d.multiplyScalar(Math.sin(c));
	c = (1 - e) * a.dot(b);
	d.x = e * a.x + c * b.x + d.x;
	d.y = e * a.y + c * b.y + d.y;
	d.z = e * a.z + c * b.z + d.z;
	return d
};
skim.geometry.Quad4Solve = function (a, b, c) {
	var d = a[1],
	e = a[2],
	f = a[3];
	a = a[4];
	var g,
	h,
	k,
	l,
	m,
	n,
	p,
	q,
	r,
	t,
	s,
	u;
	g = -e;
	h = -4 * a + f * d;
	k = (3 * h - g * g) / 9;
	l =  - (27 * ( - (d * d * a + f * f) + 4 * e * a)) + g * (9 * h - 2 * g * g);
	l /= 54;
	h = k * k * k + l * l;
	g /= 3;
	0 < h ? (k = l + Math.sqrt(h), k = 0 > k ? -Math.pow(-k, 1 / 3) : Math.pow(k, 1 / 3), h = l - Math.sqrt(h), h = 0 > h ? -Math.pow(-h, 1 / 3) : Math.pow(h, 1 / 3), h = -g + k + h) : 0 === h ? (k = 0 > l ? -Math.pow(-l, 1 / 3) : Math.pow(l, 1 / 3), h = -g + 2 * k) : (k = -k, h = Math.acos(l / Math.sqrt(k * k * k)), k = 2 * Math.sqrt(k), h = -g + k * Math.cos(h / 3));
	g = d / 4;
	r = -e + g * d + h;
	k = m = n = l = p = q = t = s = u = 0;
	0 <= r ?
	0 === r ? (h =  - (4 * a) + h * h, 0 > h ? s = 2 * Math.sqrt(-h) : (t = 2 * Math.sqrt(h), u = -t)) : (k = Math.sqrt(r), t = ( - (8 * f + d * d * d) / 4 + d * e) / k, u = -t) : (m = Math.sqrt(-r), s = ( - (8 * f + d * d * d) / 4 + d * e) / m, s = -s);
	t +=  - (2 * e + r) + 3 * d * g;
	u +=  - (2 * e + r) + 3 * d * g;
	0 === s ? (0 <= t ? n = Math.sqrt(t) : l = Math.sqrt(-t), 0 <= u ? p = Math.sqrt(u) : q = Math.sqrt(-u)) : (l = Math.sqrt(t * t + s * s), l = Math.sqrt(l), h = Math.atan2(s, t), h /= 2, p = n = l * Math.cos(h), l *= Math.sin(h), q = -l);
	b[0] = -g + (k + n) / 2;
	c[0] = (m + l) / 2;
	b[1] =  - (g + n / 2) + k / 2;
	c[1] = (-l + m) / 2;
	b[2] =  - (g + k / 2) + p / 2;
	c[2] = (-m + q) / 2;
	b[3] =  - (g + (k + p) / 2);
	c[3] =  - (m + q) / 2
};
skim.geometry.ZRadial2cart = function (a) {
	return {
		x : a.r * Math.cos(a.t),
		y : a.r * Math.sin(a.t),
		z : a.z
	}
};
skim.geometry.GetIndexFromAngle = function (a, b) {
	return Math.ceil((b || 40) * a / (2 * Math.PI))
};
skim.geometry.computeRadialDist = function (a) {
	return Math.sqrt(skim.geometry.computeRadialDistSq(a))
};
skim.geometry.computeRadialDistSq = function (a) {
	return a.x * a.x + a.y * a.y
};
skim.geometry.GetXAngleFromPoint = function (a) {
	a = a.clone().setZ(0);
	var b = a.length();
	return 0 !== b ? (b = Math.acos(a.dot(skim.geometry.vectX) / b), 0 <= a.y ? b : 2 * Math.PI - b) : 0
};
skim.geometry.GetYAngleFromPointOnYZ = function (a) {
	a = a.clone().setX(0);
	var b = a.length();
	return 0 !== b ? (b = Math.acos(a.dot(skim.geometry.vectY) / b), 0 < a.z ? b : 2 * Math.PI - b) : 0
};
skim.geometry.GetZAngleFromPoint = function (a) {
	a = a.clone().setX(0);
	var b = a.length();
	return 0 !== b ? (b = Math.acos(a.dot(skim.geometry.vectZ) / b), 0 < a.y ? b : 2 * Math.PI - b) : 0
};
skim.geometry.GetYAngleFromPoint = function (a) {
	a.clone().setZ(0);
	var b = a.length();
	return 0 !== b ? (b = Math.acos(a.dot(skim.geometry.vectY) / b), 0 < a.x ? b : 2 * Math.PI - b) : 0
};
skim.geometry.GetAngleFromPointToVectOnPlane = function (a, b, c) {
	var d,
	e,
	f;
	switch (c) {
	case "XY":
		d = a.clone().setZ(0);
		switch (b) {
		case "Y":
			f = skim.geometry.vectY;
			e = d.x;
			break;
		case "X":
			f = skim.geometry.vectX;
			e = d.y;
			break;
		case "Z":
			return 0 < d.z ? Math.PI / 2 : 3 * Math.PI / 2
		}
		break;
	case "YZ":
		d = a.clone().setX(0);
		switch (b) {
		case "Y":
			f = skim.geometry.vectY;
			e = d.z;
			break;
		case "X":
			return 0 < d.x ? Math.PI / 2 : 3 * Math.PI / 2;
		case "Z":
			f = skim.geometry.vectZ,
			e = d.y
		}
		break;
	case "XZ":
		switch (d = a.clone().setY(0), b) {
		case "Y":
			return 0 < d.y ? Math.PI / 2 : 3 *
			Math.PI / 2;
		case "X":
			f = skim.geometry.vectX;
			e = d.z;
			break;
		case "Z":
			f = skim.geometry.vectZ,
			e = d.x
		}
	}
	a = d.length();
	return 0 !== a ? (d = Math.acos(d.dot(f) / a), 0 < e ? d : 2 * Math.PI - d) : 0
};
skim.geometry.LinearInterpolation1D = function (a, b, c, d, e) {
	if (b == d && c == e || a == b)
		return c;
	if (a == d)
		return e;
	a = (a - b) / (d - b);
	return c * (1 - a) + e * a
};
skim.geometry.ComputeWarpedT = function (a, b, c, d, e) {
	a = (a - b) / (d - b);
	return a = c > e ? (Math.exp( - (a - 1) * (a - 1)) - Math.exp(-1)) / (1 - Math.exp(-1)) : (Math.exp(-a * a) - 1) / (Math.exp(-1) - 1)
};
skim.geometry.ComputeT = function (a, b, c, d, e) {
	return (a - b) / (d - b)
};
skim.geometry.CubicInterpolation1D = function (a, b, c, d, e) {
	if (b == d && c == e || a == b)
		return c;
	if (a == d)
		return e;
	a = skim.geometry.ComputeWarpedT(a, b, c, d, e);
	return c * (1 + 2 * a) * (1 - a) * (1 - a) + e * a * a * (3 - 2 * a)
};
skim.geometry.CubicInterpolation1DWithTangents = function (a, b, c, d, e, f, g) {
	if (b == d && c == e || a == b)
		return c;
	if (a == d)
		return e;
	a = skim.geometry.ComputeT(a, b, c, d, e);
	return c * (1 + 2 * a) * (1 - a) * (1 - a) + e * a * a * (3 - 2 * a) + g * a * (1 - a) * (1 - a) + f * a * a * (a - 1)
};
skim.geometry.createInterpolant = function (a, b) {
	var c,
	d = a.length;
	if (d != b.length)
		throw "Need an equal count of xs and ys.";
	if (0 === d)
		return function (a) {
			return 0
		};
	if (1 === d) {
		var e = +b[0];
		return function (a) {
			return e
		}
	}
	var f = [];
	for (c = 0; c < d; c++)
		f.push(c);
	f.sort(function (b, c) {
		return a[b] < a[c] ? -1 : 1
	});
	var g = a,
	h = b;
	a = [];
	b = [];
	for (c = 0; c < d; c++)
		a.push(+g[f[c]]), b.push(+h[f[c]]);
	var k = [],
	f = [],
	g = [];
	for (c = 0; c < d - 1; c++) {
		var h = a[c + 1] - a[c],
		l = b[c + 1] - b[c];
		f.push(h);
		k.push(l);
		g.push(l / h)
	}
	var m = [g[0]];
	for (c = 0; c < f.length - 1; c++)
		if (d =
				g[c], l = g[c + 1], 0 >= d * l)
			m.push(0);
		else {
			var h = f[c],
			n = f[c + 1],
			k = h + n;
			m.push(3 * k / ((k + n) / d + (k + h) / l))
		}
	m.push(g[g.length - 1]);
	var p = [],
	q = [];
	for (c = 0; c < m.length - 1; c++)
		h = m[c], d = g[c], l = 1 / f[c], k = h + m[c + 1] - d - d, p.push((d - h - k) * l), q.push(k * l * l);
	return function (c, d) {
		if (c == a[d])
			return b[d];
		var e = c - a[d],
		f = e * e;
		return b[d] + m[d] * e + p[d] * f + q[d] * e * f
	}
};
skim.geometry.DistanceFromSegToPoint = function (a, b, c) {
	var d = a.clone().subVectors(a, b),
	e = d.lengthSq();
	if (0 === e)
		return c.distanceTo(a);
	e = a.clone().subVectors(a, c).dot(d) / e;
	if (0 > e)
		return c.distanceTo(a);
	if (1 < e)
		return b.distanceTo(c);
	a = a.clone().add(d.multiplyScalar(e));
	return c.distanceTo(a)
};
skim.geometry.AdvDistanceFromSegToPoint = function (a, b) {
	var c = {
		d : 0,
		n : -1
	},
	d = new THREE.Vector3,
	e = d.subVectors(a[1], a[0]),
	f = e.lengthSq();
	if (0 === f)
		return c.d = b.distanceTo(a[0]), c.n = 0, c;
	f = d.clone().subVectors(b, a[0]).dot(e) / f;
	if (0 > f)
		return c.d = b.distanceTo(a[0]), c.n = 0, c;
	if (1 < f)
		return c.d = b.distanceTo(a[1]), c.n = 1, c;
	d = d.addVectors(a[0], e.multiplyScalar(f));
	c.d = b.distanceTo(d);
	c.n = 0.5 >= f ? 0 : 1;
	return c
};
skim.geometry.GetIntersectionFiniteSegmentAndLine = function (a, b, c, d) {
	var e = 0,
	f = new THREE.Vector3;
	b = f.clone().subVectors(b, a);
	d = f.clone().subVectors(d, c);
	c = f.clone().subVectors(c, a);
	e = f.clone().crossVectors(b, d);
	e = f.clone().crossVectors(c, d).dot(e) / e.lengthSq();
	return 0 < e ? f.addVectors(a, b.multiplyScalar(e)) : f.addVectors(a, b.multiplyScalar(-1800 * e))
};
skim.geometry.GetIntersectionLineAndLine = function (a, b, c, d) {
	skim.utils.assert(0 === a.z && 0 === b.z && 0 === c.z && 0 === d.z, "GetIntersectionLineAndLine can only work on 2D points. If embedded in a 3D point, must be (x,y,0)");
	skim.utils.assert(!(a.x === b.x && a.y === b.y && a.z === b.z), "segment P1-P2 is defined by a singular point");
	skim.utils.assert(!(c.x === d.x && c.y === d.y && c.z === d.z), "segment P3-P4 is defined by a singular point");
	var e = (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x);
	if (0 === e)
		return null;
	var f = a.x * b.y - a.y * b.x,
	g = c.x * d.y - c.y * d.x;
	return new THREE.Vector3((f * (c.x - d.x) - (a.x - b.x) * g) / e, (f * (c.y - d.y) - (a.y - b.y) * g) / e, 0)
};
skim.geometry.isInsidePolygon = function (a, b, c, d, e) {
	var f = !1;
	b = [b, c, d, e];
	c = 0;
	for (d = 3; 4 > c; d = c++)
		b[c].y > a.y != b[d].y > a.y && a.x < (b[d].x - b[c].x) * (a.y - b[c].y) / (b[d].y - b[c].y) + b[c].x && (f = !f);
	return f
};
skim.geometry.IsCoplanar = function (a, b, c, d, e) {
	e = e || 1E-6;
	var f = new THREE.Vector3;
	b = f.clone().subVectors(b, a);
	a = f.clone().subVectors(c, a);
	c = f.clone().subVectors(d, c);
	return Math.abs(a.dot(f.crossVectors(b, c))) < e
};
skim.geometry.IsTrigoOriented = function (a, b, c, d) {
	var e = a,
	f = b,
	g = c,
	h = d;
	void 0 === a.z ? (e = new THREE.Vector3(a.x, a.y, 0), f = new THREE.Vector3(b.x, b.y, 0), g = new THREE.Vector3(c.x, c.y, 0), h = new THREE.Vector3(d.x, d.y, 0)) : skim.utils.assert(0 === a.z && 0 === b.z && 0 === c.z && 0 === d.z, "IsTrigoOriented can only work on 2D points. If embedded in a 3D point, must be (x,y,0)");
	a = new THREE.Vector3;
	f = skim.geometry.increaseVectorLength(f, e, 2);
	g = skim.geometry.increaseVectorLength(g, e, 2);
	e = skim.geometry.increaseVectorLength(h, e, 2);
	return 0 < a.crossVectors(f, g).z && 0 < a.crossVectors(f, e).z && 0 < a.crossVectors(g, e).z
};
skim.geometry.increaseVectorLength = function (a, b, c) {
	var d = new THREE.Vector3,
	d = d.subVectors(a, b);
	return d.multiplyScalar(1 + c / d.length())
};
skim.geometry.IsConvex = function (a, b, c, d) {
	if (!skim.geometry.IsTrigoOriented(a, b, c, d))
		return !1;
	var e = !0,
	f = new THREE.Vector3,
	g = new THREE.Vector3,
	h = f.clone().subVectors(b, a),
	k = f.subVectors(c, b),
	e = e && 0 < g.crossVectors(h, k).z;
	if (!e)
		return !1;
	h = f.clone().subVectors(c, b);
	k = f.subVectors(d, c);
	e = e && 0 < g.crossVectors(h, k).z;
	if (!e)
		return !1;
	h = f.clone().subVectors(d, c);
	k = f.subVectors(a, d);
	return e = e && 0 < g.crossVectors(h, k).z
};
skim.geometry.isOrthogonal = function (a) {
	for (var b = 0, c = a.length - 1; b < a.length; c = b, b++)
		if (0 !== a[c].dot(a[b]))
			return !1;
	return !0
};
skim.geometry.bilinear2DInterp = function (a, b, c, d, e, f) {
	a = 1 - (a - Math.floor(a));
	b -= Math.floor(b);
	return (e * a + c * (1 - a)) * b + (f * a + d * (1 - a)) * (1 - b)
};
skim.geometry.bicubicOptim2DInterp = function (a, b, c, d) {
	var e,
	f,
	g,
	h,
	k,
	l,
	m = a^0;
	e = b^0;
	a -= m;
	b -= e;
	var n = m - 1,
	p = m + 1,
	q = m + 2;
	k = e * d;
	h = k - d;
	l = k + d;
	var r = k + d + d;
	d = c[h + n];
	e = c[h + m];
	f = c[h + p];
	g = c[h + q];
	h = 0.5 * (f - d + (2 * d - 5 * e + 4 * f - g + (3 * (e - f) + g - d) * a) * a) * a + e;
	d = c[k + n];
	e = c[k + m];
	f = c[k + p];
	g = c[k + q];
	k = 0.5 * (f - d + (2 * d - 5 * e + 4 * f - g + (3 * (e - f) + g - d) * a) * a) * a + e;
	d = c[l + n];
	e = c[l + m];
	f = c[l + p];
	g = c[l + q];
	l = 0.5 * (f - d + (2 * d - 5 * e + 4 * f - g + (3 * (e - f) + g - d) * a) * a) * a + e;
	d = c[r + n];
	e = c[r + m];
	f = c[r + p];
	g = c[r + q];
	c = 0.5 * (f - d + (2 * d - 5 * e + 4 * f - g + (3 * (e - f) + g - d) * a) * a) * a + e;
	d = h;
	e = k;
	f = l;
	g =
		c;
	return 0.5 * (f - d + (2 * d - 5 * e + 4 * f - g + (3 * (e - f) + g - d) * b) * b) * b + e
};
skim.geometry.bicubic2DInterp = function (a, b, c) {
	var d = [0, 0, 0, 0],
	e = Math.floor(a),
	f = Math.floor(b);
	a -= e;
	b -= f;
	for (var g = -1, h; 3 > g; g++)
		h = (f + g) * c.width + e, d[g + 1] = skim.geometry.bicubic_value(a, c.data[h - 1], c.data[h], c.data[h + 1], c.data[h + 2]);
	return skim.geometry.bicubic_value(b, d[0], d[1], d[2], d[3])
};
skim.geometry.bicubic2DInterpGeneric = function (a, b, c, d) {
	var e = [0, 0, 0, 0],
	f = Math.floor(a),
	g = Math.floor(b);
	a -= f;
	b -= g;
	for (var h = -1; 3 > h; h++)
		e[h + 1] = skim.geometry.bicubic_value(a, c[(g + h) * d + (f - 1)], c[(g + h) * d + f], c[(g + h) * d + (f + 1)], c[(g + h) * d + (f + 2)]);
	return skim.geometry.bicubic_value(b, e[0], e[1], e[2], e[3])
};
skim.geometry.bicubic_value = function (a, b, c, d, e) {
	return 0.5 * (d - b + (2 * b - 5 * c + 4 * d - e + (3 * (c - d) + e - b) * a) * a) * a + c
};
skim.geometry.getBarycenter = function (a, b) {
	for (var c = 0, d = 0, e = 0, f = 0, g = 0, h = a.length; g < h; g++)
		c += a[g].x * b[g], d += a[g].y * b[g], e += a[g].z * b[g], f += b[g];
	return new THREE.Vector3(c / f, d / f, e / f)
};
skim.canvasUtils = {};
skim.canvasUtils.safeDrawImage = function (a, b, c, d) {
	if (0 > c.x || 0 > c.y || c.width > b.width || c.height > b.height)
		console.error("skim.canvasUtils.safeDrawImage - Mapping outside the source canvas");
	else if (0 > d.x || 0 > d.y || d.width + d.x > a.canvas.width || d.height + d.y > a.canvas.height)
		console.error("skim.canvasUtils.safeDrawImage - Mapping outside the source canvas");
	else {
		console.log("Writing a " + c.width + " by " + c.height + " area at coord (" + d.x + "," + d.y + ") on area of dim " + d.width + " by " + d.height);
		var e = d.width / c.width,
		f =
			d.height / c.height;
		a.scale(e, f);
		a.drawImage(b, c.x, c.y, c.width, c.height, d.x / e, d.y / f, c.width, c.height);
		a.scale(1 / e, 1 / f)
	}
};
skim.canvasUtils.appendTestCanvas = function (a, b) {
	var c = document.createElement("canvas"),
	d = c.getContext("2d"),
	e = $(a);
	c.width = b.width;
	c.height = b.height;
	d.putImageData(b, 0, 0);
	c.style.position = "absolute";
	c.style.display = "block";
	c.style.visibility = "visible";
	c.style.zIndex = "55";
	e.append(c)
};
skim.textUtils.canvasCompression = 1;
skim.textUtils.CanvasCreator = function () {
	this.sdfPrimDef = this.params = null;
	this.vertArrayDef = [];
	this.myConversionCanvas = null;
	this.conversionParams = {};
	this.height = this.width = null;
	this.fillColor = "white";
	this.maxCanvasDim = 8E3
};
skim.textUtils.CanvasCreator.prototype.create = function (a) {
	console.error("CanvasCreator - create(canvas) is virtual and should be redefined.")
};
skim.textUtils.CanvasCreator.prototype.createCanvasVertArray = function () {
	console.error("CanvasCreator - createCanvasVertArray() is virtual and should be redefined.")
};
skim.textUtils.CanvasCreator.prototype.convertToSkimImgData = function (a) {
	console.error("CanvasCreator - convertToSkimImgData() is virtual and should be redefined.");
	return {}

};
skim.textUtils.CanvasCreator.prototype.instanciateSdfPrim = function (a, b) {
	console.error("CanvasCreator - instanciateSdfPrim() is virtual and should be redefined.")
};
skim.textUtils.CanvasCreator.prototype.computeSkimDims = function () {
	console.error("CanvasCreator - computeSkimDims() is virtual and should be redefined.")
};
skim.textUtils.CanvasCreator.prototype.getDimensions = function () {
	if (null !== this.params)
		return this.conversionParams;
	console.error("CanvasCreator - can't recommand dimensions without params");
	return {}

};
skim.textUtils.CanvasCreator.prototype.checkDimensions = function (a) {
	null !== this.params ? (skim.utils.isApproxEqual(this.conversionParams.width / this.conversionParams.height, a.width / a.height, skim.engine.functorPrecision) ? console.log("CanvasCreator - No deformation of the canvas ring expected") : (console.warn("CanvasCreator - canvas will be deformed!"), console.warn("CanvasCreator - Use getDimensions() to obtain canvas or image dimensions that won't produce deformations")), 3 > this.params.thickness && console.warn("CanvasCreator - thickness given might not guarantee printability"),
		2 >= this.params.canvasResolution / skim.textUtils.canvasCompression && console.warn("CanvasCreator - resolution/canvasCompression ratio will give a poor quality for the surface\nTry increasing params.canvasResolution or reducing skim.textUtils.canvasCompression"), this.width * this.params.canvasResolution / skim.textUtils.canvasCompression > this.maxCanvasDim && console.warn("CanvasCreator - Optimal conversion canvas is too big:\n- Reduce skim.textUtils.canvasCompression to have faster computation\u00a0\n- or reduce the params.canvasResolution (quality decrease will result)"),
		500 < this.width && 4 >= this.params.thickness && console.warn("CanvasCreator - skimlab width appear to be huge.\nDo not forget to increase params.thickness to avoid long octree computation times")) : console.warn("CanvasCreator - Need some params for checkDimensions to work")
};
skim.textUtils.CanvasCreator.prototype.setParams = function (a) {
	this.params = a;
	this.computeCanvasSize()
};
skim.textUtils.CanvasCreator.prototype.clean = function () {
	null !== this.sdfPrimDef && (this.cleanVertArray(), this.sdfPrimDef.destroy())
};
skim.textUtils.CanvasCreator.prototype.cleanVertArray = function () {
	if (this.vertArrayDef) {
		for (var a = 0; a < this.vertArrayDef.length; a++)
			this.vertArrayDef[a].destroy();
		this.vertArrayDef = []
	}
};
skim.textUtils.CanvasCreator.prototype.create = function (a) {
	if (null !== this.params) {
		this.clean();
		this.createCanvasVertArray();
		this.checkDimensions(a);
		a = this.convertToSkimImgData(a);
		this.instanciateSdfPrim(this.vertArrayDef, a);
		for (a = 0; a < this.vertArrayDef.length; a++)
			this.vertArrayDef[a].commit();
		this.sdfPrimDef.commit();
		skim.engine.update_skeleton();
		skim.engine.update_parametrics();
		skim.engine.update_blobtree()
	} else
		console.error("CanvasRingCreator - can't create a canvas ring without ring parameters. Use setParams(params)!")
};
skim.textUtils.CanvasCreator.prototype.computeCanvasSize = function () {
	this.computeSkimDims();
	this.conversionParams.width = Math.min(Math.ceil(this.width * (this.params.canvasResolution || 8) / skim.textUtils.canvasCompression), this.maxCanvasDim);
	this.conversionParams.height = Math.ceil(this.conversionParams.width * this.height / this.width);
	this.conversionParams.BBPixelSizeY = Math.ceil(this.params.thickness * skim.blobtree.KS * this.conversionParams.height / this.height);
	this.conversionParams.BBPixelSizeX = Math.ceil(this.conversionParams.BBPixelSizeY *
			this.conversionParams.width / this.conversionParams.height);
	console.log("Attempting to add on X: 2*" + this.conversionParams.BBPixelSizeX + " and on Y: 2*" + this.conversionParams.BBPixelSizeY)
};
skim.textUtils.CanvasRingCreator = function () {
	skim.textUtils.CanvasCreator.call(this)
};
skim.textUtils.CanvasRingCreator.prototype = Object.create(skim.textUtils.CanvasCreator.prototype);
skim.textUtils.CanvasRingCreator.prototype.constructor = skim.textUtils.CanvasRingCreator;
skim.textUtils.CanvasRingCreator.prototype.instanciateSdfPrim = function (a, b) {
	this.sdfPrimDef = new skim.engine.TextRingDef(a, b)
};
skim.textUtils.CanvasRingCreator.prototype.computeSkimDims = function () {
	this.width = 2 * Math.PI * (this.params.radius + this.params.rLength / 2);
	this.height = this.params.zLength - 2 * this.params.thickness
};
skim.textUtils.CanvasRingCreator.prototype.convertToSkimImgData = function (a) {
	var b = {
		x : 0,
		y : 0,
		width : 0,
		height : 0
	},
	c = {
		x : 0,
		y : 0,
		width : 0,
		height : 0
	};
	this.myConversionCanvas = document.createElement("canvas");
	var d = this.myConversionCanvas.getContext("2d");
	this.myConversionCanvas.width = this.conversionParams.width + 2 * this.conversionParams.BBPixelSizeX;
	this.myConversionCanvas.height = this.conversionParams.height + 2 * this.conversionParams.BBPixelSizeY;
	console.log("Creating Conversion canvas width: " + this.myConversionCanvas.width +
		" and height: " + this.myConversionCanvas.height);
	d.fillStyle = this.fillColor;
	d.fillRect(0, 0, this.myConversionCanvas.width, this.myConversionCanvas.height);
	console.log("Draw internalCanvas at X: " + this.conversionParams.BBPixelSizeX + " and Y: " + this.conversionParams.BBPixelSizeY);
	var e = Math.floor(this.conversionParams.BBPixelSizeX * a.width / this.conversionParams.width);
	b.x = a.width - e;
	b.y = 0;
	b.width = e;
	b.height = a.height;
	c.x = 0;
	c.y = this.conversionParams.BBPixelSizeY;
	c.width = this.conversionParams.BBPixelSizeX;
	c.height =
		this.conversionParams.height;
	skim.canvasUtils.safeDrawImage(d, a, b, c);
	b.x = 0;
	b.y = 0;
	b.width = a.width;
	b.height = a.height;
	c.x = this.conversionParams.BBPixelSizeX;
	c.y = this.conversionParams.BBPixelSizeY;
	c.width = this.conversionParams.width;
	c.height = this.conversionParams.height;
	skim.canvasUtils.safeDrawImage(d, a, b, c);
	console.log("BBoxX in conversion land: " + this.conversionParams.BBPixelSizeX + " and BBox in internalCanvas: " + e);
	b.x = 0;
	b.y = 0;
	b.width = e;
	b.height = a.height;
	c.x = this.conversionParams.width + this.conversionParams.BBPixelSizeX;
	c.y = this.conversionParams.BBPixelSizeY;
	c.width = this.conversionParams.BBPixelSizeX;
	c.height = this.conversionParams.height;
	skim.canvasUtils.safeDrawImage(d, a, b, c);
	console.log("Size of smallDatas: X" + e + " and Y: " + a.height);
	console.log("Converted size: width: " + this.myConversionCanvas.width + " and height: " + this.myConversionCanvas.height);
	return d.getImageData(0, 0, this.myConversionCanvas.width, this.myConversionCanvas.height)
};
skim.textUtils.CanvasRingCreator.prototype.createCanvasVertArray = function () {
	this.vertArrayDef = skim.ringUtils.createVertControlSet(0, this.params.radius + this.params.rLength / 2, this.params.rLength - 2 * this.params.thickness, this.params.zLength - 2 * this.params.thickness, 0, this.params.thickness).vert
};
skim.textUtils.CanvasTextCreator = function () {
	skim.textUtils.CanvasCreator.call(this)
};
skim.textUtils.CanvasTextCreator.prototype = Object.create(skim.textUtils.CanvasCreator.prototype);
skim.textUtils.CanvasTextCreator.prototype.constructor = skim.textUtils.CanvasTextCreator;
skim.textUtils.CanvasTextCreator.prototype.instanciateSdfPrim = function (a, b) {
	this.sdfPrimDef = new skim.engine.TextDef(a, b)
};
skim.textUtils.CanvasTextCreator.prototype.computeSkimDims = function () {
	this.width = this.params.width - 2 * this.params.thickness;
	this.height = this.params.height - 2 * this.params.thickness
};
skim.textUtils.CanvasTextCreator.prototype.convertToSkimImgData = function (a) {
	var b = {
		x : 0,
		y : 0,
		width : 0,
		height : 0
	},
	c = {
		x : 0,
		y : 0,
		width : 0,
		height : 0
	};
	this.myConversionCanvas = document.createElement("canvas");
	var d = this.myConversionCanvas.getContext("2d");
	this.myConversionCanvas.width = this.conversionParams.width + 2 * this.conversionParams.BBPixelSizeX;
	this.myConversionCanvas.height = this.conversionParams.height + 2 * this.conversionParams.BBPixelSizeY;
	console.log("Creating Conversion canvas width: " + this.myConversionCanvas.width +
		" and height: " + this.myConversionCanvas.height);
	d.fillStyle = this.fillColor;
	d.fillRect(0, 0, this.myConversionCanvas.width, this.myConversionCanvas.height);
	console.log("Draw internalCanvas at X: " + this.conversionParams.BBPixelSizeX + " and Y: " + this.conversionParams.BBPixelSizeY);
	b.x = 0;
	b.y = 0;
	b.width = a.width;
	b.height = a.height;
	c.x = this.conversionParams.BBPixelSizeX;
	c.y = this.conversionParams.BBPixelSizeY;
	c.width = this.conversionParams.width;
	c.height = this.conversionParams.height;
	skim.canvasUtils.safeDrawImage(d,
		a, b, c);
	console.log("Converted size: width: " + this.myConversionCanvas.width + " and height: " + this.myConversionCanvas.height);
	return d.getImageData(0, 0, this.myConversionCanvas.width, this.myConversionCanvas.height)
};
skim.textUtils.CanvasTextCreator.prototype.createCanvasVertArray = function () {
	var a = this.params.thickness,
	b = this.params.width - 2 * a,
	c = this.params.height - 2 * a,
	d = this.params.depth - 2 * a,
	e = null,
	e = this.params.orig ? this.createFrame(this.params.orig, b, c, d) : this.createFrame(new THREE.Vector3(-b / 2, -c / 2, -d / 2), b, c, d);
	this.vertArrayDef.push(new skim.engine.VertexDef(e.orig, a, skim.instances.defaultMaterial, skim.VolType.Mech));
	this.vertArrayDef.push(new skim.engine.VertexDef(e.axisX, a, skim.instances.defaultMaterial,
			skim.VolType.Mech));
	this.vertArrayDef.push(new skim.engine.VertexDef(e.axisY, a, skim.instances.defaultMaterial, skim.VolType.Mech));
	this.vertArrayDef.push(new skim.engine.VertexDef(e.axisZ, a, skim.instances.defaultMaterial, skim.VolType.Mech))
};
skim.textUtils.CanvasTextCreator.prototype.createFrame = function (a, b, c, d) {
	var e = a.clone();
	e.setX(e.x + b);
	b = a.clone();
	b.setY(b.y + c);
	c = a.clone();
	c.setZ(c.z + d);
	return {
		orig : a,
		axisX : e,
		axisY : b,
		axisZ : c
	}
};
skim.utils.DynamicMesh = function (a, b) {
	THREE.Mesh.call(this, a, b)
};
skim.utils.DynamicMesh.prototype = Object.create(THREE.Mesh.prototype);
skim.utils.DynamicMesh.prototype.constructor = skim.utils.DynamicMesh;
skim.utils.DynamicMesh.prototype.update = function (a) {
	console.error("Error : skim.utils.DynamicMesh.prototype.update must be reimplemented in subclasses")
};
skim.utils.DynamicPedestal = function (a) {
	a = null === a || void 0 === a ? new THREE.MeshPhongMaterial({
			color : 1118481,
			specular : 3355443,
			shininess : 30,
			transparent : !0,
			opacity : 0.5
		}) : a;
	var b = new THREE.CylinderGeometry(0.92, 1, 1, 50, 50);
	skim.utils.DynamicMesh.call(this, b, a);
	this.axis = "z";
	this.rotation.x = Math.PI / 2;
	this.centerMode = skim.utils.DynamicPedestal.centerMode.ORIGIN
};
skim.utils.DynamicPedestal.prototype = Object.create(skim.utils.DynamicMesh.prototype);
skim.utils.DynamicPedestal.prototype.constructor = skim.utils.DynamicPedestal;
skim.utils.DynamicPedestal.centerMode = {
	ORIGIN : 0,
	OBJECT : 1
};
skim.utils.DynamicPedestal.prototype.setCenterMode = function (a) {
	this.centerMode = a
};
skim.utils.DynamicPedestal.prototype.setAxis = function (a) {
	this.axis = a;
	a = {
		x : {
			axis : "z",
			angle : -Math.PI / 2
		},
		y : {
			axis : "y",
			angle : 0
		},
		z : {
			axis : "x",
			angle : Math.PI / 2
		}
	};
	this.rotation.set(0, 0, 0);
	this.rotation[a[this.axis].axis] = a[this.axis].angle
};
skim.utils.DynamicPedestal.prototype.update = function (a) {
	var b = a.getCenter(),
	c = a.getDimensions(),
	d = null,
	d = "x" === this.axis ? ["y", "z"] : "y" === this.axis ? ["x", "z"] : ["x", "y"],
	e = Math.max(c[d[0]], c[d[1]]);
	this.scale.y = 0.14 * c[this.axis];
	this.scale.x = 1.05 * e;
	this.scale.z = 1.05 * e;
	switch (this.centerMode) {
	case 0:
		this.position[d[0]] = 0;
		this.position[d[1]] = 0;
		break;
	case 1:
		this.position[d[0]] = b[d[0]];
		this.position[d[1]] = b[d[1]];
		break;
	default:
		console.error("Error : unknown center mode fore Dynamic Pedestal")
	}
	this.position[this.axis] =
		a.min[this.axis] - this.scale.y
};
skim.utils.Pedestal = function (a) {
	a = new THREE.MeshPhongMaterial({
			color : 1118481,
			specular : 3355443,
			shininess : 30,
			transparent : !0,
			opacity : 0.5
		});
	var b = new THREE.CylinderGeometry(0.92, 1, 1, 50, 50);
	THREE.Mesh.call(this, b, a);
	this.rotation.y = Math.PI / 2;
	this.visible = !0
};
skim.utils.Pedestal.prototype = Object.create(THREE.Mesh.prototype);
skim.utils.Pedestal.prototype.constructor = skim.utils.Pedestal;
skim.utils.Pedestal.prototype.update = function (a) {
	a.getCenter();
	var b = a.getDimensions(),
	c = Math.max(b.x, b.z);
	this.scale.x = 1.05 * c;
	this.scale.y = 0.14 * b.y;
	this.scale.z = 1.05 * c;
	this.position.x = 0;
	this.position.z = 0;
	this.position.y = a.min.y - this.scale.y
};
skim.utils.HelperBoundingBox = function () {
	THREE.BoxHelper.call(this);
	this.material.color.setHex(4892728);
	this.material.transparent = !0;
	this.material.opacity = 0.7;
	this.visible = !0
};
skim.utils.HelperBoundingBox.prototype = Object.create(THREE.BoxHelper.prototype);
skim.utils.HelperBoundingBox.prototype.constructor = skim.utils.HelperBoundingBox;
skim.utils.HelperBoundingBox.prototype.update = function (a) {
	var b = this.geometry.attributes.position.array;
	b[0] = a.max.x;
	b[1] = a.max.y;
	b[2] = a.max.z;
	b[3] = a.min.x;
	b[4] = a.max.y;
	b[5] = a.max.z;
	b[6] = a.min.x;
	b[7] = a.max.y;
	b[8] = a.max.z;
	b[9] = a.min.x;
	b[10] = a.min.y;
	b[11] = a.max.z;
	b[12] = a.min.x;
	b[13] = a.min.y;
	b[14] = a.max.z;
	b[15] = a.max.x;
	b[16] = a.min.y;
	b[17] = a.max.z;
	b[18] = a.max.x;
	b[19] = a.min.y;
	b[20] = a.max.z;
	b[21] = a.max.x;
	b[22] = a.max.y;
	b[23] = a.max.z;
	b[24] = a.max.x;
	b[25] = a.max.y;
	b[26] = a.min.z;
	b[27] = a.min.x;
	b[28] = a.max.y;
	b[29] =
		a.min.z;
	b[30] = a.min.x;
	b[31] = a.max.y;
	b[32] = a.min.z;
	b[33] = a.min.x;
	b[34] = a.min.y;
	b[35] = a.min.z;
	b[36] = a.min.x;
	b[37] = a.min.y;
	b[38] = a.min.z;
	b[39] = a.max.x;
	b[40] = a.min.y;
	b[41] = a.min.z;
	b[42] = a.max.x;
	b[43] = a.min.y;
	b[44] = a.min.z;
	b[45] = a.max.x;
	b[46] = a.max.y;
	b[47] = a.min.z;
	b[48] = a.max.x;
	b[49] = a.max.y;
	b[50] = a.max.z;
	b[51] = a.max.x;
	b[52] = a.max.y;
	b[53] = a.min.z;
	b[54] = a.min.x;
	b[55] = a.max.y;
	b[56] = a.max.z;
	b[57] = a.min.x;
	b[58] = a.max.y;
	b[59] = a.min.z;
	b[60] = a.min.x;
	b[61] = a.min.y;
	b[62] = a.max.z;
	b[63] = a.min.x;
	b[64] = a.min.y;
	b[65] =
		a.min.z;
	b[66] = a.max.x;
	b[67] = a.min.y;
	b[68] = a.max.z;
	b[69] = a.max.x;
	b[70] = a.min.y;
	b[71] = a.min.z;
	this.geometry.computeBoundingSphere()
};
skim.utils.Symplane = function (a) {
	this.ortho_axis = void 0 === a.ortho_axis ? "x" : a.ortho_axis;
	var b = new THREE.MeshBasicMaterial({
			color : void 0 === a.color ? 10066329 : a.color,
			opacity : 0.2,
			transparent : !0,
			side : THREE.DoubleSide
		});
	a = new THREE.Geometry;
	THREE.Mesh.call(this, a, b);
	b = new THREE.Vector3(0, 0, 0);
	switch (this.ortho_axis) {
	case "x":
		a.vertices = [new THREE.Vector3(0, 1, -1), new THREE.Vector3(0, 1, 1), new THREE.Vector3(0, -1, 1), new THREE.Vector3(0, -1, -1)];
		b.x = 1;
		break;
	case "y":
		a.vertices = [new THREE.Vector3(1, 0, -1), new THREE.Vector3(1,
				0, 1), new THREE.Vector3(-1, 0, 1), new THREE.Vector3(-1, 0, -1)];
		b.y = 1;
		break;
	case "z":
		a.vertices = [new THREE.Vector3(1, -1, 0), new THREE.Vector3(1, 1, 0), new THREE.Vector3(-1, 1, 0), new THREE.Vector3(-1, -1, 0)];
		b.z = 1;
		break;
	default:
		skim.utils.assert(!1, "unknown othogonal axis for symplane")
	}
	a.faces = [new THREE.Face3(0, 1, 2), new THREE.Face3(0, 2, 3)];
	for (var c = 0; 2 > c; ++c)
		a.faces[c].normal.copy(b), a.faces[c].vertexNormals.push(b.clone(), b.clone(), b.clone());
	a.verticesNeedUpdate = !0;
	this.visible = a.facesNeedUpdate = !0
};
skim.utils.Symplane.prototype = Object.create(THREE.Mesh.prototype);
skim.utils.Symplane.prototype.constructor = skim.utils.Symplane;
skim.utils.Symplane.prototype.update = function (a) {
	a.getCenter();
	var b = a.getDimensions(),
	b = Math.max(b.x, b.y, b.z),
	c = {
		x : Math.max(Math.abs(a.min.x), Math.abs(a.max.x)),
		y : Math.max(Math.abs(a.min.y), Math.abs(a.max.y)),
		z : Math.max(Math.abs(a.min.z), Math.abs(a.max.z))
	};
	Math.max(Math.max(Math.abs(a.min.x), Math.abs(a.max.x)), Math.max(Math.abs(a.min.z), Math.abs(a.max.z)));
	a = ["x", "y", "z"];
	for (var d = 0; 3 > d; ++d)
		a[d] != this.ortho_axis && (this.scale[a[d]] = c[a[d]] + 0.2 * b)
};
skim.utils.Symplane.prototype.setColor = function (a) {
	this.material.color.set(a)
};
skim.utils.OBJToTHREELoader = function (a, b) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this.ratio = b || 1
};
skim.utils.OBJToTHREELoader.prototype = {
	constructor : skim.utils.OBJToTHREELoader,
	load : function (a, b, c) {
		var d = this,
		e = new THREE.XHRLoader(d.manager);
		e.setCrossOrigin(this.crossOrigin);
		e.load(a, function (a) {
			b(d.parse(a))
		}, function (a) {
			c(a)
		})
	},
	parse : function (a) {
		function b(a, b, c) {
			return new THREE.Vector3(a, b, c)
		}
		function c(a, b) {
			return new THREE.Vector2(a, b)
		}
		function d(a, b, c, d) {
			return null !== d ? new THREE.Face3(a, b, c, d) : new THREE.Face3(a, b, c)
		}
		function e(a, b, c, e) {
			void 0 === e || null === e ? h.faces.push(d(parseInt(a, 10) -
					(m + 1), parseInt(b, 10) - (m + 1), parseInt(c, 10) - (m + 1), null)) : h.faces.push(d(parseInt(a, 10) - (m + 1), parseInt(b, 10) - (m + 1), parseInt(c, 10) - (m + 1), [n[parseInt(e[0], 10) - 1].clone(), n[parseInt(e[1], 10) - 1].clone(), n[parseInt(e[2], 10) - 1].clone()]))
		}
		function f(a, b, c) {
			h.faceVertexUvs[0].push([p[parseInt(a, 10) - 1].clone(), p[parseInt(b, 10) - 1].clone(), p[parseInt(c, 10) - 1].clone()])
		}
		function g(a, b, c) {
			void 0 !== a && void 0 !== b && void 0 !== c || console.error("handle_face_line must be called with at least 1 valid argument and 2 null pointers, undefined not allowed");
			void 0 === a[3] ? (e(a[0], a[1], a[2], c), null !== b && 0 < b.length && f(b[0], b[1], b[2])) : (null !== c && 0 < c.length ? (e(a[0], a[1], a[3], [c[0], c[1], c[3]]), e(a[1], a[2], a[3], [c[1], c[2], c[3]])) : (e(a[0], a[1], a[3], null), e(a[1], a[2], a[3], null)), null !== b && 0 < b.length && (f(b[0], b[1], b[3]), f(b[1], b[2], b[3])))
		}
		var h,
		k,
		l,
		m = 0;
		!1 === /^o /gm.test(a) && (h = new THREE.Geometry, k = new THREE.MeshLambertMaterial, l = new THREE.Mesh(h, k));
		var n = [],
		p = [],
		q = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
		r = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
		t = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
		s = /f( +\d+)( +\d+)( +\d+)( +\d+)?/,
		u = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/,
		w = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/,
		y = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/;
		a = a.split("\n");
		for (var B = 0; B < a.length; B++) {
			var A = a[B],
			A = A.trim(),
			v;
			0 !== A.length && "#" !== A.charAt(0) && (null !== (v = q.exec(A)) ? h.vertices.push(b(parseFloat(v[1]) * this.ratio, parseFloat(v[2]) *
						this.ratio, parseFloat(v[3]) * this.ratio)) : null !== (v = r.exec(A)) ? n.push(b(parseFloat(v[1]), parseFloat(v[2]), parseFloat(v[3]))) : null !== (v = t.exec(A)) ? p.push(c(parseFloat(v[1]), parseFloat(v[2]))) : null !== (v = s.exec(A)) ? g([v[1], v[2], v[3], v[4]], null, [v[1], v[2], v[3]]) : null !== (v = u.exec(A)) ? g([v[2], v[5], v[8], v[11]], [v[3], v[6], v[9], v[12]], null) : null !== (v = w.exec(A)) ? g([v[2], v[6], v[10], v[14]], [v[3], v[7], v[11], v[15]], [v[4], v[8], v[12], v[16]]) : null !== (v = y.exec(A)) ? g([v[2], v[5], v[8], v[11]], [], [v[3], v[6], v[9], v[12]]) :
				/^o /.test(A) ? (void 0 !== h && (m += h.vertices.length), h = new THREE.Geometry, k = new THREE.MeshLambertMaterial, l = new THREE.Mesh(h, k), l.name = A.substring(2).trim()) : /^g /.test(A) || (/^usemtl /.test(A) ? k.name = A.substring(7).trim() : /^mtllib /.test(A) || /^s /.test(A)))
		}
		h.computeFaceNormals();
		h.computeBoundingSphere();
		return l
	}
};
skim.utils.OBJMTLLoader = function () {};
skim.utils.OBJMTLLoader.prototype = {
	constructor : skim.utils.OBJMTLLoader,
	load : function (a, b, c, d, e) {
		var f = this,
		g = new skim.utils.MTLLoader(a.substr(0, a.lastIndexOf("/") + 1), void 0, void 0);
		g.load(b, function (b) {
			b.preload();
			var d = new THREE.XHRLoader(f.manager);
			d.setCrossOrigin(g.crossOrigin);
			d.load(a, function (a) {
				a = f.parse(a, null);
				a.traverse(function (a) {
					if (a instanceof THREE.Mesh && a.material.name) {
						var c = b.create(a.material.name);
						c && (a.material = c)
					}
				});
				c(a)
			})
		}, void 0, void 0)
	},
	parse : function (a, b) {
		function c(a,
			b, c) {
			return new THREE.Vector3(a, b, c)
		}
		function d(a, b) {
			return new THREE.Vector2(a, b)
		}
		function e(a, b, c, d) {
			return null !== d ? new THREE.Face3(a, b, c, d) : new THREE.Face3(a, b, c)
		}
		function f(a, b) {
			0 < t.length && (p.vertices = t, p.mergeVertices(), p.computeFaceNormals(), p.computeBoundingSphere(), n.add(r), p = new THREE.Geometry, r = new THREE.Mesh(p, q));
			void 0 !== a && null !== a && (r.name = a);
			void 0 !== b && null !== b && (q = new THREE.MeshLambertMaterial, q.name = b, r.material = q)
		}
		function g(a, b, c, d) {
			void 0 === d || null === d ? p.faces.push(e(parseInt(a,
						10) - (l + 1), parseInt(b, 10) - (l + 1), parseInt(c, 10) - (l + 1), null)) : p.faces.push(e(parseInt(a, 10) - (l + 1), parseInt(b, 10) - (l + 1), parseInt(c, 10) - (l + 1), [s[parseInt(d[0], 10) - 1].clone(), s[parseInt(d[1], 10) - 1].clone(), s[parseInt(d[2], 10) - 1].clone()]))
		}
		function h(a, b, c) {
			p.faceVertexUvs[0].push([u[parseInt(a, 10) - 1].clone(), u[parseInt(b, 10) - 1].clone(), u[parseInt(c, 10) - 1].clone()])
		}
		function k(a, b, c) {
			void 0 === a[3] ? (g(a[0], a[1], a[2], c), void 0 !== b && 0 < b.length && h(b[0], b[1], b[2])) : (void 0 !== c && null !== c && 0 < c.length ? (g(a[0],
						a[1], a[3], [c[0], c[1], c[3]]), g(a[1], a[2], a[3], [c[1], c[2], c[3]])) : (g(a[0], a[1], a[3], null), g(a[1], a[2], a[3], null)), void 0 !== b && 0 < b.length && (h(b[0], b[1], b[3]), h(b[1], b[2], b[3])))
		}
		for (var l = 0, m = new THREE.Object3D, n = m, p = new THREE.Geometry, q = new THREE.MeshLambertMaterial, r = new THREE.Mesh(p, q), t = [], s = [], u = [], w = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, y = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, B = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, A = /f( +\d+)( +\d+)( +\d+)( +\d+)?/,
			v = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/, D = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/, E = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/, C = a.split("\n"), F = 0; F < C.length; F++) {
			var z = C[F],
			z = z.trim(),
			x;
			0 !== z.length && "#" !== z.charAt(0) && (null !== (x = w.exec(z)) ? t.push(c(parseFloat(x[1]), parseFloat(x[2]), parseFloat(x[3]))) : null !== (x = y.exec(z)) ? s.push(c(parseFloat(x[1]), parseFloat(x[2]), parseFloat(x[3]))) :
				null !== (x = B.exec(z)) ? u.push(d(parseFloat(x[1]), parseFloat(x[2]))) : null !== (x = A.exec(z)) ? k([x[1], x[2], x[3], x[4]], null, null) : null !== (x = v.exec(z)) ? k([x[2], x[5], x[8], x[11]], [x[3], x[6], x[9], x[12]], null) : null !== (x = D.exec(z)) ? k([x[2], x[6], x[10], x[14]], [x[3], x[7], x[11], x[15]], [x[4], x[8], x[12], x[16]]) : null !== (x = E.exec(z)) ? k([x[2], x[5], x[8], x[11]], [], [x[3], x[6], x[9], x[12]]) : /^o /.test(z) ? (f(null, null), l += t.length, t = [], n = new THREE.Object3D, n.name = z.substring(2).trim(), m.add(n)) : /^g /.test(z) ? f(z.substring(2).trim(),
					null) : /^usemtl /.test(z) ? f(null, z.substring(7).trim()) : /^mtllib /.test(z) ? null !== b && void 0 !== b && (z = z.substring(7), z = z.trim(), b(z)) : /^s /.test(z) || console.log("THREE.OBJMTLLoader: Unhandled line " + z))
		}
		f(null, null);
		return m
	}
};
THREE.EventDispatcher.prototype.apply(skim.utils.OBJMTLLoader.prototype);
skim.utils.MTLLoader = function (a, b, c) {
	this.baseUrl = a;
	this.options = b;
	this.crossOrigin = c
};
skim.utils.MTLLoader.prototype = {
	constructor : skim.utils.MTLLoader,
	load : function (a, b, c, d) {
		var e = this;
		c = new THREE.XHRLoader;
		c.setCrossOrigin(this.crossOrigin);
		c.load(a, function (a) {
			b(e.parse(a))
		})
	},
	parse : function (a) {
		var b = a.split("\n"),
		c = {},
		d = /\s+/;
		a = {};
		for (var e = 0; e < b.length; e++) {
			var f = b[e],
			f = f.trim();
			if (0 !== f.length && "#" !== f.charAt(0)) {
				var g = f.indexOf(" "),
				h = 0 <= g ? f.substring(0, g) : f,
				h = h.toLowerCase(),
				f = 0 <= g ? f.substring(g + 1) : "",
				f = f.trim();
				"newmtl" === h ? (c = {
						name : f
					}, a[f] = c) : c && ("ka" === h || "kd" === h || "ks" ===
					h ? (f = f.split(d, 3), c[h] = [parseFloat(f[0]), parseFloat(f[1]), parseFloat(f[2])]) : c[h] = f)
			}
		}
		b = new skim.utils.MTLLoader.MaterialCreator(this.baseUrl, this.options);
		b.setMaterials(a);
		return b
	}
};
skim.utils.MTLLoader.MaterialCreator = function (a, b) {
	this.baseUrl = a;
	this.options = b;
	this.materialsInfo = {};
	this.materials = {};
	this.materialsArray = [];
	this.nameLookup = {};
	this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;
	this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping
};
skim.utils.MTLLoader.MaterialCreator.prototype = {
	constructor : skim.utils.MTLLoader.MaterialCreator,
	setMaterials : function (a) {
		this.materialsInfo = this.convert(a);
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {}

	},
	convert : function (a) {
		if (!this.options)
			return a;
		var b = {},
		c;
		for (c in a) {
			var d = a[c],
			e = {};
			b[c] = e;
			for (var f in d) {
				var g = !0,
				h = d[f],
				k = f.toLowerCase();
				switch (k) {
				case "kd":
				case "ka":
				case "ks":
					this.options && this.options.normalizeRGB && (h = [h[0] / 255, h[1] / 255, h[2] / 255]);
					this.options && this.options.ignoreZeroRGBs &&
					0 === h[0] && (0 === h[1] && 0 === h[1]) && (g = !1);
					break;
				case "d":
					this.options && this.options.invertTransparency && (h = 1 - h)
				}
				g && (e[k] = h)
			}
		}
		return b
	},
	preload : function () {
		for (var a in this.materialsInfo)
			this.create(a)
	},
	getIndex : function (a) {
		return this.nameLookup[a]
	},
	getAsArray : function () {
		var a = 0,
		b;
		for (b in this.materialsInfo)
			this.materialsArray[a] = this.create(b), this.nameLookup[b] = a, a++;
		return this.materialsArray
	},
	create : function (a) {
		void 0 === this.materials[a] && this.createMaterial_(a);
		return this.materials[a]
	},
	createMaterial_ : function (a) {
		var b =
			this.materialsInfo[a],
		c = {
			name : a,
			side : this.side
		},
		d;
		for (d in b) {
			var e = b[d];
			switch (d.toLowerCase()) {
			case "kd":
				c.diffuse = (new THREE.Color).fromArray(e);
				break;
			case "ka":
				c.ambient = (new THREE.Color).fromArray(e);
				break;
			case "ks":
				c.specular = (new THREE.Color).fromArray(e);
				break;
			case "map_kd":
				c.map = this.loadTexture(this.baseUrl + e, void 0, void 0, void 0);
				c.map.wrapS = this.wrap;
				c.map.wrapT = this.wrap;
				break;
			case "ns":
				c.shininess = e;
				break;
			case "d":
				1 > e && (c.transparent = !0, c.opacity = e)
			}
		}
		c.diffuse && (c.ambient || (c.ambient =
					c.diffuse), c.color = c.diffuse);
		this.materials[a] = new THREE.MeshPhongMaterial(c);
		return this.materials[a]
	},
	loadTexture : function (a, b, c, d) {
		var e = null;
		/\.dds$/i.test(a) ? e = THREE.ImageUtils.loadCompressedTexture(a, b, c, d) : (d = new Image, e = new THREE.Texture(d, b), b = new THREE.ImageLoader, b.crossOrigin = this.crossOrigin, b.load(a, function (a) {
					e.image = skim.utils.MTLLoader.ensurePowerOfTwo_(a);
					e.needsUpdate = !0;
					c && c(e)
				}));
		return e
	}
};
skim.utils.MTLLoader.ensurePowerOfTwo_ = function (a) {
	if (!THREE.Math.isPowerOfTwo(a.width) || !THREE.Math.isPowerOfTwo(a.height)) {
		var b = document.createElement("canvas");
		b.width = skim.utils.MTLLoader.nextHighestPowerOfTwo_(a.width);
		b.height = skim.utils.MTLLoader.nextHighestPowerOfTwo_(a.height);
		b.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, b.width, b.height);
		return b
	}
	return a
};
skim.utils.MTLLoader.nextHighestPowerOfTwo_ = function (a) {
	--a;
	for (var b = 1; 32 > b; b <<= 1)
		a |= a >> b;
	return a + 1
};
THREE.EventDispatcher.prototype.apply(skim.utils.MTLLoader.prototype);
skim.PhysicalMaterialEditor = function (a, b) {
	var c = this;
	this.width = b.width;
	this.height = b.height;
	this.camera = new THREE.PerspectiveCamera(60, this.width / this.height, 1, 1E5);
	this.camera.position.z = 300;
	this.cameraCube = new THREE.PerspectiveCamera(60, this.width / this.height, 1, 1E5);
	this.scene = new THREE.Scene;
	this.sceneCube = new THREE.Scene;
	this.renderer = new THREE.WebGLRenderer({
			canvas : b,
			antialias : !0
		});
	this.renderer.setSize(this.width, this.height);
	this.renderer.autoClear = !1;
	a.appendChild(this.renderer.domElement);
	var d = skim.instances.ressourcesPath + "img/cubeMaps/LandscapeMountain/blackandwhite/mountain_0",
	d = THREE.ImageUtils.loadTextureCube([d + "0.jpg", d + "1.jpg", d + "2.jpg", d + "3.jpg", d + "4.jpg", d + "5.jpg"], THREE.Texture.DEFAULT_MAPPING, function () {
			c.render()
		});
	d.format = THREE.RGBFormat;
	var e = THREE.ShaderLib.cube,
	f = THREE.UniformsUtils.clone(e.uniforms);
	f.tCube.value = d;
	d = new THREE.ShaderMaterial({
			fragmentShader : e.fragmentShader,
			vertexShader : e.vertexShader,
			uniforms : f,
			depthWrite : !1,
			side : THREE.BackSide
		});
	this.envcube_mesh =
		new THREE.Mesh(new THREE.BoxGeometry(1E3, 1E3, 1E3), d);
	this.sceneCube.add(this.envcube_mesh);
	this.sphere = new THREE.Mesh((new THREE.BufferGeometry).fromGeometry(new THREE.SphereGeometry(100, 32, 16)), skim.getPhysicalMaterialFunction(!0, !0, !0)(function (a) {
				c.render()
			}));
	d = this.sphere.geometry.getAttribute("position").count;
	this.sphere.geometry.addAttribute("roughness", new THREE.BufferAttribute(new Float32Array(d), 1));
	this.sphere.geometry.addAttribute("metallic", new THREE.BufferAttribute(new Float32Array(d),
			1));
	this.sphere.geometry.addAttribute("color", new THREE.BufferAttribute(new Float32Array(3 * d), 3));
	for (e = 0; e < d; ++e)
		this.sphere.geometry.getAttribute("roughness").setX(e, 0.4), this.sphere.geometry.getAttribute("metallic").setX(e, 0.15), this.sphere.geometry.getAttribute("color").setXYZ(e, 0.6);
	this.scene.add(this.sphere);
	this.camera.lookAt(this.scene.position);
	this.cameraCube.rotation.copy(this.camera.rotation);
	this.render();
	this.timeout = null
};
skim.PhysicalMaterialEditor.prototype.onCanvasResize = function () {
	this.camera.aspect = this.width / this.height;
	this.camera.updateProjectionMatrix();
	this.cameraCube.aspect = this.width / this.height;
	this.cameraCube.updateProjectionMatrix();
	this.renderer.setSize(this.width, this.height);
	this.render()
};
skim.PhysicalMaterialEditor.prototype.render = function () {
	this.renderer.render(this.sceneCube, this.cameraCube);
	this.renderer.render(this.scene, this.camera)
};
skim.PhysicalMaterialEditor.prototype.timeoutRender = function () {
	var a = this;
	null === this.timeout && (this.timeout = setTimeout(function () {
				a.render();
				a.timeout = null
			}, 40))
};
skim.PhysicalMaterialEditor.prototype.setRoughness = function (a) {
	for (var b = this.sphere.geometry.getAttribute("roughness"), c = 0; c < b.count; ++c)
		b.setX(c, a);
	b.needsUpdate = !0;
	this.timeoutRender()
};
skim.PhysicalMaterialEditor.prototype.setMetallic = function (a) {
	for (var b = this.sphere.geometry.getAttribute("metallic"), c = 0; c < b.count; ++c)
		b.setX(c, a);
	b.needsUpdate = !0;
	this.timeoutRender()
};
skim.PhysicalMaterialEditor.prototype.setColor = function (a) {
	for (var b = this.sphere.geometry.getAttribute("color"), c = this.sphere.geometry.getAttribute("position"), d = 0; d < c.count; ++d)
		b.setXYZ(d, a.r, a.g, a.b);
	b.needsUpdate = !0;
	this.timeoutRender()
};
skim.PhysicalMaterialEditor.prototype.getRoughness = function (a) {
	return this.sphere.geometry.getAttribute("roughness").array[0]
};
skim.PhysicalMaterialEditor.prototype.getMetallic = function (a) {
	return this.sphere.geometry.getAttribute("metallic").array[0]
};
skim.PhysicalMaterialEditor.prototype.getColor = function (a) {
	return new THREE.Color(this.sphere.geometry.getAttribute("color").array[0], this.sphere.geometry.getAttribute("color").array[1], this.sphere.geometry.getAttribute("color").array[2])
};
skim.PhysicalMaterialEditor.prototype.setEnvMap = function (a, b) {
	var c = this,
	d = THREE.ImageUtils.loadTextureCube([b[0].px, b[0].nx, b[0].py, b[0].ny, b[0].pz, b[0].nz], THREE.Texture.DEFAULT_MAPPING, function () {
			c.render()
		});
	d.format = THREE.RGBFormat;
	var e = THREE.ShaderLib.cube,
	f = THREE.UniformsUtils.clone(e.uniforms);
	f.tCube.value = d;
	d = new THREE.ShaderMaterial({
			fragmentShader : e.fragmentShader,
			vertexShader : e.vertexShader,
			uniforms : f,
			depthWrite : !1,
			side : THREE.BackSide
		});
	this.envcube_mesh.material = d;
	for (var g = [null, null,
			null, null, null, null, null], h = 0, d = function () {
		h++;
		if (6 === h) {
			for (var a = 0; 6 > a; ++a)
				c.sphere.material.uniforms["envMap" + a].value = g[a];
			c.sphere.material.uniforms.diffuseMap.value = g[6];
			c.render()
		}
	}, e = 0; 7 > e; ++e)
		f = null, f = 6 === e ? a : b[e], g[e] = THREE.ImageUtils.loadTextureCube([f.px, f.nx, f.py, f.ny, f.pz, f.nz], THREE.Texture.DEFAULT_MAPPING, d), g[e].format = THREE.RGBFormat
};
skim.PBRCubemapComputer = function (a, b, c, d, e, f, g, h, k, l) {
	skim.utils.assert(256 <= a.width && 256 <= b.width && 256 <= c.width && 256 <= a.height && 256 <= b.height && 256 <= c.height && 256 <= d.width && 256 <= e.width && 256 <= f.width && 256 <= d.height && 256 <= e.height && 256 <= f.height, "Error : Environment cubemap must be at least 256 in all dimensions");
	skim.utils.assert(a.width === a.height && b.width === b.height && c.width === c.height && d.width === d.height && e.width === e.height && f.width === f.height, "Error : Environment cubemap sprites must be square in dimensions");
	this.orig_canvas = document.createElement("canvas");
	this.orig_ctx = this.orig_canvas.getContext("2d");
	this.orig_canvas.width = 256;
	this.orig_canvas.height = 256;
	this.canvas = document.createElement("canvas");
	this.ctx = this.canvas.getContext("2d");
	this.canvas.width = 256;
	this.canvas.height = 256;
	this.keys = "nx ny nz px py pz".split(" ");
	this.environment = {
		nx : a,
		ny : b,
		nz : c,
		px : d,
		py : e,
		pz : f
	};
	this.mipmaps = [];
	this.diffuse = [];
	this.specular = [];
	for (a = 0; 6 > a; ++a)
		this.specular.push({
			nx : null,
			ny : null,
			nz : null,
			px : null,
			py : null,
			pz : null
		}),
		this.diffuse.push({
			nx : null,
			ny : null,
			nz : null,
			px : null,
			py : null,
			pz : null
		}), this.mipmaps.push({
			nx : null,
			ny : null,
			nz : null,
			px : null,
			py : null,
			pz : null
		});
	for (a = 0; a < this.keys.length; ++a)
		this.orig_canvas.width = this.environment[this.keys[a]].width, this.orig_canvas.height = this.environment[this.keys[a]].height, this.orig_ctx.putImageData(this.environment[this.keys[a]], 0, 0), this.ctx.drawImage(this.orig_canvas, 0, 0, 256, 256), this.specular[0][this.keys[a]] = this.ctx.getImageData(0, 0, 256, 256);
	for (a = 0; 6 > a; ++a)
		for (b = 0; b < this.keys.length; ++b)
			c =
				this.keys[b], d = this.getResolutionFromLevel(a), this.orig_canvas.width = this.environment[this.keys[b]].width, this.orig_canvas.height = this.environment[this.keys[b]].height, this.orig_ctx.putImageData(this.environment[this.keys[b]], 0, 0), this.ctx.drawImage(this.orig_canvas, 0, 0, d, d), this.mipmaps[a][c] = this.ctx.getImageData(0, 0, d, d), this.diffuse[a][c] = this.ctx.getImageData(0, 0, d, d), 0 !== a && (this.specular[a][c] = this.ctx.getImageData(0, 0, d, d));
	this.worker = new Worker(skim.instances.ressourcesPath + "SkimWorkerPBRCubemapComputer.min.js");
	var m = this;
	this.worker.addEventListener("message", function (a) {
		a = a.data;
		switch (a.cmd) {
		case "diffuse_progress":
			g(a.progressMessage, a.progressPercent);
			break;
		case "diffuse":
			m.diffuse[a.level] = a.diffuse[a.level];
			k(m);
			break;
		case "specular_progress":
			h(a.progressMessage, a.progressPercent);
			break;
		case "specular":
			for (var b = a.levela; b <= a.levelb; ++b)
				m.specular[b] = a.specular[b];
			l(m);
			break;
		default:
			console.error('WorkerPBRCubemapComputer unrecognized command "' + a.cmd)
		}
	}, !1);
	this.worker.postMessage({
		cmd : "init",
		mipmaps : this.mipmaps,
		specular : this.specular,
		diffuse : this.diffuse
	})
};
skim.PBRCubemapComputer.prototype.getResolutionFromLevel = function (a) {
	return 256 / Math.pow(2, a)
};
skim.PBRCubemapComputer.prototype.getMipmapsDataURL = function (a) {
	var b = {},
	c = this.mipmaps[a][this.keys[0]].width;
	this.canvas.width = c;
	this.canvas.height = c;
	for (c = 0; c < this.keys.length; ++c)
		this.ctx.putImageData(this.mipmaps[a][this.keys[c]], 0, 0), b[this.keys[c]] = this.canvas.toDataURL();
	return b
};
skim.PBRCubemapComputer.prototype.getDiffuseDataURL = function (a) {
	if (null !== this.diffuse[a][this.keys[0]]) {
		var b = {},
		c = this.getResolutionFromLevel(a);
		this.canvas.width = c;
		this.canvas.height = c;
		for (var d = 0; d < this.keys.length; ++d)
			this.ctx.putImageData(this.diffuse[a][this.keys[d]], 0, 0, 0, 0, c, c), b[this.keys[d]] = this.canvas.toDataURL();
		return b
	}
	console.warning("Cannot get diffuse for level " + a + ". This level has not been computed yet, call computeDiffuse(lvl)")
};
skim.PBRCubemapComputer.prototype.getSpecularDataURL = function () {
	for (var a = [{}, {}, {}, {}, {}, {}

		], b = 0; 6 > b; ++b)
		if (null !== this.specular[b][this.keys[0]]) {
			var c = this.getResolutionFromLevel(b);
			this.canvas.width = c;
			this.canvas.height = c;
			for (c = 0; c < this.keys.length; ++c)
				this.ctx.putImageData(this.specular[b][this.keys[c]], 0, 0), a[b][this.keys[c]] = this.canvas.toDataURL()
		}
	return a
};
skim.PBRCubemapComputer.prototype.computeDiffuse = function (a) {
	this.worker.postMessage({
		cmd : "diffuse",
		level : a
	})
};
skim.PBRCubemapComputer.prototype.computeSpecular = function (a, b) {
	this.worker.postMessage({
		cmd : "specular",
		levela : a,
		levelb : b
	})
};
var isWorker = !1;
try {
	document
} catch (e$$16) {
	isWorker = !0
}
isWorker && (self.Worker = function (a) {
	var b = this;
	this.id = Math.random().toString(36).substr(2, 5);
	this.eventListeners = {
		message : []
	};
	self.addEventListener("message", function (a) {
		if (a.data._from === b.id) {
			var c = new MessageEvent("message");
			c.initMessageEvent && c.initMessageEvent("message", !1, !1, a.data.message, b, "", null, []);
			b.dispatchEvent(c);
			if (b.onmessage)
				b.onmessage(c)
		}
	}, !1);
	var c = self.location.pathname;
	a = c.substring(0, c.lastIndexOf("/")) + "/" + a;
	self.postMessage({
		_subworker : !0,
		cmd : "newWorker",
		id : this.id,
		path : a
	})
},
	Worker.prototype = {
		onerror : null,
		onmessage : null,
		postMessage : function (a) {
			self.postMessage({
				_subworker : !0,
				id : this.id,
				cmd : "passMessage",
				message : a
			})
		},
		terminate : function () {
			self.postMessage({
				_subworker : !0,
				cmd : "terminate",
				id : this.id
			})
		},
		addEventListener : function (a, b, c) {
			this.eventListeners[a] && this.eventListeners[a].push(b)
		},
		removeEventListener : function (a, b, c) {
			b = this.eventListeners[a].indexOf(b);
			-1 !== b && this.eventListeners[a].splice(b, 1)
		},
		dispatchEvent : function (a) {
			for (var b = this.eventListeners[a.type], c = 0; c <
				b.length; c++)
				b[c](a);
			return !0
		}
	});
var allWorkers = {}, cmds = {
	newWorker : function (a) {
		var b = new Worker(a.data.path);
		b.addEventListener("message", function (b) {
			a.target.postMessage({
				_from : a.data.id,
				_workerId : self.workerId,
				message : b.data
			})
		}, !1);
		allWorkers[a.data.id] = b
	},
	terminate : function (a) {
		allWorkers[a.data.id].terminate()
	},
	passMessage : function (a) {
		allWorkers[a.data.id].postMessage(a.data.message)
	}
}, messageReceived = function (a) {
	if (a.data._subworker)
		cmds[a.data.cmd](a)
},
oldWorker = null,
oldWorker = isWorker ? Worker : window.Worker;
Worker = function (a) {
	if (this.constructor !== Worker)
		throw new TypeError("Failed to construct 'Worker': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
	a = new oldWorker(a);
	a.addEventListener("message", messageReceived, !1);
	return a
};
oldWorker.prototype.isTransferable = function (a) {
	a = a.constructor;
	return a == MessagePort || a == ArrayBuffer
};
oldWorker.prototype.getTransferableList = function (a) {
	var b,
	c,
	d = [];
	for (b in a)
		a.hasOwnProperty(b) && (c = a[b], null !== c && "object" === typeof c && (this.isTransferable(c) ? (console.log(a.constructor.name + "." + b + " is transferable !"), d.push(c)) : d = d.concat(this.getTransferableList(c))));
	return d
};
oldWorker.prototype.postMessageByReference = function (a) {
	var b = this.getTransferableList(a);
	0 == b.length ? (console.log("posting message by copy"), this.postMessage(a)) : (console.log("posting message by reference with transferList: " + b.toString()), this.postMessage(a, b))
};
skim.skel.Skeleton = function () {
	_.extend(this, Backbone.Events);
	this.aabb = new skim.geometry.AABBox;
	this.vertices = {};
	this.prims = {};
	this.onPrimChanged = function (a) {
		this.computeAABB();
		this.trigger("primChanged", a)
	};
	this.onVertexChange = function (a) {
		this.computeAABB();
		this.trigger("vertexChanged", a)
	};
	this.getAABB = function () {
		return this.aabb
	};
	this.addVertex = function (a) {
		skim.utils.assert(void 0 === this.vertices[a.id], "Error in Skeleton : the vertex to add already belong to the skeleton. Double insertion is not a valid action");
		this.vertices[a.id] = a;
		this.aabb.union(a.getAABB());
		this.listenTo(a, "change", this.onVertexChange);
		a = {
			type : "vertexAdded",
			v : a
		};
		this.trigger(a.type, a)
	};
	this.addPrim = function (a) {
		skim.utils.assert(void 0 === this.prims[a.id], "Error in Skeleton : the primitive to add already belong to the skeleton, double insertion is not a valid action");
		for (var b = 0; b < a.v.length; ++b)
			skim.utils.assert(void 0 !== this.vertices[a.v[b].id], "ERROR : the added primitive onws vertices which are not in the skeleton");
		this.aabb.union(a.getAABB());
		this.prims[a.id] = a;
		this.listenTo(a, "primChanged", this.onPrimChanged);
		a = {
			type : "primAdded",
			p : a
		};
		this.trigger(a.type, a)
	};
	this.removeVertex = function (a) {
		skim.utils.assert(void 0 !== this.vertices[a.id], "Error in Skeleton : the removed vertex does not belong to the skeleton. Invalid operation.");
		var b = {
			type : "aboutToRemoveVertex",
			v : a
		};
		this.trigger(b.type, b);
		for (var c in a.owners)
			if (a.owners.hasOwnProperty(c)) {
				var b = a.owners[c],
				d;
				for (d in b)
					b.hasOwnProperty(d) && (skim.utils.assert(!1, "Error : Primitive " + b[d].id +
							" should have been removed before vertex " + a.id + " removal."), this.removePrim(b[d]))
			}
		delete this.vertices[a.id];
		this.computeAABB();
		b = {
			type : "vertexRemoved",
			v : a
		};
		this.trigger(b.type, b)
	};
	this.removePrim = function (a) {
		skim.utils.assert(void 0 !== this.prims[a.id], "Error in Skeleton : the removed primitive does not belong to the skeleton. Invalid operation");
		var b = {
			type : "aboutToRemovePrim",
			p : a
		};
		this.trigger(b.type, b);
		this.stopListening(a);
		a.destroy();
		delete this.prims[a.id];
		this.computeAABB();
		b = {
			type : "primRemoved",
			p : a
		};
		this.trigger(b.type, b)
	};
	this.clean = function () {
		var a = {
			type : "aboutToClean"
		};
		this.trigger(a.type, a);
		for (var b in this.prims)
			this.prims.hasOwnProperty(b) && this.removePrim(this.prims[b]);
		for (var c in this.vertices)
			this.vertices.hasOwnProperty(c) && this.removeVertex(this.vertices[c]);
		this.computeAABB();
		a = {
			type : "cleaned"
		};
		this.trigger(a.type, a)
	};
	this.computeAABB = function () {
		this.aabb.setEmpty();
		for (var a = Object.keys(this.prims), b = a.length, c = 0; c < b; ++c)
			this.aabb.union(this.prims[a[c]].getAABB());
		a = Object.keys(this.vertices);
		b = a.length;
		for (c = 0; c < b; ++c)
			this.aabb.union(this.vertices[a[c]].getAABB())
	};
	this.getValencyMap = function () {
		for (var a = {}, b = Object.keys(this.vertices), c = 0; c < b.length; ++c) {
			var d = this.vertices[b[c]];
			a[d.id] = d.getValency()
		}
		return a
	};
	this.getClosestVertexToRay = function (a) {
		for (var b = Number.MAX_VALUE, c = null, d = Object.keys(this.vertices), e = 0; e < d.length; ++e) {
			var f = this.vertices[d[e]].getDistanceToRay(a);
			f < b && (b = f, c = this.vertices[d[e]])
		}
		return c
	}
};
skim.skel.PrimitiveReactor = Backbone.Model.extend({
		initialize : function (a, b) {
			this.id = a.id;
			this.v = [];
			void 0 === a.materials && (a.materials = null);
			this.widgetinfo = {
				v_idx : null,
				f_idx : null,
				color : null
			};
			this.aabb = new skim.geometry.AABBox;
			this.type = null
		},
		getVertexIndexById : function (a) {
			for (var b = 0; b < this.v.length; b++)
				if (this.v[b].id === a)
					return b;
			return -1
		},
		getVertexIndex : function (a) {
			for (var b = 0; b < this.v.length; ++b)
				if (this.v[b] == a)
					return b;
			skim.utils.assert(!1, "Should not reach this code : cannot return the index of a vertex which does not belong to the primitive");
			return -1
		},
		getAABB : function () {
			return this.aabb
		},
		primChanged : function (a) {
			this.trigger("primChanged", {
				p : this,
				data : a
			})
		},
		destroy : function () {
			skim.utils.assert(!1, "ERROR : destroy is a virtual function, should be re-implemented in all primitives(error occured in " + this.type + " primitive)")
		},
		computeAABB : function () {
			skim.utils.assert(!1, "ERROR : computeAABB is a virtual function, should be re-implemented in all primitives (error occured in " + this.type + " primitive)")
		},
		getType : function () {
			return this.type
		},
		getVolType : function () {
			return this.get("volType")
		},
		setVolType : function (a) {
			this.set({
				volType : a
			})
		},
		getMaterials : function () {
			return this.get("materials")
		},
		setMaterials : function (a) {
			return this.set({
				materials : a
			})
		},
		swapVertex : function (a, b) {
			skim.utils.assert(!1, "ERROR : swapVertex is a virtual function, should be re-implemented in all primitives (error occured in " + this.type + " primitive)")
		}
	});
skim.skel.typeVertex = "vertex";
skim.skel.VertexReactor = Backbone.Model.extend({
		initialize : function (a, b) {
			skim.utils.assert(void 0 !== a.pos && void 0 !== a.thickness, "A vertex cannot be created without position and thickness attributes");
			this.id = a.id;
			void 0 === a.material && this.set({
				material : skim.instances.defaultMaterial
			});
			this.vAdj = {};
			this.owners = {};
			this.widgetinfo = {
				v_idx : null,
				f_idx : null,
				color : null
			};
			this.listenTo(this, "change:pos", this.updatePos);
			this.listenTo(this, "change:thickness", this.updateThickness);
			this.aabb = new skim.geometry.AABBox;
			this.computeAABB(this.get("pos"), this.get("thickness"))
		},
		getPos : function () {
			return this.get("pos")
		},
		getThickness : function () {
			return this.get("thickness")
		},
		getMaterial : function () {
			return this.get("material")
		},
		getVolType : function () {
			return this.get("volType")
		},
		updatePos : function (a, b) {
			this.computeAABB(b, this.get("thickness"))
		},
		updateThickness : function (a, b) {
			this.computeAABB(this.get("pos"), b)
		},
		getAABB : function () {
			return this.aabb
		},
		addVAdj : function (a) {
			void 0 !== this.vAdj[a.id] ? this.vAdj[a.id].count++ : this.vAdj[a.id] = {
				v : a,
				count : 1
			}
		},
		removeVAdj : function (a) {
			void 0 !== this.vAdj[a.id] && (1 == this.vAdj[a.id].count ? delete this.vAdj[a.id] : this.vAdj[a.id].count--)
		},
		addOwner : function (a, b) {
			void 0 === this.owners[b] && (this.owners[b] = {});
			void 0 !== this.owners[b][a.id] && console.error("This primitive " + a.id + " is already an owner of the vertex " + this.id);
			this.owners[b][a.id] = a
		},
		hasOwner : function (a) {
			for (var b in this.owners)
				if (this.owners.hasOwnProperty(b)) {
					var c = this.owners[b],
					d;
					for (d in c)
						if (c.hasOwnProperty(d) && a == this.owners[b][d].id)
							return !0
				}
			return !1
		},
		getOwners : function (a) {
			return this.owners[a]
		},
		hasOwnerOfType : function (a) {
			for (var b in this.owners)
				if (this.owners.hasOwnProperty(b)) {
					var c = this.owners[b],
					d;
					for (d in c)
						if (c.hasOwnProperty(d) && this.owners[b][d]instanceof a)
							return !0
				}
			return !1
		},
		removeOwner : function (a, b) {
			var c = this.owners[b];
			void 0 !== c && void 0 !== c[a.id] && (delete c[a.id], skim.utils.isEmpty(c) && delete this.owners[b])
		},
		computeAABB : function (a, b) {
			this.aabb.set(a.x - b, a.y - b, a.z - b, a.x + b, a.y + b, a.z + b)
		},
		isLocalMaximum : function () {
			for (var a = !0, b = Object.keys(this.vAdj),
				c = b.length, d = 0; d < c; ++d)
				if (this.get("thickness") <= this.vAdj[b[d]].v.get("thickness")) {
					a = !1;
					break
				}
			return a
		},
		getValency : function () {
			for (var a = 0, b = Object.keys(this.vAdj), c = 0; c < b.length; ++c)
				a += this.vAdj[b[c]].count;
			return a
		},
		getDistanceToRay : function (a) {
			var b = {
				inter1 : 0,
				inter2 : 0
			},
			c = new THREE.Sphere(new THREE.Vector3, 1),
			d = new THREE.Vector3;
			d.subVectors(this.getPos(), a.origin);
			return 0 <= d.dot(a.direction) ? (c.center.copy(this.getPos()), c.radius = this.getThickness(), 0 < a.getSphereIntersections(c, b) ? 0 : a.distanceToPoint(this.getPos()) -
				this.getThickness()) : Number.MAX_VALUE
		}
	});
skim.skel.VertexReactor.getAdjVertices = function (a) {
	for (var b = {}, c = null, d = Object.keys(a), e = 0; e < d.length; ++e)
		for (var f = a[d[e]].vAdj, g = Object.keys(f), h = 0; h < g.length; h++)
			c = f[g[h]].v, b[c.id] = c;
	return b
};
skim.skel.tokenVSegment = "segments";
skim.skel.typeSegment = "segment";
skim.skel.SegmentReactor = skim.skel.PrimitiveReactor.extend({
		initialize : function (a, b) {
			void 0 === a.materials && (a.materials = null);
			skim.skel.PrimitiveReactor.prototype.initialize.call(this, a, b);
			skim.utils.assert(void 0 !== a.v0 && void 0 !== a.v1, "v0 and v1 cannot be undefined");
			this.type = skim.skel.typeSegment;
			this.v[0] = a.v0;
			this.v[1] = a.v1;
			this.dir = new THREE.Vector3;
			this.length = this.lengthSq = 0;
			this.unit_dir = new THREE.Vector3;
			this.computeHelpVariables();
			a.v0.addVAdj(a.v1);
			a.v1.addVAdj(a.v0);
			a.v0.addOwner(this,
				skim.skel.tokenVSegment);
			a.v1.addOwner(this, skim.skel.tokenVSegment);
			this.listenTo(a.v0, "change:thickness", this.onChange);
			this.listenTo(a.v1, "change:thickness", this.onChange);
			this.listenTo(a.v0, "change:pos", this.onChange);
			this.listenTo(a.v1, "change:pos", this.onChange);
			this.computeAABB()
		},
		onChange : function (a) {
			this.computeHelpVariables();
			this.computeAABB();
			this.primChanged()
		},
		swapVertex : function (a, b) {
			skim.utils.assert(0 === a || 1 === a, "Error : cannot swap vertex " + a + " in a segment (only v0 and v1)");
			if (this.v[a] !=
				b || !b.hasOwner(this.id)) {
				var c = 0 === a ? 1 : 0;
				this.v[c].removeVAdj(this.v[a]);
				this.v[a].removeVAdj(this.v[c]);
				this.v[c].addVAdj(b);
				b.addVAdj(this.v[c]);
				this.v[a].removeOwner(this, skim.skel.tokenVSegment);
				b.addOwner(this, skim.skel.tokenVSegment);
				this.stopListening(this.v[a]);
				this.v[a] = b;
				this.listenTo(this.v[a], "change:thickness", this.onChange);
				this.listenTo(this.v[a], "change:pos", this.onChange);
				this.onChange(b)
			}
		},
		destroy : function () {
			this.stopListening();
			this.v[0].removeVAdj(this.v[1]);
			this.v[1].removeVAdj(this.v[0]);
			this.v[0].removeOwner(this, skim.skel.tokenVSegment);
			this.v[1].removeOwner(this, skim.skel.tokenVSegment)
		},
		computeHelpVariables : function () {
			this.dir.subVectors(this.v[1].get("pos"), this.v[0].get("pos"));
			this.lengthSq = this.dir.lengthSq();
			this.length = Math.sqrt(this.lengthSq);
			this.unit_dir.set(this.dir.x, this.dir.y, this.dir.z);
			this.unit_dir.multiplyScalar(1 / this.length)
		},
		computeAABB : function () {
			this.aabb.setEmpty();
			this.aabb.union(this.v[0].getAABB());
			this.aabb.union(this.v[1].getAABB())
		}
	});
skim.skel.tokenVTriangle = "triangles";
skim.skel.typeTriangle = "triangle";
skim.skel.TriangleReactor = skim.skel.PrimitiveReactor.extend({
		initialize : function (a, b) {
			void 0 === a.materials && (a.materials = null);
			skim.skel.PrimitiveReactor.prototype.initialize.call(this, a, b);
			skim.utils.assert(3 === a.v.length, "Triangle must have 3 vertices");
			this.type = skim.skel.typeTriangle;
			this.v = a.v;
			this.p0p1 = new THREE.Vector3;
			this.p1p2 = new THREE.Vector3;
			this.p2p0 = new THREE.Vector3;
			this.unit_normal = new THREE.Vector3;
			this.unit_p0p1 = new THREE.Vector3;
			this.unit_p1p2 = new THREE.Vector3;
			this.unit_p2p0 = new THREE.Vector3;
			this.diffThick_p0p1 = this.diffThick_p0p1 = this.diffThick_p0p1 = this.length_p2p0 = this.length_p1p2 = this.length_p0p1 = 0;
			this.main_dir = new THREE.Vector3;
			this.point_iso_zero = new THREE.Vector3;
			this.ortho_dir = new THREE.Vector3;
			this.unsigned_ortho_dir = new THREE.Vector3;
			this.proj_dir = new THREE.Vector3;
			this.equal_weights = !1;
			this.max_seg_length = this.longest_dir_special = this.unit_delta_weight = this.coord_middle = this.coord_max = 0;
			this.half_dir_1 = new THREE.Vector3;
			this.point_half = new THREE.Vector3;
			this.half_dir_2 = new THREE.Vector3;
			this.point_min = new THREE.Vector3;
			this.weight_min = 0;
			this.addVArrAdj();
			this.addOwner();
			this.listenToAllVertices();
			this.computeHelpVariables();
			this.computeAABB()
		},
		addVArrAdj : function () {
			for (var a = 0, b = this.v.length - 1; a < this.v.length; a++, b = a - 1)
				this.v[a].addVAdj(this.v[b]), this.v[b].addVAdj(this.v[a])
		},
		removeVArrAdj : function () {
			for (var a = 0, b = this.v.length - 1; a < this.v.length; a++, b = a - 1)
				this.v[a].removeVAdj(this.v[b]), this.v[b].removeVAdj(this.v[a])
		},
		addOwner : function () {
			for (var a = 0; a < this.v.length; a++)
				this.v[a].addOwner(this,
					skim.skel.tokenVTriangle)
		},
		removeOwner : function () {
			for (var a = 0; a < this.v.length; a++)
				this.v[a].removeOwner(this, skim.skel.tokenVTriangle)
		},
		listenToAllVertices : function () {
			for (var a = 0, b = this.v.length; a < b; a++)
				this.listenTo(this.v[a], "change:thickness", this.onChange), this.listenTo(this.v[a], "change:pos", this.onChange)
		},
		onChange : function (a) {
			this.computeHelpVariables();
			this.computeAABB();
			this.primChanged()
		},
		swapVertex : function (a, b) {
			skim.utils.assert(0 <= a && 3 > a, "Error : cannot swap vertex " + a + " in a triangle (only 3 vertices)");
			this.v[a] == b && b.hasOwner(this.id) || (this.swapVertAdj(skim.ringUtils.cleanIndex(a - 1, 3), a, b), this.swapVertAdj(skim.ringUtils.cleanIndex(a + 1, 3), a, b), this.v[a].removeOwner(this, skim.skel.tokenVTriangle), b.addOwner(this, skim.skel.tokenVTriangle), this.stopListening(this.v[a]), this.v[a] = b, this.listenTo(this.v[a], "change:thickness", this.onChange), this.listenTo(this.v[a], "change:pos", this.onChange), this.onChange(b))
		},
		swapVertAdj : function (a, b, c) {
			this.v[a].removeVAdj(this.v[b]);
			this.v[b].removeVAdj(this.v[a]);
			this.v[a].addVAdj(c);
			c.addVAdj(this.v[a])
		},
		computeHelpVariables : function () {
			skim.triangleUtils.computeVectorsDirs(this)
		},
		destroy : function () {
			this.stopListening();
			this.removeVArrAdj();
			this.removeOwner()
		},
		computeAABB : function () {
			this.aabb.setEmpty();
			for (var a = 0; a < this.v.length; a++)
				this.aabb.union(this.v[a].getAABB())
		}
	});
skim.skel.tokenVRings = "rings";
skim.skel.typeRing = "ring";
skim.skel.RingReactor = skim.skel.PrimitiveReactor.extend({
		initialize : function (a, b) {
			skim.skel.PrimitiveReactor.prototype.initialize.call(this, a, b);
			skim.utils.assert(4 <= a.v.length && 4 * Math.floor(a.v.length / 4) == a.v.length, "Vertex array in ring constructor must be more than 4 in length and a multiple of 4");
			this.type = skim.skel.typeRing;
			this.v = a.v;
			this.token = skim.skel.tokenVRings;
			this.rMin = skim.geometry.Max;
			this.rMax = -skim.geometry.Max;
			this.zMax = -skim.geometry.Max;
			this.zMin = skim.geometry.Max;
			this.lMax = -skim.geometry.Max;
			this.thickMin = skim.geometry.Max;
			this.thickMax = -skim.geometry.Max;
			this.theta = [];
			this.rz = [];
			this.arcStep = 0;
			this.constraintsIndices = [];
			this.CValid = {};
			this.listenToAllVertices();
			for (var c = 0, d = a.v.length; c < d; c++)
				a.v[c].addOwner(this, this.token);
			c = 0;
			for (d = a.v.length; c < d; c += 4)
				a.v[c].addVAdj(a.v[c + 1]), a.v[c + 1].addVAdj(a.v[c]), a.v[c + 1].addVAdj(a.v[c + 2]), a.v[c + 2].addVAdj(a.v[c + 1]), a.v[c + 2].addVAdj(a.v[c + 3]), a.v[c + 3].addVAdj(a.v[c + 2]), a.v[c + 3].addVAdj(a.v[c]), a.v[c].addVAdj(a.v[c + 3]);
			this.interpolantFunctions = {
				radial : [],
				height : [],
				thickness : []
			};
			this.computeHelpVariables();
			this.computeAABB()
		},
		hasValidVertices : function () {
			var a = !0;
			0 !== this.v.length % 4 && (a = !1, console.error("Vertices should be a multiple of 4"));
			this.rz.length !== this.v.length && (a = !1, console.error("RZ array correspond to the vertices array"));
			this.theta.length !== this.v.length / 4 && (a = !1, console.error("RZ array correspond to the vertices array"));
			for (var b = 0, c = 0; c < this.v.length; c++)
				void 0 !== this.v[c].owners[this.token] && void 0 !== this.v[c].owners[this.token][this.id] ||
				b++;
			0 < b && (a = !1, console.error("Ring knows " + b + " vertex without ownership"));
			for (c = 0; c < this.v.length; c += 4)
				skim.geometry.IsConvex(this.rz[c], this.rz[c + 1], this.rz[c + 2], this.rz[c + 3]) || (a = !1, console.error("Ring has vertices that are not convex")), skim.geometry.IsCoplanar(this.rz[c], this.rz[c + 1], this.rz[c + 2], this.rz[c + 3], 1E-6) || (a = !1, console.error("Ring has vertices that are not coplanar"));
			0 !== Object.keys(this.CValid).length && (a = !1, console.error("Ring has not computed every changes"));
			skim.utils.assert(a,
				"The ring is not valid")
		},
		computeAABB : function () {
			this.aabb.set(-this.rMax - this.thickMax, -this.rMax - this.thickMax, this.zMin - this.thickMax, this.rMax + this.thickMax, this.rMax + this.thickMax, this.zMax + this.thickMax)
		},
		listenToAllVertices : function () {
			for (var a = 0, b = this.v.length; a < b; a++)
				this.listenTo(this.v[a], "change:thickness", this.onChange), this.listenTo(this.v[a], "change:pos", this.onChange)
		},
		onChange : function (a) {
			var b = skim.ringUtils.getSetIdxFromId(this, a.id);
			if (-1 !== b) {
				if (void 0 === this.CValid[b]) {
					this.CValid[b] =
						[];
					for (var c = b; c < 4 + b; c++)
						this.v[c].id != a.id && this.CValid[b].push(this.v[c].id)
				} else if (0 !== this.CValid[b].length) {
					for (c = 0; this.CValid[b][c] != a.id && 4 >= c; )
						c++;
					4 > c && this.CValid[b].splice(c, 1)
				}
				0 === this.CValid[b].length && delete this.CValid[b];
				0 === Object.keys(this.CValid).length && (this.computeHelpVariables(), this.computeAABB(), this.primChanged())
			}
		},
		clearCValid : function () {
			if (Object.keys(this.CValid).length)
				for (var a = Object.keys(this.CValid), b = 0; b < a.length; ++b)
					delete this.CValid[a[b]]
		},
		destroy : function () {
			this.stopListening();
			for (var a = 0, b = this.v.length; a < b; a += 4)
				this.v[a].removeVAdj(this.v[a + 1]), this.v[a + 1].removeVAdj(this.v[a]), this.v[a + 1].removeVAdj(this.v[a + 2]), this.v[a + 2].removeVAdj(this.v[a + 1]), this.v[a + 2].removeVAdj(this.v[a + 3]), this.v[a + 3].removeVAdj(this.v[a + 2]), this.v[a + 3].removeVAdj(this.v[a]), this.v[a].removeVAdj(this.v[a + 3]);
			a = 0;
			for (b = this.v.length; a < b; a++)
				this.v[a].removeOwner(this, this.token)
		},
		computeHelpVariables : function () {
			skim.ringUtils.computeConstraints(this);
			this.hasValidVertices(this)
		},
		setV : function (a) {
			this.v =
				a;
			skim.utils.assert(0 === Object.keys(this.CValid).length, "On change validity is stil amiss")
		},
		swapVertex : function (a, b) {
			if (!(this.v[a] == b && b.hasOwner(this.id) || skim.ringUtils.hasVert(this, b.id))) {
				var c = Math.floor(a / 4),
				d = a % 4,
				e = c + skim.ringUtils.cleanIndex(d + 1, 4),
				c = c + skim.ringUtils.cleanIndex(d - 1, 4);
				this.v[e].removeVAdj(this.v[a]);
				this.v[c].removeVAdj(this.v[a]);
				this.v[e].addVAdj(b);
				this.v[c].addVAdj(b);
				this.v[a].removeOwner(this, this.token);
				void 0 === b.owners[this.token] && b.addOwner(this, this.token);
				this.stopListening(this.v[a]);
				this.v[a] = b;
				this.listenTo(this.v[a], "change:thickness", this.onChange);
				this.listenTo(this.v[a], "change:pos", this.onChange)
			}
		}
	});
skim.skel.tokenVMesh = "meshes";
skim.skel.typeMesh = "mesh";
skim.skel.MeshReactor = skim.skel.PrimitiveReactor.extend({
		initialize : function (a, b) {
			void 0 === a.materials && (a.materials = null);
			skim.skel.PrimitiveReactor.prototype.initialize.call(this, a, b);
			this.type = skim.skel.typeMesh;
			skim.utils.assert(null !== a.mesh && void 0 !== a.mesh, "Error : cannot build a MeshReactor without a mesh");
			this.abmesh = a.mesh.clone();
			this.computeHelpVariables();
			this.computeAABB()
		},
		getMesh : function () {
			return this.abmesh
		},
		setMesh : function (a) {
			var b = new THREE.Vector3,
			c = {
				added_or_removed : !1,
				mvv : []
			};
			if (a.n_vertices !== this.abmesh.n_vertices || a.n_faces !== this.abmesh.n_faces)
				c.added_or_removed = !0;
			if (!c.added_or_removed)
				for (var d = 0; d < 3 * a.n_faces; ++d)
					c.added_or_removed = c.added_or_removed || a.faces[d] !== this.abmesh.faces[d];
			if (c.added_or_removed)
				this.abmesh = a.clone();
			else {
				for (d = 0; d < a.n_vertices; ++d)
					if (a.getVX(d) !== this.abmesh.getVX(d) || a.getVY(d) !== this.abmesh.getVY(d) || a.getVZ(d) !== this.abmesh.getVZ(d))
						c.mvv.push(d), b.set(a.getVX(d), a.getVY(d), a.getVZ(d)), this.abmesh.setVertex(d, b);
				this.abmesh.normals =
					a.normals.slice(0, a.normals.length)
			}
			if (c.added_or_removed || 0 !== c.mvv.length)
				this.onChange(c)
		},
		onChange : function (a) {
			this.computeHelpVariables();
			this.computeAABB();
			this.primChanged(a)
		},
		swapVertex : function (a, b) {
			skim.utils.assert(!1, "Error : for now 03 01 2016, Mesh primitive has no vertices, so swapVertex should never been called")
		},
		destroy : function () {
			this.stopListening()
		},
		computeHelpVariables : function () {},
		computeAABB : function () {
			var a = this.abmesh.getAABB();
			this.aabb.set(a[0], a[1], a[2], a[3], a[4], a[5])
		}
	});
skim.skel.tokenVTextRings = "textrings";
skim.skel.typeTextRing = "textring";
skim.skel.TextRingReactor = skim.skel.RingReactor.extend({
		initialize : function (a, b) {
			skim.skel.RingReactor.prototype.initialize.call(this, a, b);
			this.type = skim.skel.typeTextRing;
			this.imageData = a.imageData;
			this.token = skim.skel.tokenVTextRings;
			for (var c = 0, d = a.v.length; c < d; c++)
				a.v[c].removeOwner(this, skim.skel.typeTextRing);
			c = 0;
			for (d = a.v.length; c < d; c++)
				a.v[c].addOwner(this, this.token)
		}
	});
skim.skel.tokenVTexts = "texts";
skim.skel.typeText = "text";
skim.skel.TextReactor = skim.skel.PrimitiveReactor.extend({
		initialize : function (a, b) {
			skim.skel.PrimitiveReactor.prototype.initialize.call(this, a, b);
			this.type = skim.skel.typeText;
			this.imageData = a.imageData;
			this.token = skim.skel.tokenVTexts;
			this.v = a.v;
			for (var c = 0, d = a.v.length; c < d; c++)
				a.v[c].removeOwner(this, skim.skel.typeText);
			c = 0;
			for (d = a.v.length; c < d; c++)
				a.v[c].addOwner(this, this.token);
			this.computeAABB();
			for (c = 0; c < this.v.length; c++)
				this.listenTo(this.v[c], "change:thickness", this.onChange), this.listenTo(this.v[c],
					"change:pos", this.onChange)
		},
		onChange : function (a) {
			this.computeHelpVariables();
			this.computeAABB();
			this.primChanged()
		},
		swapVertex : function (a, b) {
			skim.utils.assert(0 === a || 1 === a, "Error : cannot swap vertex " + a + " in a segment (only v0 and v1)");
			this.v[a] == b && b.hasOwner(this.id) || (this.v[a].removeOwner(this, this.token), b.addOwner(this, this.token), this.stopListening(this.v[a]), this.v[a] = b, this.listenTo(this.v[a], "change:thickness", this.onChange), this.listenTo(this.v[a], "change:pos", this.onChange), this.onChange(b))
		},
		destroy : function () {
			this.stopListening();
			for (var a = 0, b = this.v.length; a < b; a++)
				this.v[a].removeOwner(this, this.token)
		},
		computeHelpVariables : function () {},
		computeAABB : function () {
			this.aabb.setEmpty();
			this.aabb.union(this.v[0].getAABB());
			this.aabb.union(this.v[1].getAABB());
			this.aabb.union(this.v[2].getAABB());
			this.aabb.union(this.v[3].getAABB())
		}
	});
skim.skel.tokenVHeightMapRing = "HeightMapRings";
skim.skel.typeHeightMapRing = "heightmapring";
skim.skel.HeightMapRingReactor = skim.skel.PrimitiveReactor.extend({
		initialize : function (a, b) {
			skim.skel.PrimitiveReactor.prototype.initialize.call(this, a, b);
			skim.utils.assert(void 0 !== a.rlength && void 0 !== a.zlength && void 0 !== a.round && void 0 !== a.bump && void 0 !== a.radius && void 0 !== a.lambda && void 0 !== a.uniform_zlength && void 0 !== a.image && void 0 !== a.color_image_data, "rlength zlength round bump radius image must not be undefined");
			this.type = skim.skel.typeHeightMapRing;
			this.R = this.r = 0;
			this.computeHelpVariables();
			this.listenTo(this, "change", this.onChange);
			this.computeAABB()
		},
		getRLength : function () {
			return this.get("rlength")
		},
		getZLength : function () {
			return this.get("zlength")
		},
		getRound : function () {
			return this.get("round")
		},
		getBump : function () {
			return this.get("bump")
		},
		getRadius : function () {
			return this.get("radius")
		},
		getLambda : function () {
			return this.get("lambda")
		},
		isUniformZLength : function () {
			return this.get("uniform_zlength")
		},
		getImage : function () {
			return this.get("image")
		},
		getColorImageData : function () {
			return this.get("color_image_data")
		},
		onChange : function (a) {
			this.computeHelpVariables();
			this.computeAABB();
			this.primChanged()
		},
		destroy : function () {
			this.stopListening()
		},
		computeHelpVariables : function () {},
		computeAABB : function () {
			this.aabb.setEmpty();
			var a = this.getRadius() + this.getRLength() + this.getBump();
			this.getRadius();
			this.aabb = new skim.geometry.AABBox(-a, -a, -this.getZLength() / 2, a, a, this.getZLength() / 2)
		}
	});
skim.workerPath = {
	blobtrees : {
		SlidingMC : "SkimWorkerSlidingMC.min.js",
		Parallel : "SkimWorkerParallel.min.js",
		Octree : "SkimWorkerOctree.min.js"
	},
	parametrics : {
		HeightMap : "SkimWorkerHeightMapRing.min.js",
		Mesh : "SkimWorkerMesh.min.js"
	}
};
skim.MeshState = {
	OUTDATED : 0,
	COMPUTING : 1,
	UPTODATE : 2
};
skim.WorkerMeshBuilder = function (a, b, c) {
	this.debuggingSubWorkers = !1;
	if (a in skim.workerPath.blobtrees)
		this.workerType = "Parallel", this.workerPath = skim.instances.ressourcesPath + skim.workerPath.blobtrees[this.workerType], this.subworkersType = a, this.subworkersNumber = b ? navigator.hardwareConcurrency || 4 : 1, this.debuggingSubWorkers && (this.workerType = a, this.workerPath = skim.instances.ressourcesPath + skim.workerPath.blobtrees[this.workerType], this.subworkersType = a, this.subworkersNumber = 1);
	else if (a in skim.workerPath.parametrics)
		this.workerType =
			a, this.workerPath = skim.instances.ressourcesPath + skim.workerPath.parametrics[this.workerType];
	else {
		console.error(a + " isn't a recognized type of worker.");
		return
	}
	this.worker = null;
	this.workerLocalUpdate = c || !1;
	this.currentRequestID = 0;
	this.workerTerminating = this.listening = !1;
	this.meshState = skim.MeshState.OUTDATED;
	this.meshData = this.abmesh = null;
	this.callback = {};
	this.computeStatus = {
		isDone : !1,
		percent : 0
	};
	this.log("Creating a " + (b ? "multi-thread" : "single-thread") + " MeshBuilder with " + (b ? this.workerType : this.subworkersType) +
		" algorithm")
};
skim.WorkerMeshBuilder.prototype.setCallback = function (a, b, c, d) {
	skim.utils.assert("function" === typeof c, "hum, you messed up setcallback arguments, bro.");
	this.callback[a] = {
		func : c,
		scope : b,
		args : d
	}
};
skim.WorkerMeshBuilder.prototype.log = function (a) {
	console.log("%cWorkerMeshBuilder: " + a, "background: #00ffff; color: #FFFFF")
};
skim.WorkerMeshBuilder.prototype.post = function (a) {
	a.requestID = ++this.currentRequestID;
	this.worker.postMessage(a)
};
skim.WorkerMeshBuilder.prototype.init = function () {
	this.workerLocalUpdate || this.reset();
	this.meshState = skim.MeshState.OUTDATED;
	this.abmesh = new skim.utils.ArrayBufferMesh(0);
	this.meshData = new skim.utils.MeshData(null, 0, 0);
	this.currentRequestID = 0;
	this.computeStatus = {
		isDone : !1,
		percent : 0
	};
	this.worker = new Worker(this.workerPath);
	this.worker.addEventListener("error", function (a) {
		console.error("[Worker error] " + a.filename + ":" + a.lineno + " : " + a.message);
		throw Error(a.message, a.filename, a.lineno);
	}, !1);
	this.listen();
	this.log("send message to init worker");
	this.post({
		cmd : "init",
		localUpdate : this.workerLocalUpdate,
		subworkersNumber : this.subworkersNumber,
		subworkersType : this.subworkersType
	})
};
skim.WorkerMeshBuilder.prototype.onLog = function (a, b) {
	console.log("%cWorker " + this.workerType + " : " + a, "background: " + b + "; color: #000")
};
skim.WorkerMeshBuilder.prototype.onUp = function (a, b) {
	console.log("%cWorker " + this.workerType + " is up!", "background: " + b + "; color: #000");
	skim.utils.assert(void 0 !== a.localUpdate, "Error : localUpdate value must be send back in the up message");
	this.localUpdate !== a.localUpdate && (this.localUpdate = a.localUpdate, console.log("%cWorker " + this.workerType + " forced localUpdate value to " + a.localUpdate, "background: " + b + "; color: #000"))
};
skim.WorkerMeshBuilder.prototype.onError = function (a, b) {
	console.warn("%cWorker error: " + a, "background: " + b + "; color: #000")
};
skim.WorkerMeshBuilder.prototype.setMeshState = function (a) {
	this.meshState = a
};
skim.WorkerMeshBuilder.prototype.getMeshState = function () {
	return this.meshState
};
skim.WorkerMeshBuilder.prototype.getMesh = function () {
	return this.abmesh
};
skim.WorkerMeshBuilder.prototype.getMeshData = function () {
	return this.meshData
};
skim.WorkerMeshBuilder.prototype.invalidate = function () {
	this.setMeshState(skim.MeshState.OUTDATED)
};
skim.WorkerMeshBuilder.prototype.build = function (a) {
	a.isEmpty() ? (console.log("asked WorkerMeshBuilder to build on an empty primitive"), this.computeStatus.isDone = !0, this.computeStatus.percent = 100, new skim.geometry.AABBox, this.meshState = skim.MeshState.UPTODATE, this.abmesh = new skim.utils.ArrayBufferMesh(0), this.meshData = new skim.utils.MeshData(null, 0, 0), this.callback.onMesh && this.callback.onMesh.func.call(this.callback.onMesh.scope, this.abmesh, this.meshData, this.callback.onMesh.args), this.localUpdate ||
		this.free()) : this.meshState !== skim.MeshState.COMPUTING && (a instanceof skim.blobtree.Root ? (this.log("send mesh computation request for blobtree"), a = new skim.blobtree.Encoder(a), this.post({
				cmd : "compute",
				blobtree : {
					buffer : a.getBuffer(),
					imageDatas : a.getImageDatas(),
					sdfs : a.getSdfs()
				},
				pointAcc : skim.blobtree.pointCurrAccF,
				segAcc : skim.blobtree.segCurrAccF,
				ringAcc : skim.blobtree.ringCurrAccF,
				textAcc : skim.blobtree.textCurrAccF,
				textringAcc : skim.blobtree.textringCurrAccF
			})) : (a = a.getMessageData(), a.cmd = "compute",
			this.post(a)), this.meshState = skim.MeshState.COMPUTING)
};
skim.WorkerMeshBuilder.prototype.reset = function () {
	this.free();
	this.invalidate()
};
skim.WorkerMeshBuilder.prototype.free = function () {
	null !== this.worker && (this.log("Closing worker and subworkers nicely"), this.post({
			cmd : "close"
		}), this.worker = null, this.listening = !1)
};
skim.WorkerMeshBuilder.prototype.getStatus = function () {
	return {
		percent : this.computeStatus.percent,
		isDone : this.computeStatus.isDone
	}
};
skim.WorkerMeshBuilder.prototype.onMeshResult = function (a) {
	this.log("got mesh result from worker");
	var b = new skim.utils.MeshData(a.aabb, a.surface, a.volume),
	c = new skim.utils.ArrayBufferMesh(0);
	c.set(a.vertices, a.normals, a.faces, a.colors, a.roughness, a.metallic, a.n_vertices, a.n_faces);
	this.meshState = skim.MeshState.UPTODATE;
	this.abmesh = c;
	this.meshData = b;
	this.localUpdate || this.free();
	this.callback.onMesh && this.callback.onMesh.func.call(this.callback.onMesh.scope, c, b, this.callback.onMesh.args)
};
skim.WorkerMeshBuilder.prototype.onMeshDismiss = function (a) {
	this.log("received old surface (" + a.requestID + ") from worker. Current:" + this.currentRequestID + ". Dropping.")
};
skim.WorkerMeshBuilder.prototype.onProgress = function (a, b) {
	this.computeStatus.isDone = a;
	this.computeStatus.percent = b;
	this.callback.onProgress && this.callback.onProgress.func.call(this.callback.onProgress.scope, a, b)
};
skim.WorkerMeshBuilder.prototype.onCriticalError = function (a, b) {
	console.warn("%cWORKER CRITICAL ERROR: " + a, b);
	this.callback.onCriticalError && this.callback.onCriticalError.func.call(this.callback.onCriticalError.scope, a, this.callback.onCriticalError.args)
};
skim.WorkerMeshBuilder.prototype.listen = function () {
	var a = this,
	b = function (b) {
		b = b.data;
		var d = b.background ? b.background : "#ffff00";
		switch (b.cmd) {
		case "up":
			a.onUp.call(a, b, d);
			break;
		case "log":
			a.onLog.call(a, b.msg, d);
			break;
		case "error":
			a.onError.call(a, b.msg, d);
			break;
		case "mesh":
			if (b.requestID == a.currentRequestID)
				a.onMeshResult(b);
			else
				a.onMeshDismiss(b);
			break;
		case "closed":
			console.log("Worker has been terminated successfully"),
			a.worker = null,
			a.listening = !1;
		case "progress":
			a.onProgress.call(a, 0 === b.step,
				b.percent);
			break;
		case "critical_error":
			a.onCriticalError.call(a, b.msg, d);
			break;
		case "newWorker":
			break;
		case "passMessage":
			break;
		case "terminate":
			break;
		default:
			console.error('%cWORKER: unrecognized command "' + b.cmd + '" from worker', "background: #ffff00")
		}
	};
	this.listening || (this.log("init listening"), this.worker.addEventListener("message", b, !1), this.listening = !0)
};
skim.MeshManager = function (a) {
	this.def = {};
	this.mb = {};
	this.sceneMgr = a;
	this.parallel = !0
};
skim.MeshManager.prototype.setParallel = function (a) {
	if (this.parallel !== a) {
		this.parallel = a;
		a = Object.keys(this.def);
		for (var b = 0; b < a.length; ++b) {
			var c = this.def[a[b]];
			this.remove(c);
			this.add(c)
		}
	}
};
skim.MeshManager.prototype.invalidate = skim.utils.debounce(function (a) {
		if (a in this.def) {
			var b = this.def[a],
			c = b.getType() + "_mesh_" + b.id;
			this.sceneMgr.isRegisteredSurfaceMesh(c) && this.sceneMgr.removeSurface(c);
			this.mb[a].invalidate();
			this.mb[a].init();
			this.mb[a].build(b)
		}
	}, 100);
skim.MeshManager.prototype.resetMeshesComputation = function () {
	for (var a = Object.keys(this.def), b = 0; b < a.length; ++b)
		this.mb[a[b]].reset(), this.invalidate(parseInt(a[b], 10))
};
skim.MeshManager.prototype.getGlobalMeshProgress = function () {
	for (var a = 100, b = Object.keys(this.def), c = 0; c < b.length; ++c)
		a = Math.min(a, this.mb[b[c]].getStatus().percent);
	return a
};
skim.MeshManager.prototype.getGlobalMeshStatus = function () {
	for (var a = 100, b = !0, c = Object.keys(this.def), d = 0; d < c.length; ++d)
		var e = this.mb[c[d]], a = Math.min(a, e.getStatus().percent), b = b & e.getStatus().isDone;
	return {
		percent : a,
		isDone : b
	}
};
skim.MeshManager.prototype.getMergedMeshesData = function () {
	for (var a = new skim.utils.MeshData(null, 0, 0), b = Object.keys(this.def), c = 0; c < b.length; ++c) {
		var d = this.mb[b[c]];
		skim.utils.assert(d.getMeshState() === skim.MeshState.UPTODATE, "Error : getMergedMeshesData called while not all meshes are up to date");
		a = a.merge(d.getMeshData())
	}
	return a
};
skim.MeshManager.prototype.getABMeshArray = function () {
	for (var a = [], b = Object.keys(this.def), c = 0; c < b.length; ++c) {
		var d = this.mb[b[c]];
		skim.utils.assert(d.getMeshState() === skim.MeshState.UPTODATE, "Error : getABMeshArray called while not all meshes are up to date");
		a.push(d.getABMesh())
	}
	return a
};
skim.MeshManager.prototype.getSerializedABMeshArray = function () {
	for (var a = [], b = Object.keys(this.def), c = 0; c < b.length; ++c) {
		var d = this.mb[b[c]];
		skim.utils.assert(d.getMeshState() === skim.MeshState.UPTODATE, "Error : getABMeshArray called while not all meshes are up to date");
		a.push(d.getMesh().serialize())
	}
	return a
};
skim.MeshManager.prototype.add = function (a) {
	skim.utils.assert(void 0 === this.def[a.id], "Error : Primitive already added to the mesh manager");
	this.def[a.id] = a;
	var b = a.getType() + "_mesh_" + a.id;
	if (a instanceof skim.blobtree.Root)
		this.mb[a.id] = new skim.WorkerMeshBuilder("SlidingMC", this.parallel);
	else
		switch (a.getType()) {
		case skim.parametrics.typeHeightMapRing:
			this.mb[a.id] = new skim.WorkerMeshBuilder("HeightMap", !1);
			break;
		case skim.parametrics.typeMesh:
			this.mb[a.id] = new skim.WorkerMeshBuilder("Mesh", !1);
			break;
		default:
			skim.utils.assert(!1, "Error : unknown parametric primitive")
		}
	this.sceneMgr.isRegisteredSurfaceMesh(b) || this.sceneMgr.registerSurfaceMesh(b);
	this.mb[a.id].setCallback("onMesh", this, function (a, b, e) {
		a = a.convertToTHREEBufferGeometry();
		this.sceneMgr.addSurface({
			name : e,
			geometry : a
		})
	}, b);
	this.mb[a.id].setCallback("onCriticalError", this, function (a, b) {
		console.log("Critical error caught. Relaunching computation.");
		this.mb[b.id].init();
		this.mb[b.id].build(b)
	}, a);
	this.mb[a.id].init();
	this.mb[a.id].build(a)
};
skim.MeshManager.prototype.remove = function (a) {
	var b = this.def[a.id];
	skim.utils.assert(void 0 !== this.def[a.id], "Error : Trying to remove a primitive which is not managed by the MeshManager");
	delete this.def[a.id];
	this.mb[a.id].free();
	delete this.mb[a.id];
	a = b.getType() + "_mesh_" + b.id;
	this.sceneMgr.isRegisteredSurfaceMesh(a) && (this.sceneMgr.removeSurface(a), this.sceneMgr.unregisterSurfaceMesh(a))
};
skim.MeshManager.prototype.getBlobtrees = function () {
	for (var a = [], b = Object.keys(this.def), c = 0; c < b.length; ++c) {
		var d = this.def[b[c]];
		d instanceof skim.blobtree.Root && a.push(d)
	}
	return a
};
skim.MeshManager.prototype.clean = function () {
	this.resetMeshesComputation();
	for (var a = this.getBlobtrees(), b = 0; b < a.length; ++b)
		this.remove(a[b])
};
skim.MeshManager.prototype.dispose = function () {
	this.resetMeshesComputation();
	for (var a = Object.keys(this.def), b = 0; b < a.length; ++b)
		this.remove(this.def[a[b]])
};
skim.MeshManager.prototype.exportMesh = function (a, b, c, d, e, f) {
	var g = Object.keys(this.def),
	h = {
		exportMeshBuilders : [],
		nbMeshComputed : 0,
		nbMeshTotal : g.length,
		meshes : [],
		onDone : a,
		onProgress : b
	};
	console.log("Launch mesh computation for export...");
	a = function (a, b, g) {
		g.meshes.push(a);
		if (++g.nbMeshComputed == g.nbMeshTotal) {
			for (a = 0; a < h.exportMeshBuilders.length; ++a)
				h.exportMeshBuilders[a].free();
			var k = new Worker(skim.instances.ressourcesPath + "SkimWorkerExport.min.js");
			k.addEventListener("message", function (a) {
				a = a.data;
				switch (a.cmd) {
				case "obj_blob":
				case "compressed_obj_blob":
					k.terminate();
					console.log("OBJ conversion done, callback launched");
					g.onDone(a.blob);
					break;
				case "log":
					console.log(a.msg);
					break;
				case "error":
					console.error(a.msg);
					break;
				default:
					skim.utils.assert(!1, "Export worker message not recognized")
				}
			}, !1);
			console.log("Mesh computation for export done. Launch OBJ converter worker...");
			k.postMessage({
				cmd : "export_obj",
				arr_abm : g.meshes,
				get_normals : c,
				make_manifold : d,
				orientation_m : e,
				unit : f
			})
		}
	};
	for (var k = 0; k < g.length; k++) {
		var l =
			this.def[g[k]];
		h.exportMeshBuilders[k] = new skim.WorkerMeshBuilder(l instanceof skim.blobtree.Root ? "SlidingMC" : "HeightMap", !1);
		h.exportMeshBuilders[k].setCallback("onProgress", this, b, h);
		h.exportMeshBuilders[k].setCallback("onMesh", this, a, h);
		h.exportMeshBuilders[k].init();
		h.exportMeshBuilders[k].build(l)
	}
};
skim.parametrics.primitiveType = "paramPrimitive";
skim.parametrics.MeshState = {
	OUTDATED : 0,
	COMPUTING : 1,
	UPTODATE : 2
};
skim.parametrics.Primitive = function () {
	skim.Object3D.call(this);
	this.type = "primitive";
	this.abmesh = null;
	this.mesh_data = new skim.utils.MeshData(null, 0, 0);
	this.abmesh_state = skim.parametrics.MeshState.OUTDATED;
	this.mesh_progress = 0
};
skim.parametrics.Primitive.prototype = Object.create(skim.Object3D.prototype);
skim.parametrics.Primitive.prototype.constructor = skim.parametrics.Primitive;
skim.parametrics.Primitive.prototype.getType = function () {
	return this.type
};
skim.parametrics.Primitive.prototype.getABMeshState = function () {
	return this.abmesh_state
};
skim.parametrics.Primitive.prototype.getABMesh = function () {
	return this.abmesh
};
skim.parametrics.Primitive.prototype.getMeshData = function () {
	return this.abmesh_state === skim.parametrics.MeshState.COMPUTING ? (skim.utils.assert(!1, "Error : cannot get mesh data while computing..."), null) : this.mesh_data
};
skim.parametrics.Primitive.prototype.buildABMesh = function () {
	skim.utils.assert(!1, "Error : buildABMesh not implemented")
};
skim.parametrics.Primitive.prototype.resetMeshComputation = function () {
	this.abmesh_state = skim.parametrics.MeshState.OUTDATED;
	skim.utils.assert(!1, "Error : resetMeshComputation not implemented")
};
skim.parametrics.Primitive.prototype.getMeshProgress = function () {
	return this.mesh_progress
};
skim.parametrics.typeHeightMapRing = "heightmapring";
skim.parametrics.HeightMapRing = function (a, b, c, d, e, f, g, h, k, l, m) {
	skim.parametrics.Primitive.call(this);
	this.type = skim.parametrics.typeHeightMapRing;
	skim.utils.assert(3 <= c, "Error : angles to sharp, choose a rounding of 3 at least");
	this.print_wall = h;
	this.print_details = k;
	this.rlength = a;
	this.zlength = b;
	this.round = c;
	this.bump = d;
	this.uniform_zlength = g;
	skim.utils.assert(this.rlength >= 5 + f / 2, "Error : lambda cannot lead to a ring thickness - rlength - lower than 5 units");
	skim.utils.assert(0 <= f, "Error : lambda should be positive.");
	this.lambda = f;
	this.radius = e;
	this.mid_radius = this.radius + this.rlength / 2;
	this.ref_radius = this.mid_radius + 0.5 * this.rlength - 0.5 * this.lambda;
	this.v_per_pix = 2;
	this.inside_res = 1;
	this.round_res = 16;
	this.image = l;
	this.color_image_data = m;
	this.bump_var = {};
	this.bump_var.r = ((this.zlength / 2 - this.round) * (this.zlength / 2 - this.round) - this.bump * this.bump) / (2 * this.bump);
	this.bump_var.R = this.bump_var.r + this.bump + this.round;
	this.bump_var.c = new THREE.Vector3(0, this.mid_radius + this.rlength / 2 + this.bump - this.bump_var.R, 0);
	this.bump_var.theta =
		Math.atan((this.zlength / 2 - this.round) / this.bump_var.r);
	this.outside_length = 1 < this.bump ? 2 * this.bump_var.theta * this.bump_var.R : this.zlength - 2 * this.round;
	this.corners_length = (Math.PI / 2 - this.bump_var.theta) * this.round;
	this.outside_res = this.v_per_pix * Math.round((2 * this.corners_length + this.outside_length) / (this.print_details / 2));
	this.rad_res = this.v_per_pix * Math.round(2 * this.ref_radius * Math.PI / (this.print_details / 2));
	this.hmap = null;
	this.buildHmap();
	this.meshBuilder = null
};
skim.parametrics.HeightMapRing.prototype = Object.create(skim.parametrics.Primitive.prototype);
skim.parametrics.HeightMapRing.prototype.constructor = skim.parametrics.HeightMapRing;
skim.parametrics.HeightMapRing.prototype.isEmpty = function () {
	return !1
};
skim.parametrics.HeightMapRing.prototype.getRLength = function () {
	return this.rlength
};
skim.parametrics.HeightMapRing.prototype.getZLength = function () {
	return this.zlength
};
skim.parametrics.HeightMapRing.prototype.getRound = function () {
	return this.round
};
skim.parametrics.HeightMapRing.prototype.getBump = function () {
	return this.bump
};
skim.parametrics.HeightMapRing.prototype.getRadius = function () {
	return this.radius
};
skim.parametrics.HeightMapRing.prototype.getImage = function () {
	return this.image
};
skim.parametrics.HeightMapRing.prototype.getColorImageData = function () {
	return this.color_image_data
};
skim.parametrics.HeightMapRing.prototype.getHmapresolution = function () {
	return {
		width : this.rad_res / this.v_per_pix,
		height : this.outside_res / this.v_per_pix,
		corners : this.corners_length / (this.outside_length + 2 * this.corners_length) * this.outside_res / this.v_per_pix
	}
};
skim.parametrics.HeightMapRing.prototype.buildHmap = function () {
	skim.utils.assert(null !== this.image, "Error : image should have been set before");
	var a = this.getHmapresolution(),
	b = document.createElement("canvas");
	b.width = a.width;
	b.height = a.height;
	a = b.getContext("2d");
	a.drawImage(this.image, 0, 0, b.width, b.height);
	this.hmap = new skim.utils.PrintableHeightMap(b.width, b.height, this.print_details);
	this.hmap.buildFromImageData(a.getImageData(0, 0, b.width, b.height), this.lambda)
};
skim.parametrics.HeightMapRing.prototype.getMessageData = function () {
	return {
		inside_res : this.inside_res,
		round_res : this.round_res,
		outside_res : this.outside_res,
		outside_length : this.outside_length,
		corners_length : this.corners_length,
		rad_res : this.rad_res,
		radius : this.radius,
		mid_radius : this.mid_radius,
		rlength : this.rlength,
		zlength : this.zlength,
		round : this.round,
		bump : this.bump,
		lambda : this.lambda,
		uniform_zlength : this.uniform_zlength,
		bump_var : {
			r : this.bump_var.r,
			R : this.bump_var.R,
			c : {
				x : this.bump_var.c.x,
				y : this.bump_var.c.y,
				z : this.bump_var.c.z
			},
			theta : this.bump_var.theta
		},
		p_hmap : {
			width : this.hmap.width,
			height : this.hmap.height,
			pix_dist : this.hmap.pix_dist,
			data : this.hmap.data
		},
		color_data : null === this.color_image_data ? null : {
			width : this.color_image_data.width,
			height : this.color_image_data.height,
			data : this.color_image_data.data
		}
	}
};
skim.parametrics.typeMesh = "mesh";
skim.parametrics.Mesh = function (a) {
	skim.parametrics.Primitive.call(this);
	this.type = skim.parametrics.typeMesh;
	this.abmesh = a;
	this.meshBuilder = null
};
skim.parametrics.Mesh.prototype = Object.create(skim.parametrics.Primitive.prototype);
skim.parametrics.Mesh.prototype.constructor = skim.parametrics.Mesh;
skim.parametrics.Mesh.prototype.isEmpty = function () {
	return !1
};
skim.parametrics.Mesh.prototype.getMessageData = function () {
	return {
		vertices : this.abmesh.vertices,
		normals : this.abmesh.normals,
		faces : this.abmesh.faces,
		n_vertices : this.abmesh.n_vertices,
		n_faces : this.abmesh.n_faces
	}
};
skim.clone = function (a) {
	var b = {},
	c;
	for (c in a)
		a.hasOwnProperty(c) && (b[c] = a[c]);
	return b
};
skim.deepclone = function (a) {
	if (null === a || "object" != typeof a)
		return a;
	if (a instanceof Date) {
		var b = new Date;
		b.setTime(a.getTime());
		return b
	}
	if (a instanceof Array) {
		for (var b = [], c = 0, d = a.length; c < d; c++)
			b[c] = skim.deepclone(a[c]);
		return b
	}
	if (a instanceof Object) {
		b = {};
		for (c in a)
			a.hasOwnProperty(c) && (b[c] = skim.deepclone(a[c]));
		return b
	}
	throw Error("Unable to copy obj! Its type isn't supported.");
};
skim.utils.isEmptyObject = function (a) {
	if (null === a)
		return !0;
	if (a.length && 0 < a.length)
		return !1;
	if (0 === a.length)
		return !0;
	for (var b in a)
		if (Object.prototype.hasOwnProperty.call(a, b))
			return !1;
	return !0
};
skim.blobtree.EvalTags = {
	Value : 2,
	Grad : 4,
	Mat : 8,
	NextStep : 16,
	NextStepX : 32,
	NextStepY : 64,
	NextStepZ : 128,
	NextStepOrtho : 224,
	ValueGrad : 6,
	ValueMat : 10,
	GradMat : 12,
	ValueGradMat : 14
};
skim.blobtree.iso_value = 1;
skim.blobtree.neutral_value = 0;
skim.blobtree.setAccuracyLevel = function (a) {
	var b = 4;
	switch (a) {
	case 0:
		b = 1;
		break;
	case 1:
		b = 0.5;
		break;
	case 2:
		b = 0.25;
		break;
	case 3:
		b = 0.125;
		break;
	case 4:
		b = 0;
		break;
	default:
		skim.utils.assert(!1, "Error: invalid level of accuracy")
	}
	skim.blobtree.pointCurrAccF = skim.blobtree.pointNiceAccF + b * (skim.blobtree.pointRawAccF - skim.blobtree.pointNiceAccF);
	skim.blobtree.segCurrAccF = skim.blobtree.segNiceAccF + b * (skim.blobtree.segRawAccF - skim.blobtree.segNiceAccF);
	skim.blobtree.triCurrAccF = skim.blobtree.triNiceAccF + b * (skim.blobtree.triRawAccF -
			skim.blobtree.triNiceAccF);
	skim.blobtree.ringCurrAccF = skim.blobtree.ringNiceAccF + b * (skim.blobtree.ringRawAccF - skim.blobtree.ringNiceAccF);
	skim.blobtree.textCurrAccF = skim.blobtree.textNiceAccF + b * (1 - skim.blobtree.textNiceAccF);
	skim.blobtree.textringCurrAccF = skim.blobtree.textringNiceAccF + b * (1 - skim.blobtree.textringNiceAccF)
};
skim.Ray = function (a, b) {
	THREE.Ray.call(this, a, b)
};
skim.Ray.prototype = Object.create(THREE.Ray.prototype);
skim.Ray.prototype.normalizeDirection = function () {
	this.direction.normalize()
};
skim.Ray.prototype.getTriangleIntersection = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3,
	c = new THREE.Vector3,
	d = new THREE.Vector3,
	e = new THREE.Vector3,
	f = 0,
	g = 0,
	h = 0,
	k = 0,
	l = 0;
	return function (m, n, p, q) {
		q.hit = !1;
		a.subVectors(n, m);
		b.subVectors(p, m);
		c.crossVectors(this.direction, b);
		f = a.dot(c);
		if (-1E-6 < f && 1E-6 > f)
			return q;
		g = 1 / f;
		e.subVectors(this.origin, m);
		h = e.dot(c) * g;
		if (0 > h || 1 < h)
			return 0;
		d.crossVectors(e, a);
		k = this.direction.dot(d) * g;
		if (0 > k || 1 < h + k)
			return q;
		l = b.dot(d) * g;
		1E-6 < l && (q.t = l, q.hit = !0);
		return q
	}
}
();
skim.Ray.prototype.getSphereIntersections = function (a, b) {
	var c = this.direction.lengthSq(),
	d,
	e = -a.radius * a.radius,
	f;
	f = this.origin.x - a.center.x;
	d = 0 + this.direction.x * f;
	e += f * f;
	f = this.origin.y - a.center.y;
	d += this.direction.y * f;
	e += f * f;
	f = this.origin.z - a.center.z;
	d += this.direction.z * f;
	d *= 2;
	e = d * d - 4 * c * (e + f * f);
	if (0 > e)
		return 0;
	if (0 === e)
		return b.inter1 = -d / (2 * c), 1;
	e = Math.sqrt(e);
	b.inter1 = (-d - e) / (2 * c);
	b.inter2 = (-d + e) / (2 * c);
	return 2
};
skim.geometry.AABBox = function (a, b, c, d, e, f) {
	void 0 === a || null === a ? THREE.Box3.call(this) : THREE.Box3.call(this, new THREE.Vector3(a, b, c), new THREE.Vector3(d, e, f))
};
skim.geometry.AABBox.prototype = Object.create(THREE.Box3.prototype);
skim.geometry.AABBox.prototype.setEmpty = THREE.Box3.prototype.makeEmpty;
skim.geometry.AABBox.prototype.contains = THREE.Box3.prototype.containsPoint;
skim.geometry.AABBox.prototype.intersects = THREE.Box3.prototype.isIntersectionBox;
skim.geometry.AABBox.prototype.isEmpty = THREE.Box3.prototype.empty;
skim.geometry.AABBox.prototype.getCenter = THREE.Box3.prototype.center;
skim.geometry.AABBox.prototype.getDimensions = THREE.Box3.prototype.size;
skim.geometry.AABBox.prototype.clone = function () {
	return new skim.geometry.AABBox(this.min.x, this.min.y, this.min.z, this.max.x, this.max.y, this.max.z)
};
skim.geometry.AABBox.prototype.toString = function () {
	return "(" + this.min.x.toFixed(2) + ", " + this.min.y.toFixed(2) + ", " + this.min.z.toFixed(2) + ") -> (" + this.max.x.toFixed(2) + ", " + this.max.y.toFixed(2) + ", " + this.max.z.toFixed(2) + ") "
};
skim.geometry.AABBox.prototype.set = function (a, b, c, d, e, f) {
	this.min.set(a, b, c);
	this.max.set(d, e, f)
};
skim.geometry.AABBox.prototype.getCorners = function () {
	return [new THREE.Vector3(this.min.x, this.min.y, this.min.z), new THREE.Vector3(this.max.x, this.min.y, this.min.z), new THREE.Vector3(this.max.x, this.max.y, this.min.z), new THREE.Vector3(this.min.x, this.max.y, this.min.z), new THREE.Vector3(this.min.x, this.min.y, this.max.z), new THREE.Vector3(this.max.x, this.min.y, this.max.z), new THREE.Vector3(this.max.x, this.max.y, this.max.z), new THREE.Vector3(this.min.x, this.max.y, this.max.z)]
};
skim.geometry.AABBox.prototype.getMinCorner = function () {
	return this.min
};
skim.geometry.AABBox.prototype.sphereIntersect = function (a) {
	var b = 0,
	c = a.c,
	d = this.min,
	e = this.max;
	c.x < d.x ? b += Math.pow(c.x - d.x, 2) : c.x > e.x && (b += Math.pow(c.x - e.x, 2));
	c.y < d.y ? b += Math.pow(c.y - d.y, 2) : c.y > e.y && (b += Math.pow(c.y - e.y, 2));
	c.z < d.z ? b += Math.pow(c.z - d.z, 2) : c.z > e.z && (b += Math.pow(c.z - e.z, 2));
	return b <= Math.pow(a.r, 2)
};
skim.geometry.AABBox2Acc = function (a, b, c, d, e, f) {
	void 0 === a || null === a ? THREE.Box2.call(this) : THREE.Box2.call(this, new THREE.Vector2(a, b), new THREE.Vector2(c, d));
	void 0 === e || null === e ? (a = Math.max(this.max.x - this.min.x, this.max.y - this.min.y), this.nice_acc = 0 >= a ? 1E7 : a) : this.nice_acc = e;
	this.raw_acc = void 0 === f || null === f ? this.nice_acc : f
};
skim.geometry.AABBox2Acc.prototype = Object.create(THREE.Box2.prototype);
skim.geometry.AABBox2Acc.prototype.setEmpty = THREE.Box2.prototype.makeEmpty;
skim.geometry.AABBox2Acc.prototype.contains = THREE.Box2.prototype.containsPoint;
skim.geometry.AABBox2Acc.prototype.intersects = THREE.Box2.prototype.isIntersectionBox;
skim.geometry.AABBox2Acc.prototype.isEmpty = THREE.Box2.prototype.empty;
skim.geometry.AABBox2Acc.prototype.getCenter = THREE.Box2.prototype.center;
skim.geometry.AABBox2Acc.prototype.getDimensions = THREE.Box2.prototype.size;
skim.geometry.AABBox2Acc.prototype.union = function (a) {
	THREE.Box2.prototype.union.call(this, a);
	this.raw_acc = Math.min(a.raw_acc, this.raw_acc);
	this.nice_acc = Math.min(a.nice_acc, this.nice_acc)
};
skim.geometry.AABBox2Acc.prototype.getRawAcc = function () {
	return this.raw_acc
};
skim.geometry.AABBox2Acc.prototype.getNiceAcc = function () {
	return this.nice_acc
};
skim.geometry.AABBox2Acc.prototype.setRawAcc = function (a) {
	this.raw_acc = Math.max(0, a)
};
skim.geometry.AABBox2Acc.prototype.setNiceAcc = function (a) {
	this.nice_acc = Math.max(0, a)
};
skim.geometry.AABBox2Acc.prototype.toString = function () {
	return "(" + this.min.x.toFixed(2) + ", " + this.min.y.toFixed(2) + ") -> (" + this.max.x.toFixed(2) + ", " + this.max.y.toFixed(2) + ") "
};
skim.geometry.AABBox2Acc.prototype.set = function (a, b, c, d, e, f) {
	this.min.set(a, b);
	this.max.set(c, d);
	void 0 !== e && (this.nice_acc = e);
	void 0 !== f && (this.raw_acc = f)
};
skim.geometry.AABBox2Acc.prototype.getMinCorner = function () {
	return this.min
};
skim.blobtree.elementType = "element";
skim.blobtree.Element = function () {
	skim.Object3D.call(this);
	this.valid_aabb = !1;
	this.type = skim.blobtree.elementType;
	this.parentNode = null
};
skim.blobtree.Element.prototype = Object.create(skim.Object3D.prototype);
skim.blobtree.Element.prototype.constructor = skim.blobtree.Element;
skim.blobtree.Element.prototype.getParentNode = function () {
	return this.parentNode
};
skim.blobtree.Element.prototype.getType = function () {
	return this.type
};
skim.blobtree.Element.prototype.computeHelpVariables = function () {
	this.computeAABB()
};
skim.blobtree.Element.prototype.computeAABB = function () {
	skim.utils.assert(!1, "Error : computeAABB is abstract, should have been overwritten")
};
skim.blobtree.Element.prototype.getAABB = function () {
	return this.aabb
};
skim.blobtree.Element.prototype.prepareForEval = function () {
	skim.utils.assert(!1, "ERROR : prepareForEval is a virtual function, should be re-implemented in all element(error occured in Element.js");
	return {
		del_obj : [],
		new_areas : []
	}
};
skim.blobtree.Element.prototype.getAreas = function () {
	return []
};
skim.blobtree.Element.prototype.distanceTo = function (a) {
	skim.utils.assert(!1, "ERROR : distanceTo is a virtual function, should be re-implemented in all primitives(error occured in " + this.type + " primitive)");
	return 0.5
};
skim.blobtree.Element.prototype.heuristicStepWithin = function () {
	skim.utils.assert(!1, "ERROR : heuristicStepWithin is a virtual function, should be re-implemented in all primitives(error occured in " + this.type + " primitive)");
	return 0.1
};
skim.blobtree.Element.prototype.trim = function (a, b, c) {};
skim.blobtree.Element.prototype.count = function (a) {
	return 0
};
skim.blobtree.nodeType = "blobtreeNode";
skim.blobtree.Node = function () {
	skim.blobtree.Element.call(this);
	this.type = skim.blobtree.nodeType;
	this.children = [];
	this.deleted_obj = []
};
skim.blobtree.Node.prototype = Object.create(skim.blobtree.Element.prototype);
skim.blobtree.Node.prototype.constructor = skim.blobtree.Node;
skim.blobtree.Node.prototype.setVolType = function (a) {
	for (var b = 0; b < this.children.length; b++)
		this.children[b].setVolType(a)
};
skim.blobtree.Node.prototype.prepareForEval = function () {
	console.error("prepareForEval is a pure virtual function, should be reimplemented in every node class");
	return {
		del_obj : [],
		new_areas : []
	}
};
skim.blobtree.Node.prototype.invalidAABB = function () {
	this.valid_aabb = !1;
	null !== this.parentNode && this.parentNode.isValidAABB() && this.parentNode.invalidAABB()
};
skim.blobtree.Node.prototype.isValidAABB = function () {
	return this.valid_aabb
};
skim.blobtree.Node.prototype.invalidAll = function () {
	this.invalidAABB();
	if (this.children)
		for (var a = 0; a < this.children.length; a++)
			this.children[a].invalidAll()
};
skim.blobtree.Node.prototype.destroy = function () {
	for (var a = this.children.slice(0, this.children.length), b = 0; b < a.length; b++)
		a[b].destroy();
	skim.utils.assert(0 === this.children.length, "Error : children length should be 0");
	null !== this.parentNode && this.parentNode.removeChild(this);
	skim.utils.assert(null === this.parentNode, "Error : parent node should be null at this point");
	this.children.length = 0
};
skim.blobtree.Node.prototype.addChild = function (a) {
	null !== a.parentNode && a.parentNode.removeChild(a);
	this.children.push(a);
	a.parentNode = this;
	this.invalidAABB()
};
skim.blobtree.Node.prototype.removeChild = function (a) {
	for (var b = 0, c = this.children; c[b] !== a && b < c.length; )
		++b;
	b != c.length ? (c[b] = c[c.length - 1], c.pop()) : skim.utils.assert(!1, "c does not belong to the children of this node");
	this.deleted_obj.push(a);
	this.invalidAABB();
	a.parentNode = null
};
skim.blobtree.Node.prototype.computeAABB = function () {
	this.aabb.setEmpty();
	for (var a = 0; a < this.children.length; a++)
		this.children[a].computeAABB(), this.aabb.union(this.children[a].getAABB())
};
skim.blobtree.Node.prototype.getAreas = function () {
	skim.utils.assert(this.valid_aabb, "Error : cannot call getAreas on a not prepared for eval nod, please call PrepareForEval first.");
	for (var a = [], b = 0; b < this.children.length; b++)
		a.push.apply(a, this.children[b].getAreas());
	return a
};
skim.blobtree.Node.prototype.distanceTo = function (a) {
	for (var b = 1E7, c = 0; c < this.children.length; c++)
		b = Math.min(b, this.children[c].distanceTo(a));
	return b
};
skim.blobtree.Node.prototype.heuristicStepWithin = function () {
	for (var a = 1E7, b = 0; b < this.children.length; b++)
		a = Math.min(a, this.children[b].heuristicStepWithin());
	return a
};
skim.blobtree.Node.prototype.trim = function (a, b, c) {
	for (var d = b.length, e = 0; e < this.children.length; e++)
		this.children[e].getAABB().intersects(a) || (b.push(this.children[e]), c.push(this));
	for (e = d; e < b.length; ++e)
		this.removeChild(b[e]);
	for (e = 0; e < this.children.length; e++)
		this.children[e].trim(a, b, c)
};
skim.blobtree.Node.prototype.count = function (a) {
	var b = 0;
	this instanceof a && b++;
	for (var c = 0; c < this.children.length; c++)
		b += this.children[c].count(a);
	return b
};
skim.blobtree.ricciNodeType = "blobtreeRicciNode";
skim.blobtree.RicciNode = function (a) {
	skim.blobtree.Node.call(this);
	this.type = skim.blobtree.ricciNodeType;
	this.ricci_n = a;
	this.blend_changed = !1;
	this.tmp_res = {
		v : 0,
		g : new THREE.Vector3(0, 0, 0),
		m : new skim.Material(null, null, null)
	};
	this.tmp_v_arr = new Float32Array(0);
	this.tmp_m_arr = [];
	this.blobBoundingSphere = new THREE.Sphere
};
skim.blobtree.RicciNode.prototype = Object.create(skim.blobtree.Node.prototype);
skim.blobtree.RicciNode.prototype.constructor = skim.blobtree.RicciNode;
skim.blobtree.RicciNode.prototype.prepareForEval = function () {
	var a = {
		del_obj : [],
		new_areas : []
	};
	if (!this.valid_aabb) {
		this.aabb = new skim.geometry.AABBox;
		for (var b = this.children.length, c = null, d = 0; d < b; ++d) {
			var c = this.children[d],
			e = c.prepareForEval();
			this.aabb.union(c.getAABB());
			a.del_obj = a.del_obj.concat(e.del_obj);
			this.blend_changed ? a.new_areas = this.getAreas() : a.new_areas.push.apply(a.new_areas, e.new_areas)
		}
		a.del_obj.push.apply(a.del_obj, this.deleted_obj);
		this.deleted_obj = [];
		this.valid_aabb = !0;
		this.blend_changed =
			!1;
		if (this.tmp_v_arr.length < this.children.length)
			for (this.tmp_v_arr = new Float32Array(2 * this.children.length), this.tmp_m_arr.length = 2 * this.children.length, d = 0; d < this.tmp_m_arr.length; ++d)
				this.tmp_m_arr[d] = new skim.Material(null, 0, 0)
	}
	return a
};
skim.blobtree.RicciNode.prototype.compareAreas = function (a) {
	for (var b = [], c = {}, d = {}, e = 0; e < this.children.length; ++e)
		c[this.children[e].id] = this.children[e];
	for (e = 0; e < a.children.length; ++e)
		d[a.children[e].id] = a.children[e];
	a = Object.keys(c);
	for (e = 0; e < a.length; ++e)
		void 0 !== d[a[e]] ? (Array.prototype.push.apply(b, c[a[e]].compareAreas(d[a[e]])), delete d[a[e]], delete c[a[e]]) : b.push({
			other : null,
			that : c[a[e]].getAreas()
		});
	a = Object.keys(d);
	for (e = 0; e < a.length; ++e)
		skim.utils.assert(void 0 === c[a[e]], "Error : should have been processed in the loop above"),
		b.push({
			other : d[a[e]].getAreas(),
			that : null
		});
	return b
};
skim.blobtree.RicciNode.prototype.value = function (a, b, c) {
	var d = this.children.length,
	e = this.tmp_res;
	c.v = 0;
	b & skim.blobtree.EvalTags.Mat && c.m.copy(skim.instances.defaultMaterial);
	b & skim.blobtree.EvalTags.Grad ? c.g.set(0, 0, 0) : b & skim.blobtree.EvalTags.NextStep && (c.step = 1E9);
	if (this.aabb.contains(a) && 0 !== d) {
		for (var f = this.tmp_v_arr, g = this.tmp_m_arr, h = 0, k = 0, l = 0; l < d; ++l)
			if (this.children[l].aabb.contains(a))
				if (this.children[l].value(a, b, e), this.countEval++, 0 < e.v) {
					var m = Math.pow(e.v, this.ricci_n - 1),
					k = k + e.v * m;
					b & skim.blobtree.EvalTags.Grad && (e.g.multiplyScalar(m), c.g.add(e.g));
					b & skim.blobtree.EvalTags.Mat && (f[h] = e.v * m, g[h].copy(e.m), h++);
					b & (skim.blobtree.EvalTags.NextStep | skim.blobtree.EvalTags.NextStepOrtho) && (c.step = Math.min(c.step, this.children[l].heuristicStepWithin()))
				} else
					this.countEval0++, b & skim.blobtree.EvalTags.NextStep && (c.step = Math.min(c.step, this.children[l].distanceTo(a)));
			else if (b & skim.blobtree.EvalTags.NextStep)
				c.step = Math.min(c.step, this.children[l].distanceTo(a));
			else if (b & skim.blobtree.EvalTags.NextStepOrtho) {
				var n;
				b & skim.blobtree.EvalTags.NextStepZ ? n = this.children[l].aabb.min.z - a.z : b & skim.blobtree.EvalTags.NextStepY ? n = this.children[l].aabb.min.y - a.y : b & skim.blobtree.EvalTags.NextStepX && (n = this.children[l].aabb.min.x - a.x);
				0 < n && (c.step = Math.min(c.step, n))
			}
		c.v = Math.pow(k, 1 / this.ricci_n);
		0 !== c.v && (b & skim.blobtree.EvalTags.Grad && c.g.multiplyScalar(c.v / k), b & skim.blobtree.EvalTags.Mat && c.m.weightedMean(g, f, h))
	} else
		b & skim.blobtree.EvalTags.NextStep && (c.step = this.aabb.distanceToPoint(a) + 0.3)
};
skim.blobtree.RicciNode.prototype.setRicciN = function (a) {
	this.ricci_n != a && (this.ricci_n = a, this.invalidAABB(), this.blend_changed = !0)
};
skim.blobtree.RicciNode.prototype.setVolType = function (a) {
	for (var b = 0; b < this.children.length; b++)
		this.children[b].setVolType(a)
};
skim.blobtree.RicciNode.prototype.intersectRayBlob = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3,
	c = new THREE.Vector3,
	d = {
		g : new THREE.Vector3
	},
	e = {
		p : new THREE.Vector3,
		g : new THREE.Vector3,
		p_absc : 0
	},
	f = 0,
	g = 0,
	h = 0;
	return function (k, l, m, n) {
		a.copy(k.origin);
		b.copy(k.direction);
		b.normalize();
		h = 0;
		for (this.value(a, skim.blobtree.EvalTags.Value | skim.blobtree.EvalTags.NextStep, d); d.v < skim.blobtree.iso_value && h < m; )
			a.add(c.copy(b).multiplyScalar(d.step)), h += d.step, f = d.step, g = d.v, this.value(a, skim.blobtree.EvalTags.Value |
				skim.blobtree.EvalTags.NextStep, d);
		return d.v >= skim.blobtree.iso_value ? (skim.Convergence.safeNewton1D(this, a, b.multiplyScalar(-1), 0, f, f * (skim.blobtree.iso_value - d.v) / (g - d.v), skim.blobtree.iso_value, f / 512, 10, e), l.distance = h - e.absc, l.point = e.p.clone(), l.g && l.g.copy(e.g), !0) : !1
	}
}
();
skim.blobtree.RicciNode.prototype.intersectOrthoRayBlob = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3,
	c = {},
	d = {};
	d.g = new THREE.Vector3;
	var e = 0,
	f = 0,
	g = -1;
	return function (h, k, l, m) {
		m.axis & skim.blobtree.EvalTags.NextStepZ ? a.set(this.aabb.min.x + h, this.aabb.min.y + k, this.aabb.min.z + 1E-7) : m.axis & skim.blobtree.EvalTags.NextStepY ? a.set(this.aabb.min.x + h, this.aabb.min.y + 1E-7, this.aabb.min.z + k) : m.axis & skim.blobtree.EvalTags.NextStepX && a.set(this.aabb.min.x + 1E-7, this.aabb.min.y + h, this.aabb.min.z + k);
		c.step =
			m.get(this.aabb.max) - m.get(this.aabb.min);
		this.value(a, skim.blobtree.EvalTags.Value | m.axis, c);
		e = 1E-7;
		for (g = -1; m.get(a) < m.get(this.aabb.max); ) {
			for (; 0 <= (c.v - 1) * g && m.get(a) < m.get(this.aabb.max); )
				m.add(a, c.step), e = c.step, c.step = m.get(this.aabb.max) - m.get(a), this.value(a, skim.blobtree.EvalTags.Value | m.axis, c);
			if (m.get(a) < m.get(this.aabb.max)) {
				g *= -1;
				b.copy(a);
				f = m.get(a);
				e /= 2;
				for (m.add(a, -e); 0.1 < e; )
					f = m.get(a), e /= 2, this.value(a, skim.blobtree.EvalTags.Value, d), 0 > (d.v - 1) * g ? m.add(a, e) : m.add(a, -e);
				m.add(a, f);
				m.divide(a, 2);
				this.value(a, skim.blobtree.EvalTags.Grad, d);
				l.push({
					point : a.clone(),
					gradient : d.g.clone()
				});
				a.copy(b)
			}
		}
	}
}
();
skim.blobtree.rootNodeType = "blobtreeRootNode";
skim.blobtree.Root = function () {
	skim.blobtree.RicciNode.call(this, 64);
	this.type = skim.blobtree.rootNodeType;
	this.valid_aabb = !0;
	this.trimmed = [];
	this.trim_parents = []
};
skim.blobtree.Root.prototype = Object.create(skim.blobtree.RicciNode.prototype);
skim.blobtree.Root.prototype.constructor = skim.blobtree.Root;
skim.blobtree.Root.prototype.invalidAABB = function () {
	this.valid_aabb = !1
};
skim.blobtree.Root.prototype.internalTrim = function (a) {
	skim.utils.assert(0 === this.trimmed.length && 0 === this.trim_parents.length, "Error : you should not call internal trim if you have not untrimmed before. Call untrim or use externalTrim");
	this.trim(a, this.trimmed, this.trim_parents)
};
skim.blobtree.Root.prototype.externalTrim = function (a, b, c) {
	this.trim(a, b, c)
};
skim.blobtree.Root.prototype.internalUntrim = function () {
	this.untrim(this.trimmed, this.trim_parents);
	this.trimmed.length = 0;
	this.trim_parents.length = 0
};
skim.blobtree.Root.prototype.untrim = function (a, b) {
	skim.utils.assert(a.length === b.length, "Error : trimmed and parents arrays should have the same length");
	for (var c = 0; c < a.length; ++c)
		b[c].addChild(a[c])
};
skim.blobtree.Root.prototype.compareAreas = function (a) {
	skim.utils.assert(a instanceof skim.blobtree.Root && (2 === a.children.length && a.children[0]instanceof skim.blobtree.RicciNode && a.children[1]instanceof skim.blobtree.RicciNode || 0 === a.children.length) && (2 === this.children.length && this.children[0]instanceof skim.blobtree.RicciNode && this.children[1]instanceof skim.blobtree.RicciNode || 0 === this.children.length), "Error : compareAreas has note been implemented to handle any blobtrees. Please read the warning in the jsdoc");
	if (0 === a.children.length) {
		for (var b = [], c = 0; c < this.children.length; ++c)
			for (var d = this.children[c], e = 0; e < d.children.length; ++e)
				b.push({
					other : null,
					that : d.children[e].getAreas()
				});
		return b
	}
	if (0 === this.children.length) {
		b = [];
		for (c = 0; c < a.children.length; ++c)
			for (d = a.children[c], e = 0; e < d.children.length; ++e)
				b.push({
					other : d.children[e].getAreas(),
					that : null
				});
		return b
	}
	return this.children[0].compareAreas(a.children[0]).concat(this.children[1].compareAreas(a.children[1]))
};
skim.blobtree.Root.prototype.isEmpty = function () {
	return 0 == this.children.length
};
skim.blobtree.verticesIds = 0;
skim.blobtree.Vertex = function (a, b) {
	this.pos = a;
	this.thickness = b;
	this.id = skim.blobtree.verticesIds++;
	this.aabb = new skim.geometry.AABBox;
	this.valid_aabb = !1
};
skim.blobtree.Vertex.prototype.setPos = function (a) {
	this.valid_aabb = !1;
	this.pos = a
};
skim.blobtree.Vertex.prototype.setThickness = function (a) {
	this.valid_aabb = !1;
	this.thickness = a
};
skim.blobtree.Vertex.prototype.setAll = function (a, b) {
	this.valid_aabb = !1;
	this.pos = a;
	this.thickness = b
};
skim.blobtree.Vertex.prototype.getPos = function () {
	return this.pos
};
skim.blobtree.Vertex.prototype.getThickness = function () {
	return this.thickness
};
skim.blobtree.Vertex.prototype.getAABB = function () {
	this.valid_aabb || (this.computeAABB(), this.valid_aabb = !0);
	return this.aabb
};
skim.blobtree.Vertex.prototype.computeAABB = function () {
	var a = this.getPos(),
	b = this.getThickness() * skim.blobtree.KS;
	this.aabb.set(a.x - b, a.y - b, a.z - b, a.x + b, a.y + b, a.z + b)
};
skim.blobtree.Vertex.prototype.equals = function (a) {
	return this.pos.equals(a.pos) && this.thickness === a.thickness
};
skim.blobtree.KS = 2;
skim.blobtree.KS2 = 4;
skim.blobtree.KIS2 = 1 / (skim.blobtree.KS * skim.blobtree.KS);
skim.blobtree.Poly6Eval = function (a) {
	a = 1 - skim.blobtree.KIS2 * a * a;
	return 0 < a ? a * a * a : 0
};
skim.blobtree.Poly6EvalSq = function (a) {
	a = 1 - skim.blobtree.KIS2 * a;
	return 0 < a ? a * a * a : 0
};
skim.blobtree.GetIsoValueAtDistanceGeom0D = function (a, b, c) {
	skim.utils.assert(0 === a % 2, "degree should be even");
	return c < b ? Math.pow(1 - c * c / (b * b), a / 2) : 0
};
skim.blobtree.Poly4NF0D = 1 / skim.blobtree.GetIsoValueAtDistanceGeom0D(4, skim.blobtree.KS, 1);
skim.blobtree.Poly6NF0D = 1 / skim.blobtree.GetIsoValueAtDistanceGeom0D(6, skim.blobtree.KS, 1);
skim.blobtree.GetIsoValueAtDistanceGeom1D = function (a, b, c) {
	skim.utils.assert(0 === a % 2, "degree should be even");
	if (c < b) {
		c = 1 - c * c / (b * b);
		b = 2 * b * Math.sqrt(c);
		for (var d = 0; d != a; )
			d += 2, b *= d / (1 + d) * c;
		return b
	}
	return 0
};
skim.blobtree.Poly4NF1D = 1 / skim.blobtree.GetIsoValueAtDistanceGeom1D(4, skim.blobtree.KS, 1);
skim.blobtree.Poly6NF1D = 1 / skim.blobtree.GetIsoValueAtDistanceGeom1D(6, skim.blobtree.KS, 1);
skim.blobtree.GetIsoValueAtDistanceGeom2D = function (a, b, c) {
	return c < b ? (a += 2, 2 * Math.PI / a * b * b * Math.pow(1 - c * c / (b * b), 0.5 * a)) : 0
};
skim.blobtree.Poly4NF2D = 1 / skim.blobtree.GetIsoValueAtDistanceGeom2D(4, skim.blobtree.KS, 1);
skim.blobtree.Poly6NF2D = 1 / skim.blobtree.GetIsoValueAtDistanceGeom2D(6, skim.blobtree.KS, 1);
skim.blobtree.defaultVolType = skim.VolType.Orga;
skim.blobtree.primitiveType = "primitive";
skim.blobtree.Primitive = function () {
	skim.blobtree.Element.call(this);
	this.type = skim.blobtree.primitiveType;
	this.volType = skim.VolType.Mech;
	this.v = [];
	this.materials = []
};
skim.blobtree.Primitive.prototype = Object.create(skim.blobtree.Element.prototype);
skim.blobtree.Primitive.prototype.constructor = skim.blobtree.Primitive;
skim.blobtree.Primitive.prototype.mutableVolType = function () {
	return !1
};
skim.blobtree.Primitive.prototype.setVolType = function (a) {
	a !== this.volType && (this.volType = a, this.invalidAABB())
};
skim.blobtree.Primitive.prototype.getVolType = function () {
	return this.volType
};
skim.blobtree.Primitive.prototype.setMaterials = function (a) {
	skim.utils.assert(a.length === this.materials.length, "Error : trying to set " + a.length + " materials on a primitive with only " + this.materials.length);
	for (var b = 0; b < a.length; ++b)
		a[b].equals(this.materials[b]) || (this.materials[b].copy(a[b]), this.invalidAABB())
};
skim.blobtree.Primitive.prototype.getMaterials = function () {
	return this.materials
};
skim.blobtree.Primitive.prototype.setIsWorker = function (a) {
	this.isWorker = a;
	this.invalidAABB()
};
skim.blobtree.Primitive.prototype.setVPos = function (a, b) {
	skim.utils.assert(a < this.v.length, "Vertex index invalid");
	this.v[a].setPos(b);
	this.invalidAABB()
};
skim.blobtree.Primitive.prototype.setVThickness = function (a, b) {
	skim.utils.assert(a < this.v.length, "Vertex index invalid");
	this.v[a].setThickness(b);
	this.invalidAABB()
};
skim.blobtree.Primitive.prototype.setVAll = function (a, b, c) {
	skim.utils.assert(a < this.v.length, "Vertex index invalid");
	this.v[a].setAll(b, c);
	this.invalidAABB()
};
skim.blobtree.Primitive.prototype.getVPos = function (a, b) {
	return this.v[a].getPos()
};
skim.blobtree.Primitive.prototype.getVThickness = function (a) {
	return this.v[a].getThickness()
};
skim.blobtree.Primitive.prototype.invalidAll = function () {
	this.invalidAABB()
};
skim.blobtree.Primitive.prototype.invalidAABB = function () {
	this.valid_aabb = !1;
	null !== this.parentNode && this.parentNode.invalidAABB()
};
skim.blobtree.Primitive.prototype.isValidAABB = function () {
	return this.valid_aabb
};
skim.blobtree.Primitive.prototype.computeAABB = function () {
	this.aabb.setEmpty();
	for (var a = 0; a < this.v.length; a++)
		this.aabb.union(this.v[a].getAABB())
};
skim.blobtree.Primitive.prototype.destroy = function () {
	null !== this.parentNode && this.parentNode.removeChild(this)
};
skim.blobtree.Primitive.prototype.value = function (a, b, c) {
	skim.utils.assert(!1, "ERROR : value is a virtual function, should be re-implemented in all primitives(error occured in " + this.type + " primitive)");
	return 0
};
skim.blobtree.Primitive.prototype.getAreas = function () {
	skim.utils.assert(!1, "ERROR : getAreas is a virtual function, should be re-implemented in all primitives(error occured in " + this.type + " primitive)");
	return []
};
skim.blobtree.Primitive.prototype.computeHelpVariables = function () {
	skim.utils.assert(!1, "ERROR : computeHelpVariables is a virtual function, should be re-implemented in all primitives(error occured in " + this.type + " primitive)")
};
skim.blobtree.Primitive.prototype.prepareForEval = function () {
	skim.utils.assert(!1, "ERROR : prepareForEval is a virtual function, should be re-implemented in all primitives(error occured in " + this.type + " primitive)");
	return {
		del_obj : [],
		new_areas : []
	}
};
skim.blobtree.Primitive.prototype.compareAreas = function (a) {
	skim.utils.assert(!1, "ERROR : compareAreas is a virtual function, should be re-implemented in all primitives(error occured in " + this.type + " primitive)");
	return []
};
skim.blobtree.Primitive.prototype.count = function (a) {
	return this instanceof a ? 1 : 0
};
skim.blobtree.typePoint = "point";
skim.blobtree.pointNiceAccF = 0.3;
skim.blobtree.pointRawAccF = 1;
skim.blobtree.pointCurrAccF = 0.3;
skim.blobtree.Point = function (a, b, c, d) {
	skim.blobtree.Primitive.call(this);
	this.v.push(a);
	this.volType = skim.VolType.Mech;
	this.density = c;
	this.materials.push(d);
	this.type = skim.blobtree.typePoint;
	this.v_to_p = new THREE.Vector3
};
skim.blobtree.Point.prototype = Object.create(skim.blobtree.Primitive.prototype);
skim.blobtree.Point.prototype.constructor = skim.blobtree.Point;
skim.blobtree.Point.prototype.setDensity = function (a) {
	this.density = a;
	this.invalidAABB()
};
skim.blobtree.Point.prototype.getDensity = function () {
	return this.density
};
skim.blobtree.Point.prototype.setMaterial = function (a) {
	this.materials[0].copy(a);
	this.invalidAABB()
};
skim.blobtree.Point.prototype.computeHelpVariables = function () {
	this.computeAABB()
};
skim.blobtree.Point.prototype.prepareForEval = function () {
	var a = {
		del_obj : [],
		new_areas : []
	};
	this.valid_aabb || (this.computeHelpVariables(), this.valid_aabb = !0, a.new_areas = this.getAreas());
	return a
};
skim.blobtree.Point.prototype.compareAreas = function (a) {
	skim.utils.assert(this.valid_aabb, "Error : cannot compare if objects are not prepared for eval, please call prepareForEval before");
	skim.utils.assert(a.type === this.type, "Error : compareAreas called on different primitive type");
	return this.volType === a.volType && skim.Material.areEqualsArrays(this.materials, a.materials) && this.v[0].equals(a.v[0]) ? [] : [{
			that : this.getAreas(),
			other : a.getAreas()
		}
	]
};
skim.blobtree.Point.prototype.getAreas = function () {
	if (this.valid_aabb)
		return [{
				aabb : this.aabb,
				bv : new skim.blobtree.AreaPoint(this.v[0].getPos(), this.v[0].getThickness()),
				obj : this
			}
		];
	console.log("ERROR : Cannot get area of invalid primitive");
	return []
};
skim.blobtree.Point.prototype.heuristicStepWithin = function () {
	return this.v[0].getThickness() / 3
};
skim.blobtree.Point.prototype.value = function (a, b, c) {
	skim.utils.assert(this.valid_aabb, "Error : PrepareForEval should have been called");
	var d = this.v[0].getThickness();
	this.v_to_p.subVectors(a, this.v[0].getPos());
	a = this.v_to_p.lengthSq() / (d * d);
	a = 1 - skim.blobtree.KIS2 * a;
	0 < a ? (c.v = this.density * a * a * a * skim.blobtree.Poly6NF0D, b & skim.blobtree.EvalTags.Grad && (d = 6 * (-this.density * d * skim.blobtree.KIS2) * a * a * skim.blobtree.Poly6NF0D / (d * d * d), c.g.set(d * this.v_to_p.x, d * this.v_to_p.y, d * this.v_to_p.z)), b & skim.blobtree.EvalTags.Mat &&
		c.m.copy(this.materials[0])) : (c.v = 0, b & skim.blobtree.EvalTags.Grad && c.g.set(0, 0, 0), b & skim.blobtree.EvalTags.Mat && c.m.copy(skim.instances.defaultMaterial))
};
skim.blobtree.Point.prototype.distanceTo = function (a) {
	return a.distanceTo(this.v[0].getPos())
};
skim.geometry.Sphere = function (a, b) {
	void 0 === a ? (this.c = new THREE.Vector3(0, 0, 0), this.r2 = this.r = 1) : (this.c = a, this.r = b, this.r2 = b * b)
};
skim.geometry.Sphere.prototype.contains = function (a) {
	return (a.x - this.c.x) * (a.x - this.c.x) + (a.y - this.c.y) * (a.y - this.c.y) + (a.z - this.c.z) * (a.z - this.c.z) <= this.r2
};
skim.geometry.Sphere.prototype.isEmpty = function () {
	return 0 >= this.r
};
skim.blobtree.typeSegment = "segment";
skim.blobtree.segNiceAccF = 0.3;
skim.blobtree.segRawAccF = 1;
skim.blobtree.segCurrAccF = 0.3;
skim.blobtree.Segment = function (a, b, c, d, e) {
	skim.blobtree.Primitive.call(this);
	this.v.length = 2;
	this.v[0] = a;
	this.v[1] = b;
	this.volType = c;
	this.density = d;
	this.materials = e;
	this.type = skim.blobtree.typeSegment;
	this.clipped_l1 = 1;
	this.clipped_l2 = 0;
	this.vector = new THREE.Vector3;
	this.cycle = new THREE.Vector3;
	this.proj = new THREE.Vector3;
	this.ev_eps = {
		v : 0
	};
	this.p_eps = new THREE.Vector3;
	this.v0_p = this.v[0].getPos();
	this.v1_p = this.v[1].getPos();
	this.dir = new THREE.Vector3;
	this.length = this.lengthSq = 0;
	this.unit_dir = new THREE.Vector3;
	this.c1 = this.c0 = this.weight_p1 = 0;
	this.increase_unit_dir = new THREE.Vector3;
	this.p_min = new THREE.Vector3;
	this.cyl_bd1 = this.cyl_bd0 = this.maxboundSq = this.maxbound = this.unit_delta_weight = this.inv_weight_min = this.weight_min = 0;
	this.f0f1f2 = new THREE.Vector3;
	this.tmpVec1 = new THREE.Vector3;
	this.tmpVec2 = new THREE.Vector3;
	this.computeHelpVariables()
};
skim.blobtree.Segment.prototype = Object.create(skim.blobtree.Primitive.prototype);
skim.blobtree.Segment.constructor = skim.blobtree.Segment;
skim.blobtree.Segment.prototype.mutableVolType = function () {
	return !0
};
skim.blobtree.Segment.prototype.setDensity = function (a) {
	this.density = a;
	this.invalidAABB()
};
skim.blobtree.Segment.prototype.getDensity = function () {
	return this.density
};
skim.blobtree.Segment.prototype.setVolType = function (a) {
	skim.utils.assert(a == skim.VolType.Orga || a == skim.VolType.Mech, "ERROR : volType must be set to skim.VolType.Orga or skim.VolType.Mech");
	this.volType != a && (this.volType = a, this.invalidAABB())
};
skim.blobtree.Segment.prototype.getVolType = function () {
	return this.volType
};
skim.blobtree.Segment.prototype.prepareForEval = function () {
	var a = {
		del_obj : [],
		new_areas : []
	};
	this.valid_aabb || (this.computeHelpVariables(), this.valid_aabb = !0, a.new_areas = this.getAreas());
	return a
};
skim.blobtree.Segment.prototype.compareAreas = function (a) {
	skim.utils.assert(this.valid_aabb, "Error : cannot compare if objects are not prepared for eval, please call prepareForEval before");
	skim.utils.assert(a.type === this.type, "Error : compareAreas called on different primitive type");
	return this.volType === a.volType && skim.Material.areEqualsArrays(this.materials, a.materials) && this.v[0].equals(a.v[0]) && this.v[1].equals(a.v[1]) ? [] : [{
			that : this.getAreas(),
			other : a.getAreas()
		}
	]
};
skim.blobtree.Segment.prototype.getAreas = function () {
	if (this.valid_aabb)
		return [{
				aabb : this.aabb,
				bv : new skim.blobtree.AreaSeg(this.v[0].getPos(), this.v[1].getPos(), this.v[0].getThickness(), this.v[1].getThickness(), this.length, this.unit_dir),
				obj : this
			}
		];
	console.log("ERROR : Cannot get area of invalid primitive");
	return []
};
skim.blobtree.Segment.prototype.computeHelpVariables = function () {
	this.v0_p = this.v[0].getPos();
	this.v1_p = this.v[1].getPos();
	this.dir.subVectors(this.v1_p, this.v0_p);
	this.lengthSq = this.dir.lengthSq();
	this.length = Math.sqrt(this.lengthSq);
	this.unit_dir.copy(this.dir).normalize();
	this.weight_p1 = this.v[1].getThickness();
	this.c0 = this.v[0].getThickness();
	this.c1 = this.v[1].getThickness() - this.v[0].getThickness();
	var a = this.v[0].getThickness() * skim.blobtree.KS,
	b = this.v[1].getThickness() * skim.blobtree.KS;
	this.maxbound =
		Math.max(a, b);
	this.maxboundSq = this.maxbound * this.maxbound;
	this.cyl_bd0 = Math.min(-a, this.length - b);
	this.cyl_bd1 = Math.max(this.length + b, a);
	this.increase_unit_dir.copy(this.unit_dir);
	0 > this.c1 ? (this.p_min.copy(this.v1_p), this.weight_min = this.weight_p1, this.inv_weight_min = 1 / this.weight_p1, this.increase_unit_dir.negate(), this.unit_delta_weight = -this.c1 / this.length) : (this.p_min.copy(this.v0_p), this.weight_min = this.c0, this.inv_weight_min = 1 / this.c0, this.unit_delta_weight = this.c1 / this.length);
	this.computeAABB()
};
skim.blobtree.Segment.prototype.value = function (a, b, c) {
	switch (this.volType) {
	case skim.VolType.Mech:
		this.evalMech(a, b, c);
		break;
	case skim.VolType.Orga:
		this.evalOrga(a, b, c);
		break;
	default:
		console.log("Unknown volType, use Orga")
	}
};
skim.blobtree.Segment.prototype.evalMech = function (a, b, c) {
	var d = this.vector;
	d.subVectors(a, this.v[0].getPos());
	var e = d.dot(this.dir),
	f = d.lengthSq(),
	g = this.lengthSq * this.c0 + e * this.c1,
	d = 0 > this.c1 ? 0 : 1;
	0 < g && (d = e * this.c0 + f * this.c1, d = 0 > d ? 0 : d > g ? 1 : d / g);
	e = Math.sqrt(d * (d * this.lengthSq - 2 * e) + f);
	c.v = this.density * skim.blobtree.Poly6Eval(e / (this.c0 + d * this.c1)) * skim.blobtree.Poly6NF0D;
	b & skim.blobtree.EvalTags.Mat && this.evalMat(a, c);
	b & skim.blobtree.EvalTags.Grad && (b = this.density / 1E-5, this.p_eps.copy(a), this.p_eps.x +=
		1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.x = b * (this.ev_eps.v - c.v), this.p_eps.x -= 1E-5, this.p_eps.y += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.y = b * (this.ev_eps.v - c.v), this.p_eps.y -= 1E-5, this.p_eps.z += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.z = b * (this.ev_eps.v - c.v))
};
skim.blobtree.Segment.prototype.evalMat = function (a, b) {
	var c = this.vector;
	c.subVectors(a, this.v[0].getPos());
	c = this.unit_dir.dot(c) / this.length;
	1 < c ? b.m.copy(this.materials[1]) : 0 >= c ? b.m.copy(this.materials[0]) : (b.m.copy(this.materials[0]), b.m.lerp(this.materials[1], c))
};
skim.blobtree.Segment.prototype.HomotheticClippingSpecial = function (a) {
	var b = -a.z,
	c = -a.y;
	a = -a.x;
	var d = c * c - b * a;
	return 0 <= d && (d = c + Math.sqrt(d), !(0 > d || this.length * d < a)) ? (d = a / d, this.clipped_l1 = 0 > d ? 0 : d, d *= b, this.clipped_l2 = 2 * c < d + b * this.length ? a / d : this.length, !0) : !1
};
skim.blobtree.Segment.prototype.heuristicStepWithin = function () {
	return this.weight_min / 3
};
skim.blobtree.Segment.prototype.evalOrga = function (a, b, c) {
	skim.utils.assert(this.valid_aabb, "Error : prepareForEval should have been called");
	b & skim.blobtree.EvalTags.Grad && c.g.set(0, 0, 0);
	c.v = 0;
	var d = this.tmpVec1;
	d.subVectors(a, this.p_min);
	var e = this.increase_unit_dir.dot(d),
	f = d.lengthSq(),
	g = this.tmpVec2;
	g.set(this.weight_min * this.weight_min - skim.blobtree.KIS2 * f, -this.unit_delta_weight * this.weight_min - skim.blobtree.KIS2 * e, this.unit_delta_weight * this.unit_delta_weight - skim.blobtree.KIS2);
	if (this.HomotheticClippingSpecial(g)) {
		var h =
			1 / (this.weight_min + this.clipped_l1 * this.unit_delta_weight);
		g.x = 1 - skim.blobtree.KIS2 * (this.clipped_l1 * (this.clipped_l1 - 2 * e) + f) * h * h;
		g.y = -this.unit_delta_weight - skim.blobtree.KIS2 * (e - this.clipped_l1) * h;
		b & skim.blobtree.EvalTags.Grad ? (0.06 <= this.unit_delta_weight ? this.HomotheticCompactPolynomial_segment_FGradF_i6((this.clipped_l2 - this.clipped_l1) * h, this.unit_delta_weight, g) : this.HomotheticCompactPolynomial_approx_segment_FGradF_i6((this.clipped_l2 - this.clipped_l1) * h, this.unit_delta_weight, this.inv_weight_min,
				g), c.v = skim.blobtree.Poly6NF1D * this.f0f1f2.x, this.f0f1f2.y *= h, c.g.copy(this.increase_unit_dir).multiplyScalar(this.f0f1f2.z + this.clipped_l1 * this.f0f1f2.y).sub(d.multiplyScalar(this.f0f1f2.y)).multiplyScalar(6 * skim.blobtree.Poly6NF1D * skim.blobtree.KIS2 * h)) : c.v = 0.06 <= this.unit_delta_weight ? skim.blobtree.Poly6NF1D * this.HomotheticCompactPolynomial_segment_F_i6((this.clipped_l2 - this.clipped_l1) * h, this.unit_delta_weight, g) : skim.blobtree.Poly6NF1D * this.HomotheticCompactPolynomial_approx_segment_F_i6((this.clipped_l2 -
					this.clipped_l1) * h, this.unit_delta_weight, h, g);
		b & skim.blobtree.EvalTags.Mat && this.evalMat(a, c)
	}
};
skim.blobtree.Segment.prototype.clamp = function (a, b, c) {
	return Math.max(b, Math.min(c, a))
};
skim.blobtree.Segment.prototype.distanceTo = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3;
	return function (c) {
		var d = a.subVectors(c, this.v[0].getPos()).dot(this.dir) / this.lengthSq,
		d = this.clamp(d, 0, 1);
		b.copy(this.dir).multiplyScalar(d).add(this.v[0].getPos());
		return c.distanceTo(b)
	}
}
();
skim.blobtree.Segment.prototype.HomotheticCompactPolynomial_segment_F_i6 = function (a, b, c) {
	var d = b * a + 1,
	e = 1 / d,
	f = d * d,
	g = 1 / (f * f),
	h = c.y,
	k = h * h,
	l = 12 * k;
	b = 1 / b;
	var m = h * b,
	n = d * f,
	p = a * a,
	q = p * p,
	r = a * p,
	t = a * q,
	s = c.x;
	c = c.z;
	var u = s * s,
	w = c * c,
	y = 1 / (n * n),
	B = e * g,
	n = 1 / n,
	f = 1 / f,
	d = Math.log(d);
	return -w * ((((( - (e - 1) * b - a * f) * b - p * n) * b - r * g) * b - q * B) * b - t * y) * m + (-s * (y - 1) * b / 6 - ( - (B - 1) * b / 5 - a * y) * m) * u + ((s * l + 3 * c * u) * (0.4 * ( - (g - 1) * b / 4 - a * B) * b - p * y) + (3 * w * s + c * l) * (0.8 * (0.75 * (2 / 3 * ( - (f - 1) * b / 2 - a * n) * b - p * g) * b - r * B) * b - q * y) + c * w * (1.2 * (1.25 * (4 / 3 * (1.5 * (2 * (d * b - a * e) * b - p *
							f) * b - r * n) * b - q * g) * b - t * B) * b - r * r * y) + (-12 * c * s - 8 * k) * (0.6 * (( - (n - 1) * b / 3 - a * g) * b / 2 - p * B) * b - r * y) * h) * b / 6
};
skim.blobtree.Segment.prototype.HomotheticCompactPolynomial_approx_segment_F_i6 = function (a, b, c, d) {
	var e = c * b,
	f = e + 1,
	g = 1 / f,
	f = f * f,
	f = g / (f * f) / f,
	h = d.z,
	k = d.y;
	d = d.x;
	var l = a * a,
	m = h * l - 2 * k * a + d,
	n = h * d - k * k,
	p = h * a - k,
	q = d * d,
	r = k * q,
	t = m * m,
	s = p * t,
	h = 1 / h,
	u = n * h,
	n = 6 / 35 * (4 / 3 * (2 * n * a + p * m + k * d) * u + s + r) * u + m * s / 7 + d * r / 7,
	m = h * n,
	g = g * f,
	t = t * t,
	q = k * m + t / 8 - q * q / 8;
	a = -a * t + (-10 * k * q + d * n) * h;
	return m - 7 * b * q * h + (-0.1111111111 * (3 * f - 3 + 7 * (2 + g) * e) * a - 0.1 * (2 - 2 * f - 7 * (1 + g) * e) / c * (-1 * l * t + (1.333333333 * k * a + 2 * d * q) * h)) * h / (c * c)
};
skim.blobtree.Segment.prototype.HomotheticCompactPolynomial_segment_FGradF_i6 = function (a, b, c) {
	var d = b * a + 1,
	e = 1 / d,
	f = d * d,
	g = 1 / (f * f),
	h = c.y,
	k = h * h,
	l = 2 * k,
	m = c.z;
	c = c.x;
	var n = m * c / 3 + 2 / 3 * k,
	p = m * m,
	q = p / 6,
	r = -2 / 3 * m,
	t = d * f,
	s = 1 / t,
	u = e * g,
	t = 1 / (t * t),
	w = a * a;
	b = 1 / b;
	var y = a * w,
	B = 0.6 * (( - (s - 1) * b / 3 - a * g) * b / 2 - w * u) * b - y * t,
	A = B * h,
	v =  - (u - 1) * b / 5 - a * t,
	D = c * c,
	E = D * v,
	C = 0.4 * ( - (g - 1) * b / 4 - a * u) * b - w * t,
	F = c * C,
	z = -D * (t - 1) / 6,
	x = w * w,
	H = a * x,
	f = 1 / f,
	G = 0.8 * (0.75 * (2 / 3 * ( - (f - 1) * b / 2 - a * s) * b - w * g) * b - y * u) * b - x * t,
	I = (((( - (e - 1) * b - a * f) * b - w * s) * b - y * g) * b - x * u) * b - H * t,
	J = y * y,
	d = Math.log(d);
	this.f0f1f2.x = (c * z - h * E + F * l - 4 / 3 * k * A + (D * C / 2 + G * l - 2 * c * A) * m + (c * G / 2 - h * I + (-J * t / 6 + (-H * u / 5 + (-x * g / 4 + (-y * s / 3 + (-w * f / 2 + (d * b - a * e) * b) * b) * b) * b) * b) * m) * p) * b;
	this.f0f1f2.y = (z + C * n + G * q + (-2 / 3 * c * v + B * r) * h) * b;
	this.f0f1f2.z = (E / 6 + B * n + I * q + (-2 / 3 * F + G * r) * h) * b
};
skim.blobtree.Segment.prototype.HomotheticCompactPolynomial_approx_segment_FGradF_i6 = function (a, b, c, d) {
	var e = c * b,
	f = e + 1,
	g = 1 / f,
	h = 1 / (c * c),
	f = f * f,
	k = g / (f * f) / f,
	f = d.x,
	l = 2 * f,
	m = d.z,
	n = 1 / m,
	p = b * n;
	d = d.y;
	var q = a * a,
	r = m * q - 2 * d * a + f,
	t = r * r,
	s = r * t,
	u = f * f,
	w = f * u,
	y = m * f - d * d,
	B = m * a - d,
	A = y * n,
	v = 4 / 3 * (2 * y * a + B * r + d * f) * A + B * t + d * u,
	r = v / 5,
	y = d * n * r + s / 6 - w / 6,
	m = -a * s + (-8 * d * y + f * r) * n,
	D = q * s,
	E = -D + (10 / 7 * d * m + y * l) * n,
	C = -E / 8,
	s = 6 / 35 * v * A + B * s / 7 + d * w / 7,
	w = g * k,
	g = (3 * k - 3 + 7 * (2 + w) * e) * h;
	c = (2 - 2 * k - 7 * (1 + w) * e) / c * h;
	e = n * g;
	h = n * c;
	k = n * s;
	t *= t;
	u = d * k + t / 8 - u * u / 8;
	s = -a * t + (-10 * d * u +
			f * s) * n;
	this.f0f1f2.x = k - 7 * u * p - s * e / 9 - (-q * t + (4 / 3 * d * s + u * l) * n) * h / 10;
	this.f0f1f2.y = (r - 7 * b * y - m * g / 7 + c * C) * n;
	this.f0f1f2.z = y * n + m * p + e * C - (-a * D + (1.5 * d * E - 3 / 7 * f * m) * n) * h / 9
};
skim.blobtree.typeRing = "ring";
skim.blobtree.ringNiceAccF = 0.5;
skim.blobtree.ringRawAccF = 1;
skim.blobtree.ringCurrAccF = 0.5;
skim.blobtree.Ring = function (a, b, c) {
	skim.blobtree.Primitive.call(this);
	this.volType = b;
	this.materials = c;
	this.type = skim.blobtree.typeRing;
	this.v = a;
	this.rMin = skim.geometry.Max;
	this.rMax = -skim.geometry.Max;
	this.zMax = -skim.geometry.Max;
	this.zMin = skim.geometry.Max;
	this.lMax = -skim.geometry.Max;
	this.thickMin = skim.geometry.Max;
	this.thickMax = -skim.geometry.Max;
	this.theta = [];
	this.rz = [];
	this.arcStep = 0;
	this.constraintsIndices = [];
	this.vector = new THREE.Vector3;
	this.proj = new THREE.Vector3;
	this.ev_eps = {
		v : 0
	};
	this.p_eps =
		new THREE.Vector3;
	this.valid_aabb = !1;
	this.interpolantFunctions = {
		radial : [],
		height : [],
		thickness : []
	}
};
skim.blobtree.Ring.prototype = Object.create(skim.blobtree.Primitive.prototype);
skim.blobtree.Ring.prototype.constructor = skim.blobtree.Ring;
skim.blobtree.Ring.prototype.prepareForEval = function () {
	var a = {
		del_obj : [],
		new_areas : []
	};
	this.valid_aabb || (this.computeHelpVariables(), this.valid_aabb = !0, a.new_areas = this.getAreas());
	return a
};
skim.blobtree.Ring.prototype.compareAreas = function (a) {
	skim.utils.assert(this.valid_aabb, "Error : cannot compare if objects are not prepared for eval, please call prepareForEval before");
	skim.utils.assert(a.type === this.type, "Error : compareAreas called on different primitive type");
	for (var b = this.v.length === a.v.length, c = 0; c < this.v.length && b; ++c)
		b = b && this.v[c].equals(a.v[c]);
	return this.volType === a.volType && skim.Material.areEqualsArrays(this.materials, a.materials) && b ? [] : [{
			that : this.getAreas(),
			other : a.getAreas()
		}
	]
};
skim.blobtree.Ring.prototype.getAreas = function () {
	if (this.valid_aabb)
		return [{
				aabb : this.aabb,
				bv : new skim.blobtree.AreaRing(this.v, this.rz, this.theta, this.constraintsIndices, this.arcStep, this.interpolantFunctions, {
					rMin : this.rMin,
					rMax : this.rMax,
					zMax : this.zMax,
					zMin : this.zMin,
					thickMin : this.thickMin,
					thickMax : this.thickMax,
					lMax : this.lMax
				}),
				obj : this
			}
		];
	console.log("ERROR : Cannot get area of invalid primitive");
	return []
};
skim.blobtree.Ring.prototype.computeHelpVariables = function () {
	skim.ringUtils.computeConstraints(this);
	this.computeAABB()
};
skim.blobtree.Ring.prototype.computeAABB = function () {
	var a = this.thickMax * skim.blobtree.KS;
	this.aabb.set(-this.rMax - a, -this.rMax - a, this.zMin - a, this.rMax + a, this.rMax + a, this.zMax + a)
};
skim.blobtree.Ring.prototype.mutableVolType = function () {
	return !1
};
skim.blobtree.Ring.prototype.setTheta = function (a) {
	this.theta = a
};
skim.blobtree.Ring.prototype.setV = function (a) {
	this.v = a
};
skim.blobtree.Ring.prototype.setRZ = function (a) {
	this.rz = a
};
skim.blobtree.Ring.prototype.setarcStep = function (a) {
	this.arcStep = a
};
skim.blobtree.Ring.prototype.setconstraintsIndices = function (a) {
	this.constraintsIndices = a
};
skim.blobtree.Ring.prototype.setMins = function (a) {
	this.rMin = a[0];
	this.zMin = a[1];
	this.thickMin = a[2]
};
skim.blobtree.Ring.prototype.setMaxs = function (a) {
	this.rMax = a[0];
	this.zMax = a[1];
	this.thickMax = a[2];
	this.lMax = a[3]
};
skim.blobtree.Ring.prototype.updateConstraints = function (a) {
	skim.utils.assert(4 <= a.length && 4 * Math.floor(a.length / 4) == a.length, "Vertex array in ring constructor must be more than 4 in length");
	var b = this.v.length;
	this.v.length += a.length;
	for (var c = 0; c < a.length; ++c)
		this.v[c + b] = a[c], this.v[c + b].addOwner(this);
	this.computeHelpVariables()
};
skim.blobtree.Ring.prototype.distanceTo = function (a) {
	return 1
};
skim.blobtree.Ring.prototype.heuristicStepWithin = function () {
	return this.thickMin / 5
};
skim.blobtree.Ring.prototype.value = function (a, b, c) {
	switch (this.volType) {
	case skim.VolType.Mech:
		return this.evalMech(a, b, c);
	case skim.VolType.Orga:
		return this.evalMech(a, b, c);
	default:
		console.log("Unknown volType, use Orga")
	}
};
skim.blobtree.Ring.prototype.evalMech = function (a, b, c) {
	skim.ringUtils.evalMechForRing(this, a, b, c)
};
skim.blobtree.typeText = "text";
skim.blobtree.textNiceAccF = 0.3;
skim.blobtree.textCurrAccF = 0.7;
skim.blobtree.textRawOnTopAccF = 0.7;
skim.blobtree.Text = function (a, b, c, d) {
	skim.blobtree.Primitive.call(this);
	this.volType = c;
	this.materials = d;
	this.type = skim.blobtree.typeText;
	this.v = a;
	this.sdfManager = new skim.textUtils.FlatSdfManager(this.v, b);
	this.thickness = 10;
	this.mapping = null;
	this.ev_eps = {
		v : 0
	};
	this.p_eps = new THREE.Vector3;
	this.valid_aabb = !1;
	this.isLight = !0
};
skim.blobtree.Text.prototype = Object.create(skim.blobtree.Primitive.prototype);
skim.blobtree.Text.prototype.constructor = skim.blobtree.Text;
skim.blobtree.Text.prototype.prepareForEval = function () {
	var a = {
		del_obj : [],
		new_areas : []
	};
	this.valid_aabb || (this.computeHelpVariables(), this.isLight || this.sdfManager.generateSdf(), this.valid_aabb = !0, a.new_areas = this.getAreas());
	return a
};
skim.blobtree.Text.prototype.compareAreas = function (a) {
	skim.utils.assert(this.valid_aabb, "Error : cannot compare if objects are not prepared for eval, please call prepareForEval before");
	skim.utils.assert(a.type === this.type, "Error : compareAreas called on different primitive type");
	for (var b = this.v.length === a.v.length, c = 0; c < this.v.length && b; ++c)
		b = b && this.v[c].equals(a.v[c]);
	return this.volType === a.volType && skim.Material.areEqualsArrays(this.materials, a.materials) && b && skim.textUtils.compareImageDatas(this.sdfManager.getImageData(),
		a.sdfManager.getImageData()) ? [] : [{
			that : this.getAreas(),
			other : a.getAreas()
		}
	]
};
skim.blobtree.Text.prototype.getAreas = function () {
	if (this.valid_aabb)
		return [{
				aabb : this.aabb,
				bv : new skim.blobtree.AreaText(this.v, this.sdfManager, this.aabb),
				obj : this
			}
		];
	console.log("ERROR : Cannot get area of invalid primitive");
	return []
};
skim.blobtree.Text.prototype.setIsLight = function (a) {
	this.isLight = a;
	this.invalidAABB()
};
skim.blobtree.Text.prototype.getVolType = function () {
	return this.volType
};
skim.blobtree.Text.prototype.mutableVolType = function () {
	return !1
};
skim.blobtree.Text.prototype.computeHelpVariables = function () {
	this.thickness = this.v[0].getThickness();
	this.thicknessInvSq = 1 / (this.thickness * this.thickness);
	this.computeAABB()
};
skim.blobtree.Text.prototype.distanceTo = function (a) {
	return 1
};
skim.blobtree.Text.prototype.heuristicStepWithin = function () {
	return 0.5
};
skim.blobtree.Text.prototype.value = function (a, b, c) {
	switch (this.volType) {
	case skim.VolType.Mech:
		return this.evalMech(a, b, c);
	case skim.VolType.Orga:
		return this.evalMech(a, b, c);
	default:
		console.log("Unknown volType, use Orga")
	}
};
skim.blobtree.Text.prototype.evalMech = function (a, b, c) {
	this.isLight ? c.v = 0 : this.evalMechForText(a, b, c)
};
skim.blobtree.Text.prototype.evalMechForText = function (a, b, c) {
	var d = skim.textUtils.getDistSq(this.sdfManager, a);
	null === d ? c.v = 0 : (c.v = skim.blobtree.Poly6EvalSq(d * this.thicknessInvSq) * skim.blobtree.Poly6NF0D, b & skim.blobtree.EvalTags.Mat && c.m.copy(this.materials[0]), b & skim.blobtree.EvalTags.Grad && (this.p_eps.copy(a), this.p_eps.x += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.x = (this.ev_eps.v - c.v) / 1E-5, this.p_eps.x -= 1E-5, this.p_eps.y += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value,
					this.ev_eps), c.g.y = (this.ev_eps.v - c.v) / 1E-5, this.p_eps.y -= 1E-5, this.p_eps.z += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.z = (this.ev_eps.v - c.v) / 1E-5))
};
skim.blobtree.typeTriangle = "triangle";
skim.blobtree.triNiceAccF = 0.3;
skim.blobtree.triRawAccF = 1;
skim.blobtree.triCurrAccF = 0.3;
skim.blobtree.sampleNumber = 10;
skim.blobtree.Triangle = function (a, b, c) {
	skim.blobtree.Primitive.call(this);
	this.volType = b;
	this.materials = null !== c ? c : [skim.instances.defaultMaterial.clone(), skim.instances.defaultMaterial.clone(), skim.instances.defaultMaterial.clone()];
	this.type = skim.blobtree.typeTriangle;
	this.v = a;
	this.min_thick = Math.min(this.v[0].getThickness(), this.v[1].getThickness(), this.v[2].getThickness());
	this.max_thick = Math.max(this.v[0].getThickness(), this.v[1].getThickness(), this.v[2].getThickness());
	this.res_gseg = {};
	this.tmp_res_gseg = {};
	this.ev_eps = {
		v : 0
	};
	this.p_eps = new THREE.Vector3;
	this.p0p1 = new THREE.Vector3;
	this.p1p2 = new THREE.Vector3;
	this.p2p0 = new THREE.Vector3;
	this.unit_normal = new THREE.Vector3;
	this.unit_p0p1 = new THREE.Vector3;
	this.unit_p1p2 = new THREE.Vector3;
	this.unit_p2p0 = new THREE.Vector3;
	this.diffThick_p0p1 = this.diffThick_p0p1 = this.diffThick_p0p1 = this.length_p2p0 = this.length_p1p2 = this.length_p0p1 = 0;
	this.main_dir = new THREE.Vector3;
	this.point_iso_zero = new THREE.Vector3;
	this.ortho_dir = new THREE.Vector3;
	this.unsigned_ortho_dir =
		new THREE.Vector3;
	this.proj_dir = new THREE.Vector3;
	this.equal_weights = !1;
	this.max_seg_length = this.longest_dir_special = this.unit_delta_weight = this.coord_middle = this.coord_max = 0;
	this.half_dir_1 = new THREE.Vector3;
	this.point_half = new THREE.Vector3;
	this.half_dir_2 = new THREE.Vector3;
	this.point_min = new THREE.Vector3;
	this.weight_min = 0;
	this.valid_aabb = !1
};
skim.blobtree.Triangle.prototype = Object.create(skim.blobtree.Primitive.prototype);
skim.blobtree.Triangle.prototype.constructor = skim.blobtree.Triangle;
skim.blobtree.Triangle.prototype.prepareForEval = function () {
	var a = {
		del_obj : [],
		new_areas : []
	};
	this.valid_aabb || (this.computeHelpVariables(), this.valid_aabb = !0, a.new_areas = this.getAreas());
	return a
};
skim.blobtree.Triangle.prototype.compareAreas = function (a) {
	skim.utils.assert(this.valid_aabb, "Error : cannot compare if objects are not prepared for eval, please call prepareForEval before");
	skim.utils.assert(a.type === this.type, "Error : compareAreas called on different primitive type");
	return this.volType === a.volType && skim.Material.areEqualsArrays(this.materials, a.materials) && this.v[0].equals(a.v[0]) && this.v[1].equals(a.v[1]) && this.v[2].equals(a.v[2]) ? [] : [{
			that : this.getAreas(),
			other : a.getAreas()
		}
	]
};
skim.blobtree.Triangle.prototype.getAreas = function () {
	if (this.valid_aabb) {
		var a = [];
		a.push({
			norm : this.length_p0p1,
			diffThick : this.diffThick_p0p1,
			dir : this.unit_p0p1,
			v : [this.v[0], this.v[1]],
			ortho_vec_x : this.v[0].getThickness() - this.v[1].getThickness(),
			ortho_vec_y : this.length_p0p1
		});
		a.push({
			norm : this.length_p1p2,
			diffThick : this.diffThick_p1p2,
			dir : this.unit_p1p2,
			v : [this.v[1], this.v[2]],
			ortho_vec_x : this.v[1].getThickness() - this.v[2].getThickness(),
			ortho_vec_y : this.length_p1p2
		});
		a.push({
			norm : this.length_p2p0,
			diffThick : this.diffThick_p2p0,
			dir : this.unit_p2p0,
			v : [this.v[2], this.v[0]],
			ortho_vec_x : this.v[2].getThickness() - this.v[0].getThickness(),
			ortho_vec_y : this.length_p2p0
		});
		return [{
				aabb : this.aabb,
				bv : new skim.blobtree.AreaTri(this.v, this.unit_normal, this.main_dir, a, this.min_thick, this.max_thick),
				obj : this
			}
		]
	}
	console.log("ERROR : Cannot get area of invalid primitive");
	return []
};
skim.blobtree.Triangle.prototype.computeHelpVariables = function () {
	skim.triangleUtils.computeVectorsDirs(this);
	this.computeAABB()
};
skim.blobtree.Triangle.prototype.mutableVolType = function () {
	return !0
};
skim.blobtree.Triangle.prototype.setVolType = function (a) {
	skim.utils.assert(a == skim.VolType.Orga || a == skim.VolType.Mech, "ERROR : volType must be set to skim.VolType.Orga or skim.VolType.Mech");
	this.volType != a && (this.volType = a, this.invalidAABB())
};
skim.blobtree.Triangle.prototype.getVolType = function () {
	return this.volType
};
skim.blobtree.Triangle.prototype.clamp = function (a, b, c) {
	return Math.max(b, Math.min(c, a))
};
skim.blobtree.Triangle.prototype.distanceTo = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3,
	c = new THREE.Vector3,
	d = new THREE.Vector3;
	return function (e) {
		a.subVectors(e, this.v[0].getPos());
		b.subVectors(e, this.v[1].getPos());
		c.subVectors(e, this.v[2].getPos());
		if (0 < d.crossVectors(this.p0p1, a).dot(this.unit_normal) && 0 < d.crossVectors(this.p1p2, b).dot(this.unit_normal) && 0 < d.crossVectors(this.p2p0, c).dot(this.unit_normal))
			return Math.abs(a.dot(this.unit_normal));
		var f = a.dot(this.p0p1) / this.length_p0p1,
		f = this.clamp(f, 0, 1);
		d.copy(this.p0p1).multiplyScalar(f).add(this.v[0].getPos());
		var f = e.distanceToSquared(d),
		g = b.dot(this.p1p2) / this.length_p1p2,
		g = this.clamp(g, 0, 1);
		d.copy(this.p1p2).multiplyScalar(g).add(this.v[1].getPos());
		var g = e.distanceToSquared(d),
		h = c.dot(this.p2p0) / this.length_p2p0,
		h = this.clamp(h, 0, 1);
		d.copy(this.p2p0).multiplyScalar(h).add(this.v[2].getPos());
		h = e.distanceToSquared(d);
		return Math.sqrt(Math.min(Math.min(f, g), h))
	}
}
();
skim.blobtree.Triangle.prototype.heuristicStepWithin = function () {
	return this.weight_min / 3
};
skim.blobtree.Triangle.prototype.value = function (a, b, c) {
	switch (this.volType) {
	case skim.VolType.Mech:
		return this.evalMech(a, b, c);
	case skim.VolType.Orga:
		return this.evalOrga(a, b, c);
	default:
		console.log("Unknown volType, use Orga")
	}
};
skim.blobtree.Triangle.prototype.evalMech = function (a, b, c) {
	var d = new THREE.Vector3;
	d.subVectors(a, this.v[0].getPos());
	var e = this.unit_normal.clone().multiplyScalar(-1);
	if (!this.equal_weights) {
		var f = e,
		g = this.unsigned_ortho_dir,
		h = this.main_dir.clone().multiplyScalar(-1),
		k = -this.v[0].getPos().dot(f),
		l = -a.dot(g),
		m = -this.point_iso_zero.dot(h),
		n = new THREE.Vector3;
		n.crossVectors(g, h);
		n.multiplyScalar(-k);
		k = new THREE.Vector3;
		k.crossVectors(h, f);
		k.multiplyScalar(-l);
		l = new THREE.Vector3;
		l.crossVectors(f, g);
		l.multiplyScalar(-m);
		m = new THREE.Vector3;
		m.crossVectors(g, h);
		g = new THREE.Vector3(n.x + k.x + l.x, n.y + k.y + l.y, n.z + k.z + l.z);
		g.divideScalar(f.dot(m));
		f = new THREE.Vector3(g.x - a.x, g.y - a.y, g.z - a.z);
		this.proj_dir = new THREE.Vector3;
		this.proj_dir.crossVectors(f, this.unsigned_ortho_dir);
		this.proj_dir.normalize()
	}
	f = new THREE.Vector3;
	f.copy(this.proj_dir);
	f.multiplyScalar(-d.dot(e) / this.proj_dir.dot(e));
	f.add(a);
	d = new THREE.Vector3;
	n = new THREE.Vector3;
	g = new THREE.Vector3;
	h = new THREE.Vector3;
	n.subVectors(f, this.v[0].getPos());
	g.subVectors(f, this.v[1].getPos());
	h.subVectors(f, this.v[2].getPos());
	if (0 < d.crossVectors(this.unit_p0p1, n).dot(e) && 0 < d.crossVectors(this.unit_p1p2, g).dot(e) && 0 < d.crossVectors(this.unit_p2p0, h).dot(e))
		d.subVectors(a, f), c.v = d.lengthSq(), m = this.v[0].getPos(), k = this.v[1].getPos(), l = this.v[2].getPos(), f = new THREE.Vector3, d.subVectors(k, m), f.subVectors(l, m), e = new THREE.Vector3, e.crossVectors(d, f), d.subVectors(l, k), f = new THREE.Vector3, f.crossVectors(d, g), d.subVectors(m, l), g = new THREE.Vector3, g.crossVectors(d,
			h), d.subVectors(k, m), h = new THREE.Vector3, h.crossVectors(d, n), d = e.lengthSq(), f = e.dot(f), g = e.dot(g), e = e.dot(h), h = (f * this.v[0].getThickness() + g * this.v[1].getThickness() + e * this.v[2].getThickness()) / d, c.v = skim.blobtree.Poly6Eval(Math.sqrt(c.v) / h) * skim.blobtree.Poly6NF0D, b & skim.blobtree.EvalTags.Mat && c.m.triMean(this.materials[0], this.materials[1], this.materials[2], f, g, e, d);
	else if (f = 0, this.GenericSegmentComputation(a, this.v[0].getPos(), this.p0p1, this.length_p0p1, this.length_p0p1 * this.length_p0p1, this.v[0].getThickness(),
			this.v[1].getThickness() - this.v[0].getThickness(), this.res_gseg), this.res_gseg.sqrdist = this.res_gseg.proj_to_p.lengthSq(), this.res_gseg.ratio = this.res_gseg.sqrdist / (this.res_gseg.weight_proj * this.res_gseg.weight_proj), this.GenericSegmentComputation(a, this.v[1].getPos(), this.p1p2, this.length_p1p2, this.length_p1p2 * this.length_p1p2, this.v[1].getThickness(), this.v[2].getThickness() - this.v[1].getThickness(), this.tmp_res_gseg), this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq(), this.tmp_res_gseg.ratio =
			this.tmp_res_gseg.sqrdist / (this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj), this.res_gseg.ratio > this.tmp_res_gseg.ratio && (this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist, this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p, this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj, this.res_gseg.ratio = this.tmp_res_gseg.ratio, this.res_gseg.t = this.tmp_res_gseg.t, f = 1), this.GenericSegmentComputation(a, this.v[2].getPos(), this.p2p0, this.length_p2p0, this.length_p2p0 * this.length_p2p0, this.v[2].getThickness(),
			this.v[0].getThickness() - this.v[2].getThickness(), this.tmp_res_gseg), this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq(), this.tmp_res_gseg.ratio = this.tmp_res_gseg.sqrdist / (this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj), this.res_gseg.ratio > this.tmp_res_gseg.ratio && (this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist, this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p, this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj, this.res_gseg.ratio = this.tmp_res_gseg.ratio, this.res_gseg.t =
				this.tmp_res_gseg.t, f = 2), c.v = skim.blobtree.Poly6Eval(Math.sqrt(this.res_gseg.sqrdist) / this.res_gseg.weight_proj) * skim.blobtree.Poly6NF0D, b & skim.blobtree.EvalTags.Mat)
		switch (f) {
		case 0:
			c.m.copy(this.materials[0]);
			c.m.lerp(this.materials[1], this.res_gseg.t);
			break;
		case 1:
			c.m.copy(this.materials[1]);
			c.m.lerp(this.materials[2], this.res_gseg.t);
			break;
		case 2:
			c.m.copy(this.materials[2]);
			c.m.lerp(this.materials[0], this.res_gseg.t);
			break;
		default:
			skim.utils.assert(!1, "Error : seg_case unknown")
		}
	b & skim.blobtree.EvalTags.Grad &&
	(this.p_eps.copy(a), this.p_eps.x += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.x = (this.ev_eps.v - c.v) / 1E-5, this.p_eps.x -= 1E-5, this.p_eps.y += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.y = (this.ev_eps.v - c.v) / 1E-5, this.p_eps.y -= 1E-5, this.p_eps.z += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.z = (this.ev_eps.v - c.v) / 1E-5)
};
skim.blobtree.Triangle.prototype.GenericSegmentComputation = function (a, b, c, d, e, f, g, h) {
	d = new THREE.Vector3;
	d.subVectors(a, b);
	a = d.dot(c);
	b = d.lengthSq();
	e = e * f + a * g;
	var k = 0 > g ? 0 : 1;
	0 < e && (k = (a * f + b * g) / e, k = 0 > k ? 0 : 1 < k ? 1 : k);
	h.proj_to_p = new THREE.Vector3(k * c.x - d.x, k * c.y - d.y, k * c.z - d.z);
	h.weight_proj = f + k * g;
	h.t = k;
	return h
};
skim.blobtree.Triangle.prototype.evalOrga = function () {
	var a = {
		v : 0,
		m : new skim.Material(null, null, null)
	};
	return function (b, c, d) {
		var e = {
			l1 : 0,
			l2 : 0
		};
		if (this.ComputeTParam(b, e)) {
			for (var f = e.l1, g = e.l2, h = this.weight_min + f * this.unit_delta_weight, k = this.warpAbscissa((g - f) / h), l = 2 * (0.5 * skim.blobtree.sampleNumber * k + 1), m = k / l, n = m, m = 2 * m, p = 0, e = new THREE.Vector3, q = 1, r = null; q < l; q += 2)
				r = this.computeLineIntegral(this.unwarpAbscissa(n) * h + f, b, c), p += r.v, c & skim.blobtree.EvalTags.Grad && e.addVectors(e, r.g), n += m;
			for (var t = 0, s =
					new THREE.Vector3, n = 0, q = 2; q < l; q += 2)
				n += m, r = this.computeLineIntegral(this.unwarpAbscissa(n) * h + f, b, c), c & skim.blobtree.EvalTags.Grad && s.addVectors(s, r.g), t += r.v;
			f = this.computeLineIntegral(f, b, c);
			g = this.computeLineIntegral(g, b, c);
			d.v = f.v + 4 * p + 2 * t + f.v;
			k = k / (3 * l) * skim.blobtree.Poly6NF2D;
			d.v *= k;
			c & skim.blobtree.EvalTags.Grad && (l = new THREE.Vector3, l.addVectors(l, f.g), l.addVectors(l, e.multiplyScalar(4)), l.addVectors(l, s.multiplyScalar(2)), l.addVectors(l, g.g), d.g = l.multiplyScalar(k))
		} else
			d.v = 0, d.g = new THREE.Vector3;
		c & skim.blobtree.EvalTags.Mat && (this.evalMech(b, skim.blobtree.EvalTags.Mat, a), d.m.copy(a.m))
	}
}
();
skim.blobtree.Triangle.prototype.warpAbscissa = function (a) {
	var b = a * this.unit_delta_weight,
	c = 1 / (b + 2),
	b = b * c,
	b = b * b;
	return 2 * a * c * (1 + b * (1 / 3 + b * (0.2 + b * (1 / 7 + b * (1 / 9 + b * (1 / 11 + b * (1 / 13)))))))
};
skim.blobtree.Triangle.prototype.unwarpAbscissa = function (a) {
	var b = a * this.unit_delta_weight;
	return a * (1 + b * (0.5 + b * (1 / 6 + b * (1 / 24 + b * (1 / 120 + 1 * b / 720)))))
};
skim.blobtree.Triangle.prototype.computeLineIntegral = function (a, b, c) {
	var d = this.weight_min + a * this.unit_delta_weight,
	e = new THREE.Vector3;
	e.addVectors(this.point_min, this.longest_dir_special.clone().multiplyScalar(a));
	a = a < this.coord_middle ? a / this.coord_middle * this.max_seg_length : (this.coord_max - a) / (this.coord_max - this.coord_middle) * this.max_seg_length;
	return c & skim.blobtree.EvalTags.Grad ? this.consWeightEvalGradForSeg(e, d, this.ortho_dir, a, b) : this.consWeightEvalForSeg(e, d, this.ortho_dir, a, b)
};
skim.blobtree.Triangle.prototype.homotheticClippingSpecial = function (a, b, c) {
	var d = -a.z,
	e = -a.y;
	a = -a.x;
	var f = e * e - d * a;
	return 0 <= f && (f = e + Math.sqrt(f), !(0 > f || b * f < a)) ? (f = a / f, c.l1 = 0 > f ? 0 : f, f *= d, c.l2 = 2 * e < f + d * b ? a / f : b, !0) : !1
};
skim.blobtree.Triangle.prototype.consWeightEvalForSeg = function (a, b, c, d, e) {
	var f = {
		v : 0
	},
	g = new THREE.Vector3;
	g.subVectors(e, a);
	a = c.dot(g);
	g = g.lengthSq();
	c = new THREE.Vector3;
	c.set(b * b - skim.blobtree.KIS2 * g, -skim.blobtree.KIS2 * a, -skim.blobtree.KIS2);
	e = {
		l1 : 0,
		l2 : 0
	};
	this.homotheticClippingSpecial(c, d, e) && (b = 1 / b, c.x = 1 - skim.blobtree.KIS2 * (e.l1 * (e.l1 - 2 * a) + g) * b * b, c.y = -skim.blobtree.KIS2 * (a - e.l1) * b, f.v = this.homotheticCompactPolynomial_segment_F_i6_cste((e.l2 - e.l1) * b, c));
	return f
};
skim.blobtree.Triangle.prototype.consWeightEvalGradForSeg = function (a, b, c, d, e) {
	var f = {
		v : 0,
		g : new THREE.Vector3
	},
	g = new THREE.Vector3;
	g.subVectors(e, a);
	var h = c.dot(g),
	k = g.lengthSq();
	e = new THREE.Vector3;
	e.set(b * b - skim.blobtree.KIS2 * k, -skim.blobtree.KIS2 * h, -skim.blobtree.KIS2);
	a = {
		l1 : 0,
		l2 : 0
	};
	this.homotheticClippingSpecial(e, d, a) && (b = 1 / b, e.x = 1 - skim.blobtree.KIS2 * (a.l1 * (a.l1 - 2 * h) + k) * b * b, e.y = -skim.blobtree.KIS2 * (h - a.l1) * b, d = new THREE.Vector3, this.homotheticCompactPolynomial_segment_FGradF_i6_cste((a.l2 - a.l1) *
			b, e, d), f.v = d.x, d.y *= b, c = c.clone(), c.multiplyScalar(d.z + a.l1 * d.y), g.multiplyScalar(-d.y), g.addVectors(g, c), f.g = g.multiplyScalar(6 * skim.blobtree.KIS2 * b));
	return f
};
skim.blobtree.Triangle.prototype.ComputeTParam = function (a, b) {
	var c = new THREE.Vector3;
	c.subVectors(a, this.point_min);
	var d = c.dot(this.main_dir),
	c = c.dot(this.unit_normal),
	c = d * d + c * c,
	e = new THREE.Vector3;
	e.set(this.weight_min * this.weight_min - skim.blobtree.KIS2 * c, -this.unit_delta_weight * this.weight_min - skim.blobtree.KIS2 * d, this.unit_delta_weight * this.unit_delta_weight - skim.blobtree.KIS2);
	return this.homotheticClippingSpecial(e, this.coord_max, b)
};
skim.blobtree.Triangle.prototype.homotheticCompactPolynomial_segment_F_i6_cste = function (a, b) {
	var c = b.z,
	d = c * a,
	e = b.y,
	f = b.x,
	g = c * f - e * e,
	c = 1 / c,
	h = g * c,
	k = f + (-2 * e + d) * a,
	d = d - e,
	l = d * k * k,
	m = e * f * f;
	return (1.2 * (4 / 3 * (2 * g * a + d * k + e * f) * h + l + m) * h + k * l + f * m) * c / 7
};
skim.blobtree.Triangle.prototype.homotheticCompactPolynomial_segment_FGradF_i6_cste = function (a, b, c) {
	var d = b.z,
	e = d * a,
	f = b.y,
	g = b.x,
	h = d * g - f * f,
	d = 1 / d;
	b = h * d;
	var k = g + (-2 * f + e) * a,
	e = e - f,
	l = k * k,
	m = g * g;
	a = 4 / 3 * (2 * h * a + e * k + f * g) * b + e * l + f * m;
	h = a * d / 5;
	g *= m;
	k *= l;
	c.x = (1.2 * a * b + e * k + f * g) * d / 7;
	c.y = h;
	c.z = (f * h + k / 6 - g / 6) * d
};
skim.blobtree.typeTextRing = "textring";
skim.blobtree.textringNiceAccF = 0.3;
skim.blobtree.textringCurrAccF = 0.7;
skim.blobtree.textringRawAccF = 1;
skim.blobtree.textringRawOnTopAccF = 0.7;
skim.blobtree.TextRing = function (a, b, c, d) {
	skim.blobtree.Primitive.call(this);
	this.volType = c;
	this.materials = d;
	this.type = skim.blobtree.typeTextRing;
	this.v = a;
	this.thickness = skim.textUtils.computeThickness(this.v);
	this.rMin = 1E17;
	this.zMax = this.rMax = 0;
	this.zMin = 1E17;
	this.lMax = 0;
	this.thickMin = 1E18;
	this.thickMax = 0;
	this.theta = [];
	this.rz = [];
	this.arcStep = 0;
	this.constraintsIndices = [];
	this.interpolantFunctions = {
		radial : [],
		height : [],
		thickness : []
	};
	this.sdfManager = new skim.textUtils.RingSdfManager(this.v, b);
	this.ev_eps = {
		v : 0
	};
	this.p_eps = new THREE.Vector3;
	this.tmpVect3 = new THREE.Vector3;
	this.valid_aabb = !1;
	this.computeHelpVariables();
	this.isLight = !0
};
skim.blobtree.TextRing.prototype = Object.create(skim.blobtree.Primitive.prototype);
skim.blobtree.TextRing.prototype.constructor = skim.blobtree.TextRing;
skim.blobtree.TextRing.prototype.prepareForEval = function () {
	var a = {
		del_obj : [],
		new_areas : []
	};
	this.valid_aabb || (this.computeHelpVariables(), this.isLight || this.sdfManager.generateSdf(), this.valid_aabb = !0, a.new_areas = this.getAreas());
	return a
};
skim.blobtree.TextRing.prototype.compareAreas = function (a) {
	skim.utils.assert(this.valid_aabb, "Error : cannot compare if objects are not prepared for eval, please call prepareForEval before");
	skim.utils.assert(a.type === this.type, "Error : compareAreas called on different primitive type");
	for (var b = this.v.length === a.v.length, c = 0; c < this.v.length && b; ++c)
		b = b && this.v[c].equals(a.v[c]);
	return this.volType === a.volType && skim.Material.areEqualsArrays(this.materials, a.materials) && b && skim.textUtils.compareImageDatas(this.sdfManager.getImageData(),
		a.sdfManager.getImageData()) ? [] : [{
			that : this.getAreas(),
			other : a.getAreas()
		}
	]
};
skim.blobtree.TextRing.prototype.getAreas = function () {
	if (this.valid_aabb)
		return [{
				aabb : this.aabb,
				bv : new skim.blobtree.AreaTextRing(this.v, this.sdfManager),
				obj : this
			}
		];
	console.log("ERROR : Cannot get area of invalid primitive");
	return []
};
skim.blobtree.TextRing.prototype.setIsLight = function (a) {
	this.isLight = a;
	this.invalidAABB()
};
skim.blobtree.TextRing.prototype.getVolType = function () {
	return this.volType
};
skim.blobtree.TextRing.prototype.mutableVolType = function () {
	return !1
};
skim.blobtree.TextRing.prototype.computeHelpVariables = function () {
	skim.ringUtils.computeConstraints(this);
	this.thickness = skim.textUtils.computeThickness(this.v);
	this.thicknessInvSq = 1 / (this.thickness * this.thickness);
	this.computeAABB()
};
skim.blobtree.TextRing.prototype.computeAABB = function () {
	var a = this.thickMax * skim.blobtree.KS;
	this.aabb.set(-this.rMax - a, -this.rMax - a, this.zMin - a, this.rMax + a, this.rMax + a, this.zMax + a)
};
skim.blobtree.TextRing.prototype.distanceTo = function (a) {
	return 1
};
skim.blobtree.TextRing.prototype.heuristicStepWithin = function () {
	return this.thickness / 3
};
skim.blobtree.TextRing.prototype.value = function (a, b, c) {
	switch (this.volType) {
	case skim.VolType.Mech:
		return this.evalMech(a, b, c);
	case skim.VolType.Orga:
		return this.evalMech(a, b, c);
	default:
		console.log("Unknown volType, use Orga")
	}
};
skim.blobtree.TextRing.prototype.evalMech = function (a, b, c) {
	this.isLight ? skim.ringUtils.evalMechForRing(this, a, b, c) : this.evalMechForTextRing(a, b, c)
};
skim.blobtree.TextRing.prototype.evalMechForTextRing = function (a, b, c) {
	var d = skim.textUtils.getDistSq(this.sdfManager, a);
	null === d ? c.v = 0 : (c.v = skim.blobtree.Poly6EvalSq(d * this.thicknessInvSq) * skim.blobtree.Poly6NF0D, b & skim.blobtree.EvalTags.Mat && c.m.copy(this.materials[0]), b & skim.blobtree.EvalTags.Grad && (this.p_eps.copy(a), this.p_eps.x += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.x = (this.ev_eps.v - c.v) / 1E-5, this.p_eps.x -= 1E-5, this.p_eps.y += 1E-5, this.evalMech(this.p_eps,
					skim.blobtree.EvalTags.Value, this.ev_eps), c.g.y = (this.ev_eps.v - c.v) / 1E-5, this.p_eps.y -= 1E-5, this.p_eps.z += 1E-5, this.evalMech(this.p_eps, skim.blobtree.EvalTags.Value, this.ev_eps), c.g.z = (this.ev_eps.v - c.v) / 1E-5))
};
skim.blobtree.Encoder = function (a) {
	var b = this.getEncodedSize(a);
	this.imageDatas = {};
	this.sdfs = [];
	this.buffer = new ArrayBuffer(4 * b);
	this.buff = new Float32Array(this.buffer);
	this.index = 0;
	this.encodeBlobtree(a)
};
skim.blobtree.Encoder.prototype.getEncodedSize = function (a) {
	var b = this.getNodeSize(a);
	if (a.type == skim.blobtree.rootNodeType || a.type == skim.blobtree.ricciNodeType || a.type == skim.blobtree.nodeType)
		for (var c = 0; c < a.children.length; c++)
			b += this.getEncodedSize(a.children[c]);
	return b
};
skim.blobtree.Encoder.prototype.getNodeSize = function (a) {
	switch (a.getType()) {
	case skim.blobtree.rootNodeType:
	case skim.blobtree.ricciNodeType:
	case skim.blobtree.nodeType:
		return this.getMergeNodeSize(a);
	case "point":
		return this.getPointNodeSize(a);
	case "segment":
		return this.getSegmentNodeSize(a);
	case "ring":
		return this.getRingNodeSize(a);
	case "text":
		return this.getTextNodeSize(a);
	case "textring":
		return this.getTextRingNodeSize(a);
	case "triangle":
		return this.getTriangleNodeSize(a);
	default:
		return console.error("unrecognized node type at encoding: " +
			a.getType()),
		0
	}
};
skim.blobtree.Encoder.prototype.getBuffer = function () {
	return this.buffer
};
skim.blobtree.Encoder.prototype.getImageDatas = function () {
	return this.imageDatas
};
skim.blobtree.Encoder.prototype.getSdfs = function () {
	return this.sdfs
};
skim.blobtree.Encoder.prototype.getVertArraySize = function (a) {
	return 1 + 4 * a.length
};
skim.blobtree.Encoder.prototype.getMatArraySize = function (a) {
	return 1 + 5 * a.length
};
skim.blobtree.Encoder.prototype.encodeVertex = function (a) {
	var b = a.getPos();
	a = a.getThickness();
	this.buff[this.index++] = b.x;
	this.buff[this.index++] = b.y;
	this.buff[this.index++] = b.z;
	this.buff[this.index++] = a
};
skim.blobtree.Encoder.prototype.getVertexSize = function () {
	return 4
};
skim.blobtree.Encoder.prototype.encodeMaterial = function (a) {
	this.buff[this.index++] = a.getColor().r;
	this.buff[this.index++] = a.getColor().g;
	this.buff[this.index++] = a.getColor().b;
	this.buff[this.index++] = a.getRoughness();
	this.buff[this.index++] = a.getMetallic()
};
skim.blobtree.Encoder.prototype.getMaterialSize = function () {
	return 5
};
skim.blobtree.Encoder.prototype.encodeMaterialArray = function (a) {
	this.buff[this.index++] = a.length;
	for (var b = 0; b < a.length; ++b)
		this.encodeMaterial(a[b])
};
skim.blobtree.Encoder.prototype.encodeAABB = function (a) {
	this.buff[this.index++] = a.min.x;
	this.buff[this.index++] = a.min.y;
	this.buff[this.index++] = a.min.z;
	this.buff[this.index++] = a.max.x;
	this.buff[this.index++] = a.max.y;
	this.buff[this.index++] = a.max.z
};
skim.blobtree.Encoder.prototype.encodeVolType = function (a) {
	this.buff[this.index++] = a == skim.VolType.Orga ? 0 : 1
};
skim.blobtree.Encoder.prototype.encodeDensity = function (a) {
	this.buff[this.index++] = a
};
skim.blobtree.Encoder.prototype.encodeIsLight = function (a) {
	this.buff[this.index++] = a ? 1 : 0
};
skim.blobtree.Encoder.prototype.encodeValidAABB = function (a) {
	this.buff[this.index++] = a ? 1 : 0
};
skim.blobtree.Encoder.prototype.encodeVertArray = function (a) {
	var b = a.length;
	this.buff[this.index++] = b;
	for (var c = 0; c < b; c++)
		this.encodeVertex(a[c])
};
skim.blobtree.Encoder.prototype.encodeImgData = function (a) {
	this.imageDatas[a.id] = a.sdfManager.imageData
};
skim.blobtree.Encoder.prototype.encodeType = function (a) {
	this.buff[this.index++] = a
};
skim.blobtree.Encoder.prototype.encodeId = function (a) {
	this.buff[this.index++] = a
};
skim.blobtree.Encoder.prototype.encodePoint = function (a) {
	this.encodeType(2);
	this.encodeId(a.id);
	this.encodeVertex(a.v[0]);
	this.encodeMaterial(a.materials[0]);
	this.encodeVolType(a.volType);
	this.encodeDensity(a.density);
	this.encodeValidAABB(a.valid_aabb)
};
skim.blobtree.Encoder.prototype.getPointNodeSize = function (a) {
	return 2 + this.getVertexSize() + this.getMaterialSize() + 3
};
skim.blobtree.Encoder.prototype.encodeSegment = function (a) {
	this.encodeType(3);
	this.encodeId(a.id);
	this.encodeVertex(a.v[0]);
	this.encodeVertex(a.v[1]);
	this.encodeMaterial(a.materials[0]);
	this.encodeMaterial(a.materials[1]);
	this.encodeVolType(a.volType);
	this.encodeDensity(a.density);
	this.encodeValidAABB(a.valid_aabb)
};
skim.blobtree.Encoder.prototype.getSegmentNodeSize = function (a) {
	return 2 + 2 * this.getVertexSize() + 2 * this.getMaterialSize() + 3
};
skim.blobtree.Encoder.prototype.encodeRing = function (a) {
	this.encodeType(4);
	this.encodeId(a.id);
	this.encodeVertArray(a.v);
	this.encodeMaterialArray(a.materials);
	this.encodeVolType(a.volType);
	this.encodeValidAABB(a.valid_aabb)
};
skim.blobtree.Encoder.prototype.getRingNodeSize = function (a) {
	return 2 + this.getVertArraySize(a.v) + this.getMatArraySize(a.materials) + 2
};
skim.blobtree.Encoder.prototype.encodeText = function (a) {
	this.encodeType(5);
	this.encodeId(a.id);
	this.encodeVertArray(a.v);
	this.encodeMaterialArray(a.materials);
	this.encodeImgData(a);
	this.encodeVolType(a.volType);
	this.encodeIsLight(a.isLight);
	this.encodeValidAABB(a.valid_aabb);
	a.valid_aabb && !a.isLight && (this.encodeCompressionFactor(a.sdfManager.compressionFactor), this.encodeSDFData(a.sdfManager.sdfData))
};
skim.blobtree.Encoder.prototype.getTextNodeSize = function (a) {
	var b = 2 + this.getVertArraySize(a.v) + this.getMatArraySize(a.materials) + 3;
	a.isValidAABB() && !a.isLight && (b += 1 + this.getSDFDataSize(a.sdfManager.sdfData));
	return b
};
skim.blobtree.Encoder.prototype.encodeTextRing = function (a) {
	this.encodeType(6);
	this.encodeId(a.id);
	this.encodeVertArray(a.v);
	this.encodeMaterialArray(a.materials);
	this.encodeImgData(a);
	this.encodeVolType(a.volType);
	this.encodeIsLight(a.isLight);
	this.encodeValidAABB(a.valid_aabb);
	a.valid_aabb && !a.isLight && (this.encodeCompressionFactor(a.sdfManager.compressionFactor), this.encodeSDFData(a.sdfManager.sdfData))
};
skim.blobtree.Encoder.prototype.getTextRingNodeSize = function (a) {
	var b = 2 + this.getVertArraySize(a.v) + this.getMatArraySize(a.materials) + 3;
	a.isValidAABB() && !a.isLight && (b += 1 + this.getSDFDataSize(a.sdfManager.sdfData));
	return b
};
skim.blobtree.Encoder.prototype.encodeCompressionFactor = function (a) {
	this.buff[this.index++] = a
};
skim.blobtree.Encoder.prototype.encodeSDFData = function (a) {
	this.sdfs.push(a);
	this.buff[this.index++] = this.sdfs.length - 1
};
skim.blobtree.Encoder.prototype.getSDFDataSize = function (a) {
	return 1
};
skim.blobtree.Encoder.prototype.encodeTriangle = function (a) {
	this.encodeType(7);
	this.encodeId(a.id);
	this.encodeVertex(a.v[0]);
	this.encodeVertex(a.v[1]);
	this.encodeVertex(a.v[2]);
	this.encodeMaterial(a.materials[0]);
	this.encodeMaterial(a.materials[1]);
	this.encodeMaterial(a.materials[2]);
	this.encodeVolType(a.volType);
	this.encodeValidAABB(a.valid_aabb)
};
skim.blobtree.Encoder.prototype.getTriangleNodeSize = function (a) {
	return 2 + 3 * this.getVertexSize() + 3 * this.getMaterialSize() + 2
};
skim.blobtree.Encoder.prototype.encodeMergeNode = function (a) {
	this.encodeType(1);
	this.encodeId(a.id);
	this.buff[this.index++] = a.ricci_n;
	this.buff[this.index++] = a.deleted_obj.length;
	this.buff[this.index++] = a.children.length;
	for (var b = 0; b < a.deleted_obj.length; b++)
		this.encodeNode(a.deleted_obj[b]);
	for (b = 0; b < a.children.length; b++)
		this.encodeNode(a.children[b]);
	this.encodeValidAABB(a.valid_aabb)
};
skim.blobtree.Encoder.prototype.encodeRootNode = function (a) {
	this.encodeType(0);
	this.encodeId(a.id);
	this.buff[this.index++] = a.ricci_n;
	this.buff[this.index++] = a.deleted_obj.length;
	this.buff[this.index++] = a.children.length;
	for (var b = 0; b < a.deleted_obj.length; b++)
		this.encodeNode(a.deleted_obj[b]);
	for (b = 0; b < a.children.length; b++)
		this.encodeNode(a.children[b]);
	this.encodeValidAABB(a.valid_aabb)
};
skim.blobtree.Encoder.prototype.getMergeNodeSize = function (a) {
	for (var b = 5, c = 0; c < a.deleted_obj.length; c++)
		b += this.getNodeSize(a.deleted_obj[c]);
	return b + 1
};
skim.blobtree.Encoder.prototype.encodeNode = function (a) {
	switch (a.getType()) {
	case skim.blobtree.rootNodeType:
	case skim.blobtree.ricciNodeType:
	case skim.blobtree.nodeType:
		a instanceof skim.blobtree.Root ? this.encodeRootNode(a) : this.encodeMergeNode(a);
		break;
	case "point":
		this.encodePoint(a);
		break;
	case "segment":
		this.encodeSegment(a);
		break;
	case "ring":
		this.encodeRing(a);
		break;
	case "text":
		this.encodeText(a);
		break;
	case "textring":
		this.encodeTextRing(a);
		break;
	case "triangle":
		this.encodeTriangle(a);
		break;
	default:
		console.error("unrecognized node type at encoding: " +
			a.getType())
	}
};
skim.blobtree.Encoder.prototype.encodeBlobtree = function (a) {
	this.encodeNode(a)
};
skim.blobtree.Decoder = function (a, b, c) {
	this.buffer = a;
	this.buff = new Float32Array(this.buffer);
	this.index = 0;
	this.imageDatas = b || null;
	this.sdfs = c || [];
	this.blobtree = this.decodeBlobtree()
};
skim.blobtree.Decoder.prototype.getBlobtree = function () {
	return this.blobtree
};
skim.blobtree.Decoder.prototype.getSdfAt = function (a) {
	skim.utils.assert(a < this.sdfs.length, "Error : wanted sdf is not present");
	return this.sdfs[a]
};
skim.blobtree.Decoder.prototype.decodeVertex = function () {
	var a = this.buff[this.index++],
	b = this.buff[this.index++],
	c = this.buff[this.index++],
	d = this.buff[this.index++],
	a = new THREE.Vector3(a, b, c);
	return new skim.blobtree.Vertex(a, d)
};
skim.blobtree.Decoder.prototype.decodeMaterialArray = function () {
	for (var a = this.buff[this.index++], b = [], c = 0; c < a; ++c)
		b.push(this.decodeMaterial());
	return b
};
skim.blobtree.Decoder.prototype.decodeMaterial = function () {
	var a = this.buff[this.index++],
	b = this.buff[this.index++],
	c = this.buff[this.index++],
	d = this.buff[this.index++],
	e = this.buff[this.index++],
	f = new THREE.Color;
	f.setRGB(a, b, c);
	return new skim.Material(f, d, e)
};
skim.blobtree.Decoder.prototype.decodeAABB = function () {
	var a = this.buff[this.index++],
	b = this.buff[this.index++],
	c = this.buff[this.index++],
	d = this.buff[this.index++],
	e = this.buff[this.index++],
	f = this.buff[this.index++];
	return new skim.geometry.AABBox(a, b, c, d, e, f)
};
skim.blobtree.Decoder.prototype.decodeType = function () {
	return this.buff[this.index++]
};
skim.blobtree.Decoder.prototype.decodeId = function () {
	return this.buff[this.index++]
};
skim.blobtree.Decoder.prototype.decodeVolType = function () {
	return 0 === this.buff[this.index++] ? skim.VolType.Orga : skim.VolType.Mech
};
skim.blobtree.Decoder.prototype.decodeDensity = function () {
	return this.buff[this.index++]
};
skim.blobtree.Decoder.prototype.decodeIsLight = function () {
	return 1 === this.buff[this.index++]
};
skim.blobtree.Decoder.prototype.decodeValidAABB = function () {
	return 1 == this.buff[this.index++]
};
skim.blobtree.Decoder.prototype.decodeVertArray = function () {
	for (var a = this.buff[this.index++], b = [], c = 0; c < a; c++)
		b[c] = this.decodeVertex();
	return b
};
skim.blobtree.Decoder.prototype.decodePoint = function () {
	var a = this.decodeId(),
	b = this.decodeVertex(),
	c = this.decodeMaterial(),
	d = this.decodeVolType(),
	e = this.decodeDensity(),
	b = new skim.blobtree.Point(b, d, e, c);
	b.id = a;
	this.decodeValidAABB() && b.prepareForEval();
	return b
};
skim.blobtree.Decoder.prototype.decodeSegment = function () {
	var a = this.decodeId(),
	b = this.decodeVertex(),
	c = this.decodeVertex(),
	d = this.decodeMaterial(),
	e = this.decodeMaterial(),
	f = this.decodeVolType(),
	g = this.decodeDensity(),
	b = new skim.blobtree.Segment(b, c, f, g, [d, e]);
	b.id = a;
	this.decodeValidAABB() && b.prepareForEval();
	return b
};
skim.blobtree.Decoder.prototype.decodeRing = function () {
	var a = this.decodeId(),
	b = this.decodeVertArray(),
	c = this.decodeMaterialArray(),
	d = this.decodeVolType(),
	b = new skim.blobtree.Ring(b, d, c);
	b.id = a;
	this.decodeValidAABB() && b.prepareForEval();
	return b
};
skim.blobtree.Decoder.prototype.decodeText = function (a) {
	var b = this.decodeId(),
	c = this.decodeVertArray(),
	d = this.decodeMaterialArray(),
	e = this.imageDatas[b],
	f = this.decodeVolType(),
	c = new skim.blobtree.Text(c, e, f, d);
	c.setIsLight(void 0 !== a ? a : !1);
	c.id = b;
	a = this.decodeIsLight();
	this.decodeValidAABB() && (a ? c.prepareForEval() : (c.computeHelpVariables(), c.valid_aabb = !0, c.sdfManager.compressionFactor = this.decodeCompressionFactor(), c.sdfManager.sdfData = this.decodeSDFData(), c.sdfManager.sdfMapper = c.sdfManager.computeMapper()));
	return c
};
skim.blobtree.Decoder.prototype.decodeTextRing = function (a) {
	var b = this.decodeId(),
	c = this.decodeVertArray(),
	d = this.decodeMaterialArray(),
	e = this.imageDatas[b],
	f = this.decodeVolType(),
	c = new skim.blobtree.TextRing(c, e, f, d);
	c.setIsLight(void 0 !== a ? a : !1);
	c.id = b;
	a = this.decodeIsLight();
	this.decodeValidAABB() && (a ? c.prepareForEval() : (c.computeHelpVariables(), c.valid_aabb = !0, c.sdfManager.compressionFactor = this.decodeCompressionFactor(), c.sdfManager.sdfData = this.decodeSDFData(), c.sdfManager.sdfMapper = c.sdfManager.computeMapper()));
	return c
};
skim.blobtree.Decoder.prototype.decodeCompressionFactor = function () {
	return this.buff[this.index++]
};
skim.blobtree.Decoder.prototype.decodeSDFData = function () {
	return this.getSdfAt(this.buff[this.index++])
};
skim.blobtree.Decoder.prototype.decodeTriangle = function () {
	var a = this.decodeId(),
	b = [this.decodeVertex(), this.decodeVertex(), this.decodeVertex()],
	c = [this.decodeMaterial(), this.decodeMaterial(), this.decodeMaterial()],
	d = this.decodeVolType(),
	b = new skim.blobtree.Triangle(b, d, c);
	b.id = a;
	this.decodeValidAABB() && b.prepareForEval();
	return b
};
skim.blobtree.Decoder.prototype.decodeNode = function (a, b) {
	var c = this.decodeType(),
	d = null;
	switch (c) {
	case 0:
		d = this.decodeRootNode(a, b);
		break;
	case 1:
		d = this.decodeMergeNode(a, b);
		break;
	case 2:
		d = this.decodePoint();
		break;
	case 3:
		d = this.decodeSegment();
		break;
	case 4:
		d = this.decodeRing();
		break;
	case 5:
		d = this.decodeText(b);
		break;
	case 6:
		d = this.decodeTextRing(b);
		break;
	case 7:
		d = this.decodeTriangle();
		break;
	default:
		console.error("unrecognized node type at decoding: " + c)
	}
	return d
};
skim.blobtree.Decoder.prototype.decodeMergeNode = function (a, b) {
	var c = null,
	d = this.decodeId(),
	c = new skim.blobtree.RicciNode(this.buff[this.index++]);
	c.id = d;
	for (var d = this.buff[this.index++], e = this.buff[this.index++], f = 0; f < d; f++)
		c.deleted_obj[f] = this.decodeNode(c, !0);
	for (f = 0; f < e; f++)
		c.addChild(this.decodeNode(c, b));
	this.decodeValidAABB() && c.prepareForEval();
	return c
};
skim.blobtree.Decoder.prototype.decodeRootNode = function (a, b) {
	skim.utils.assert(null === a, "Error : decoding a root with a non null parentNode");
	var c = null,
	d = this.decodeId(),
	c = new skim.blobtree.Root;
	c.setRicciN(this.buff[this.index++]);
	c.id = d;
	for (var d = this.buff[this.index++], e = this.buff[this.index++], f = 0; f < d; f++)
		c.deleted_obj[f] = this.decodeNode(c, !0);
	for (f = 0; f < e; f++)
		c.addChild(this.decodeNode(c, b));
	this.decodeValidAABB() && c.prepareForEval();
	return c
};
skim.blobtree.Decoder.prototype.decodeBlobtree = function (a) {
	a = this.decodeNode(null, void 0 !== a ? a : !1);
	skim.utils.assert(this.buff.length === this.index, "Error : something wring when decoding, number of decoded float does not match final index");
	return a
};
skim.textUtils.sdfMethod = 1;
skim.textUtils.SdfManager = function (a, b) {
	this.v = a;
	this.imageData = b;
	this.sdfMapper = this.sdfData = null;
	this.compressionFactor = 1;
	this.BBPixelSizeX = this.BBPixelSizeY = null;
	this.uncompressedValues = {
		BBy : null,
		BBx : null,
		width : null,
		height : null
	}
};
skim.textUtils.SdfManager.prototype.getImageData = function () {
	return this.imageData
};
skim.textUtils.SdfManager.prototype.generateSdf = function () {
	var a = null,
	b = null,
	a = (new Date).getTime(),
	c = this.computeSdf(this.imageData);
	console.log("SDF uncompressed size: width: " + c.width + " and height: " + c.height);
	b = (new Date).getTime();
	console.log("Computing SDF: " + (b - a).toFixed(2) + " ms");
	a = (new Date).getTime();
	this.sdfData = this.compressSdf(c);
	b = (new Date).getTime();
	console.log("Compressing SDF: " + (b - a).toFixed(2) + " ms");
	console.log("SDF compressed size: width: " + this.sdfData.width + " and height: " +
		this.sdfData.height);
	console.log("BB compressed size: X: " + this.BBPixelSizeX + " and Y: " + this.BBPixelSizeY);
	this.sdfMapper = this.computeMapper()
};
skim.textUtils.SdfManager.prototype.computeSdf = function (a) {
	var b = null;
	switch (skim.textUtils.sdfMethod) {
	case 1:
		b = skim.textUtils.computeSignedDistanceField(a);
		break;
	case 2:
		b = (new skim.textUtils.AntiAliasedComputer).Generate(a);
		break;
	case 3:
		b = skim.textUtils.computeUnsignedDistanceField(a);
		break;
	default:
		b = {
			data : null,
			width : 0,
			height : 0
		},
		console.error("SdfManager - sdfMethod is unknown")
	}
	return b
};
skim.textUtils.SdfManager.prototype.computeMapper = function () {
	skim.utils.assert(!1, "computeMapper is virtual and should be redefined");
	return null
};
skim.textUtils.SdfManager.prototype.computeMapperHelper = function () {
	var a = this.thickness * skim.blobtree.KS,
	a = Math.ceil(a * this.imageData.height / (this.height + 2 * a)),
	b = Math.ceil(a * this.imageData.width / this.imageData.height);
	skim.utils.assert(skim.utils.isApproxEqual((this.imageData.width + 2 * b) / (this.imageData.height + 2 * a), this.imageData.width / this.imageData.height, 0.1), "X and Y ratio should be the same after BBbox addition!");
	this.uncompressedValues = {
		BBy : a,
		BBx : b,
		width : this.imageData.width - 2 * b,
		height : this.imageData.height -
		2 * a
	};
	this.BBPixelSizeY = a / this.compressionFactor;
	this.BBPixelSizeX = b / this.compressionFactor
};
skim.textUtils.SdfManager.prototype.compressSdf = function (a) {
	this.compressionFactor = this.computeCompressionFactor(a);
	console.log("Compression Factor is: " + this.compressionFactor);
	if (1 === this.compressionFactor)
		return a;
	for (var b = {
			data : [],
			width : 0,
			height : 0
		}, c = 0, d = 0; c < a.height; d++, c += this.compressionFactor)
		for (var e = 0, f = 0; e < a.width; f++, e += this.compressionFactor)
			b.data.push(a.data[c * a.width + e]);
	b.width = f;
	b.height = d;
	skim.utils.assert(b.data.length === b.width * b.height, "compression is wrong");
	console.log("data is: " +
		b.data.length + " while computed width is: " + b.width + " and computed height is" + b.height + ". data length should be: " + b.width * b.height);
	return b
};
skim.textUtils.SdfManager.prototype.computeCompressionFactor = function (a) {
	return 1
};
skim.textUtils.getDist = function (a, b) {
	var c = skim.textUtils.getDistSq(a, b);
	return null === c ? null : Math.sqrt(c)
};
skim.textUtils.getDistSq = function (a, b) {
	var c = skim.textUtils.getDepthDist(a, b, !1),
	d = skim.textUtils.getSdfDist(a, b, !1);
	return null === d ? null : c * c + d * d
};
skim.textUtils.getDepthDist = function (a, b, c) {
	return a.sdfMapper.mapDepth(b, c)
};
skim.textUtils.getSdfDist = function (a, b, c) {
	var d = a.sdfData;
	a = a.sdfMapper;
	b = a.mapPoint(b);
	var e = null;
	a.checkMapping(b, d) && (e = skim.geometry.bicubicOptim2DInterp(b.x, b.y, d.data, d.width), e = a.unmapDist(!c && 0 > e ? 0 : e));
	return e
};
skim.textUtils.RingSdfManager = function (a, b) {
	skim.textUtils.SdfManager.call(this, a, b);
	this.height = skim.textUtils.computeHeight(this.v);
	this.thickness = skim.textUtils.computeThickness(this.v);
	this.radius = skim.textUtils.computeRadius(this.v);
	this.width = 2 * this.radius * Math.PI;
	this.depth = skim.textUtils.computeSDFLength(this.v)
};
skim.textUtils.RingSdfManager.prototype = Object.create(skim.textUtils.SdfManager.prototype);
skim.textUtils.RingSdfManager.prototype.constructor = skim.textUtils.RingSdfManager;
skim.textUtils.RingSdfManager.prototype.computeMapper = function () {
	this.computeMapperHelper();
	return new skim.textUtils.RingSDFMaper(this)
};
skim.textUtils.RingSdfManager.prototype.computeCompressionFactor = function (a) {
	return Math.max(1, Math.floor(a.height / 100))
};
skim.textUtils.FlatSdfManager = function (a, b) {
	skim.textUtils.SdfManager.call(this, a, b);
	var c = [a[0].getPos(), a[1].getPos(), a[2].getPos(), a[3].getPos()],
	d = new THREE.Vector3,
	e = [d.clone().subVectors(c[1], c[0]), d.clone().subVectors(c[2], c[0]), d.clone().subVectors(c[3], c[0])];
	skim.utils.assert(skim.geometry.isOrthogonal(e), "Text vertices should be defined as an orthogonal basis");
	skim.utils.assert(a[0].getThickness() === a[1].getThickness() && a[1].getThickness() === a[2].getThickness() && a[2].getThickness() ===
		a[3].getThickness(), "Thickness should be the same for all vertices of a text prim");
	this.height = d.subVectors(c[2], c[0]).length();
	this.thickness = a[0].getThickness();
	this.width = d.subVectors(c[1], c[0]).length();
	this.depth = d.subVectors(c[3], c[0]).length()
};
skim.textUtils.FlatSdfManager.prototype = Object.create(skim.textUtils.SdfManager.prototype);
skim.textUtils.FlatSdfManager.prototype.constructor = skim.textUtils.FlatSdfManager;
skim.textUtils.FlatSdfManager.prototype.computeMapper = function () {
	this.computeMapperHelper();
	return new skim.textUtils.FlatSDFMaper(this)
};
skim.textUtils.FlatSdfManager.prototype.computeCompressionFactor = function (a) {
	return Math.max(1, Math.floor((a.width < a.height ? a.width : a.height) / 100))
};
skim.textUtils.SDFMaper = function (a, b, c) {
	this.mat = a;
	this.scaleOtpimFactor = 1 / ((b.x > b.y ? b.x : b.y) * c)
};
skim.textUtils.SDFMaper.prototype.mapPoint = function (a) {
	console.error("SDFMaper - mapPoint is virtual and should be redefined");
	return {
		x : null,
		y : null
	}
};
skim.textUtils.SDFMaper.prototype.mapDepth = function (a, b) {
	console.error("SDFMaper - mapPoint is virtual and should be redefined");
	return null
};
skim.textUtils.SDFMaper.prototype.checkMapping = function (a, b) {
	console.error("SDFMaper - mapPoint is virtual and should be redefined");
	return !1
};
skim.textUtils.SDFMaper.prototype.unmapDist = function (a) {
	return a * this.scaleOtpimFactor
};
skim.textUtils.RingSDFMaper = function (a) {
	var b = new THREE.Vector3(a.uncompressedValues.width / (a.width * a.compressionFactor), a.uncompressedValues.height / (a.height * a.compressionFactor), 1);
	skim.utils.assert(skim.utils.isApproxEqual(b.x, b.y, 0.1), "X and Y ratio should be the same for computation!");
	console.log("Sdf has: " + a.sdfData.width * a.sdfData.height + " elements");
	var c = new THREE.Matrix4,
	d = new THREE.Matrix4,
	e = new THREE.Matrix4,
	f = new THREE.Matrix4,
	g = new THREE.Matrix4,
	h = new THREE.Matrix4;
	d.scale(b);
	f.makeScale(1,
		-1, 1);
	e.makeTranslation(0, a.uncompressedValues.height / a.compressionFactor + a.BBPixelSizeY, 0);
	h.set(1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1);
	g.makeTranslation(0, 0, a.height / 2);
	c = c.multiplyMatrices(c, e);
	c = c.multiplyMatrices(c, f);
	c = c.multiplyMatrices(c, d);
	c = c.multiplyMatrices(c, h);
	c = c.multiplyMatrices(c, g);
	this.halfDepth = a.depth / 2;
	this.radius = a.radius;
	this.realWidth = a.uncompressedValues.width / a.compressionFactor;
	this.BBPixelSizeX = a.BBPixelSizeX;
	skim.textUtils.SDFMaper.call(this, c, b, a.compressionFactor)
};
skim.textUtils.RingSDFMaper.prototype = Object.create(skim.textUtils.SDFMaper.prototype);
skim.textUtils.RingSDFMaper.prototype.constructor = skim.textUtils.RingSDFMaper;
skim.textUtils.RingSDFMaper.prototype.mapPoint = function (a) {
	var b = this.mat.elements,
	b = b[1] * a.x + b[5] * a.y + b[9] * a.z + b[13];
	a = skim.geometry.GetXAngleFromPoint(a) / (2 * Math.PI);
	return {
		x : this.BBPixelSizeX + this.realWidth * a,
		y : b
	}
};
skim.textUtils.RingSDFMaper.prototype.mapDepth = function (a, b) {
	var c = skim.geometry.computeRadialDist(a) - this.radius;
	c > -this.halfDepth && c < this.halfDepth ? c = b ? Math.abs(c) - this.halfDepth : 0 : (c = 0 > c ? c + this.halfDepth : c - this.halfDepth, c = Math.abs(c));
	return c
};
skim.textUtils.RingSDFMaper.prototype.checkMapping = function (a, b) {
	return a.y < b.height - 2 && 1 < a.y
};
skim.textUtils.FlatSDFMaper = function (a) {
	this.halfDepth = a.depth / 2;
	var b = new THREE.Vector3(a.uncompressedValues.width / (a.width * a.compressionFactor), a.uncompressedValues.height / (a.height * a.compressionFactor), 1),
	c = new THREE.Matrix4,
	d = new THREE.Matrix4;
	new THREE.Matrix4;
	var e = new THREE.Matrix4,
	f = new THREE.Matrix4,
	g = new THREE.Matrix4,
	h = a.v[0].getPos();
	d.makeTranslation(-h.x, -h.y,  - (h.z + this.halfDepth));
	e.scale(b);
	g.makeScale(1, -1, 1);
	f.makeTranslation(a.BBPixelSizeX, a.uncompressedValues.height / a.compressionFactor +
		a.BBPixelSizeY, 0);
	c = c.multiplyMatrices(c, f);
	c = c.multiplyMatrices(c, g);
	c = c.multiplyMatrices(c, e);
	c = c.multiplyMatrices(c, d);
	skim.textUtils.SDFMaper.call(this, c, b, a.compressionFactor)
};
skim.textUtils.FlatSDFMaper.prototype = Object.create(skim.textUtils.SDFMaper.prototype);
skim.textUtils.FlatSDFMaper.prototype.constructor = skim.textUtils.FlatSDFMaper;
skim.textUtils.FlatSDFMaper.prototype.mapPoint = function (a) {
	var b = this.mat.elements;
	return {
		x : b[0] * a.x + b[4] * a.y + b[8] * a.z + b[12],
		y : b[1] * a.x + b[5] * a.y + b[9] * a.z + b[13]
	}
};
skim.textUtils.FlatSDFMaper.prototype.mapDepth = function (a, b) {
	var c = this.mat.elements,
	c = c[2] * a.x + c[6] * a.y + c[10] * a.z + c[14];
	c > -this.halfDepth && c < this.halfDepth ? c = b ? Math.abs(c) - this.halfDepth : 0 : (c = 0 > c ? c + this.halfDepth : c - this.halfDepth, c = Math.abs(c));
	return c
};
skim.textUtils.FlatSDFMaper.prototype.checkMapping = function (a, b) {
	return a.x < b.width - 2 && 1 < a.x && a.y < b.height - 2 && 1 < a.y
};
skim.blobtree.Area = function () {};
skim.blobtree.AreaPoint = function (a, b) {
	skim.blobtree.Area.call(this);
	this.p = new THREE.Vector3(a.x, a.y, a.z);
	this.thick = b;
	this.v_to_p = new THREE.Vector3
};
skim.blobtree.AreaPoint.prototype = Object.create(skim.blobtree.Area.prototype);
skim.blobtree.AreaPoint.prototype.constructor = skim.blobtree.AreaPoint;
skim.blobtree.AreaPoint.prototype.sphereIntersect = function (a) {
	this.v_to_p.subVectors(a.c, this.p);
	a = a.r + this.thick * skim.blobtree.KS;
	return this.v_to_p.lengthSq() < a * a
};
skim.blobtree.AreaPoint.prototype.contains = function (a) {
	this.v_to_p.subVectors(a, this.p);
	return this.v_to_p.lengthSq() < this.thick * this.thick * skim.blobtree.KS2
};
skim.blobtree.AreaPoint.prototype.getAcc = function (a, b) {
	return this.thick * b
};
skim.blobtree.AreaPoint.prototype.getNiceAcc = function (a) {
	return this.getAcc(a, skim.blobtree.pointNiceAccF)
};
skim.blobtree.AreaPoint.prototype.getCurrAcc = function (a) {
	return this.getAcc(a, skim.blobtree.pointCurrAccF)
};
skim.blobtree.AreaPoint.prototype.getRawAcc = function (a) {
	return this.getAcc(a, skim.blobtree.pointRawAccF)
};
skim.blobtree.AreaPoint.prototype.getMinAcc = function () {
	return skim.blobtree.pointCurrAccF * this.thick
};
skim.blobtree.AreaPoint.prototype.getMinRawAcc = function () {
	return skim.blobtree.pointRawAccF * this.thick
};
skim.blobtree.AreaPoint.prototype.getAxisProjectionMinStep = function (a, b) {
	var c = 1E8,
	d = b - this.p[a];
	d < -2 * this.thick ? c = Math.min(c, Math.max(Math.abs(d + 2 * this.thick), skim.blobtree.pointCurrAccF * this.thick)) : d < 2 * this.thick && (c = Math.min(c, skim.blobtree.pointCurrAccF * this.thick));
	return c
};
skim.blobtree.AreaSeg = function (a, b, c, d, e, f) {
	skim.blobtree.Area.call(this);
	this.p0 = new THREE.Vector3(a.x, a.y, a.z);
	this.p1 = new THREE.Vector3(b.x, b.y, b.z);
	this.thick0 = c;
	this.thick1 = d;
	this.length = e;
	this.unit_dir = new THREE.Vector3(f.x, f.y, f.z);
	this.p0_to_p = this.vector = new THREE.Vector3;
	this.y_p_2DSq = this.y_p_2D = this.x_p_2D = this.p0_to_p_sqrnorm = 0;
	this.ortho_vec_x = this.thick0 - this.thick1;
	this.ortho_vec_y = this.length;
	this.p_proj_y = this.p_proj_x = 0;
	this.abs_diff_thick = Math.abs(this.ortho_vec_x)
};
skim.blobtree.AreaSeg.prototype = Object.create(skim.blobtree.Area.prototype);
skim.blobtree.AreaSeg.prototype.constructor = skim.blobtree.AreaSeg;
skim.blobtree.AreaSeg.prototype.proj_computation = function (a) {
	this.p0_to_p = this.vector;
	this.p0_to_p.subVectors(a, this.p0);
	this.p0_to_p_sqrnorm = this.p0_to_p.lengthSq();
	this.x_p_2D = this.p0_to_p.dot(this.unit_dir);
	this.y_p_2DSq = this.p0_to_p_sqrnorm - this.x_p_2D * this.x_p_2D;
	this.y_p_2D = 0 < this.y_p_2DSq ? Math.sqrt(this.y_p_2DSq) : 0;
	this.p_proj_x = this.x_p_2D + -this.y_p_2D / this.ortho_vec_y * this.ortho_vec_x;
	this.p_proj_y = 0
};
skim.blobtree.AreaSeg.prototype.sphereIntersect = function (a) {
	this.proj_computation(a.c);
	if (0 > this.p_proj_x)
		return Math.sqrt(this.p0_to_p_sqrnorm) - a.r < this.thick0 * skim.blobtree.KS;
	if (this.p_proj_x > this.length)
		return this.vector.subVectors(a.c, this.p1), Math.sqrt(this.vector.lengthSq()) - a.r < this.thick1 * skim.blobtree.KS;
	var b = this.x_p_2D - this.p_proj_x,
	c = this.p_proj_x / this.length;
	a = a.r + (this.thick0 * (1 - c) + c * this.thick1) * skim.blobtree.KS;
	return b * b + this.y_p_2DSq < a * a
};
skim.blobtree.AreaSeg.prototype.contains = function (a) {
	this.proj_computation(a);
	if (0 > this.p_proj_x)
		return this.p0_to_p_sqrnorm < this.thick0 * this.thick0 * skim.blobtree.KS2;
	if (this.p_proj_x > this.length)
		return this.vector.subVectors(a, this.p1), this.vector.lengthSq() < this.thick1 * this.thick1 * skim.blobtree.KS2;
	a = this.x_p_2D - this.p_proj_x;
	var b = this.y_p_2D - this.p_proj_y,
	c = this.p_proj_x / this.length,
	c = this.thick0 * (1 - c) + c * this.thick1;
	return a * a + b * b < c * c * skim.blobtree.KS2
};
skim.blobtree.AreaSeg.prototype.getAcc = function (a, b) {
	this.proj_computation(a.c);
	var c = this.abs_diff_thick / this.length,
	c = 0.5 * a.r * Math.sqrt(1 + c * c),
	d = this.p_proj_x,
	d = d + (this.thick0 > this.thick1 ? c : -c);
	if (0 > d)
		return this.thick0 * b;
	if (d > this.length)
		return this.thick1 * b;
	c = d / this.length;
	return (this.thick0 * (1 - c) + c * this.thick1) * b
};
skim.blobtree.AreaSeg.prototype.getNiceAcc = function (a) {
	return this.getAcc(a, skim.blobtree.segNiceAccF)
};
skim.blobtree.AreaSeg.prototype.getCurrAcc = function (a) {
	return this.getAcc(a, skim.blobtree.segCurrAccF)
};
skim.blobtree.AreaSeg.prototype.getRawAcc = function (a) {
	return this.getAcc(a, skim.blobtree.segRawAccF)
};
skim.blobtree.AreaSeg.prototype.getMinAcc = function () {
	return skim.blobtree.segCurrAccF * Math.min(this.thick0, this.thick1)
};
skim.blobtree.AreaSeg.prototype.getMinRawAcc = function () {
	return skim.blobtree.segRawAccF * Math.min(this.thick0, this.thick1)
};
skim.blobtree.AreaSeg.prototype.getAxisProjectionMinStep = function (a, b) {
	var c = Number.MAX_VALUE,
	d = this.p0[a] < this.p1[a] ? this.p0 : this.p1,
	e,
	f,
	g;
	d === this.p0 ? (e = this.p1, f = this.thick0, g = this.thick1) : (e = this.p0, f = this.thick1, g = this.thick0);
	var h = b - d[a];
	h < -2 * f ? c = Math.min(c, Math.max(Math.abs(h + 2 * f), skim.blobtree.segCurrAccF * f)) : h < 2 * f && (c = Math.min(c, skim.blobtree.segCurrAccF * f));
	h = b - e[a];
	h < -2 * g ? c = Math.min(c, Math.max(Math.abs(h + 2 * g), skim.blobtree.segCurrAccF * g)) : h < 2 * g && (c = Math.min(c, skim.blobtree.segCurrAccF *
					g));
	h = b - d[a];
	d = e[a] - d[a];
	0 < h && (h < d && 0 !== d) && (c = Math.min(c, skim.blobtree.segCurrAccF * (f + h / d * (g - f))));
	return c
};
skim.blobtree.AreaTri = function (a, b, c, d, e, f) {
	skim.blobtree.Area.call(this);
	this.tmpVect = new THREE.Vector3;
	this.min_thick = e;
	this.max_thick = f;
	this.v = a;
	this.p0p1 = this.tmpVect.clone().subVectors(this.v[1].getPos(), this.v[0].getPos());
	this.p2p0 = this.tmpVect.clone().subVectors(this.v[0].getPos(), this.v[2].getPos());
	this.unit_normal = b;
	this.main_dir = c;
	a = Math.abs(this.v[0].getThickness() - this.v[1].getThickness());
	b = Math.abs(this.v[1].getThickness() - this.v[2].getThickness());
	this.equal_weights = a < skim.geometry.Epsilon &&
		b < skim.geometry.Epsilon;
	this.segParams = d;
	this.segAttr = {
		p0_to_p : 0,
		p0_to_p_sqrnorm : 0,
		x_p_2D : 0,
		y_p_2D : 0,
		y_p_2DSq : 0,
		p_proj_x : 0
	};
	d = this.tmpVect.clone().crossVectors(this.segParams[0].dir, this.unit_normal).normalize();
	a = this.tmpVect.clone().crossVectors(this.segParams[1].dir, this.unit_normal).normalize();
	b = this.tmpVect.clone().crossVectors(this.segParams[2].dir, this.unit_normal).normalize();
	this.tmpVect.copy(this.unit_normal);
	c = [];
	c.push(this.tmpVect.clone().addVectors(this.v[0].getPos(), this.tmpVect.multiplyScalar(this.v[0].getThickness() *
				skim.blobtree.KS)));
	this.tmpVect.copy(this.unit_normal);
	c.push(this.tmpVect.clone().addVectors(this.v[1].getPos(), this.tmpVect.multiplyScalar(this.v[1].getThickness() * skim.blobtree.KS)));
	this.tmpVect.copy(this.unit_normal);
	c.push(this.tmpVect.clone().addVectors(this.v[2].getPos(), this.tmpVect.multiplyScalar(this.v[2].getThickness() * skim.blobtree.KS)));
	this.tmpVect.copy(this.unit_normal);
	c.push(this.tmpVect.clone().addVectors(this.v[0].getPos(), this.tmpVect.multiplyScalar(-this.v[0].getThickness() *
				skim.blobtree.KS)));
	this.tmpVect.copy(this.unit_normal);
	c.push(this.tmpVect.clone().addVectors(this.v[1].getPos(), this.tmpVect.multiplyScalar(-this.v[1].getThickness() * skim.blobtree.KS)));
	this.tmpVect.copy(this.unit_normal);
	c.push(this.tmpVect.clone().addVectors(this.v[2].getPos(), this.tmpVect.multiplyScalar(-this.v[2].getThickness() * skim.blobtree.KS)));
	f = new THREE.Vector3;
	this.tmpVect.subVectors(c[1], c[0]);
	f.subVectors(c[2], c[0]);
	e = this.tmpVect.clone().crossVectors(this.tmpVect, f).normalize();
	this.tmpVect.subVectors(c[5],
		c[3]);
	f.subVectors(c[4], c[3]);
	f = this.tmpVect.clone().crossVectors(this.tmpVect, f).normalize();
	this.planeParams = [];
	this.planeParams.push({
		orig : this.v[0].getPos(),
		n : d
	});
	this.planeParams.push({
		orig : this.v[1].getPos(),
		n : a
	});
	this.planeParams.push({
		orig : this.v[2].getPos(),
		n : b
	});
	this.planeParams.push({
		orig : c[0],
		n : e
	});
	this.planeParams.push({
		orig : c[3],
		n : f
	});
	this.segAreas = [];
	for (d = 0; 3 > d; ++d)
		this.segAreas.push(new skim.blobtree.AreaSeg(this.segParams[d].v[0].getPos(), this.segParams[d].v[1].getPos(), this.segParams[d].v[0].getThickness(),
				this.segParams[d].v[1].getThickness(), this.segParams[d].norm, this.segParams[d].dir))
};
skim.blobtree.AreaTri.prototype = Object.create(skim.blobtree.Area.prototype);
skim.blobtree.AreaTri.prototype.constructor = skim.blobtree.AreaTri;
skim.blobtree.AreaTri.prototype.proj_computation = function (a, b) {
	this.segAttr.p0_to_p = this.tmpVect;
	this.segAttr.p0_to_p.subVectors(a, b.v[0].getPos());
	this.segAttr.p0_to_p_sqrnorm = this.segAttr.p0_to_p.lengthSq();
	this.segAttr.x_p_2D = this.segAttr.p0_to_p.dot(b.dir);
	this.segAttr.y_p_2DSq = this.segAttr.p0_to_p_sqrnorm - this.segAttr.x_p_2D * this.segAttr.x_p_2D;
	this.segAttr.y_p_2D = 0 < this.segAttr.y_p_2DSq ? Math.sqrt(this.segAttr.y_p_2DSq) : 0;
	this.segAttr.p_proj_x = this.segAttr.x_p_2D + -this.segAttr.y_p_2D / b.ortho_vec_y *
		b.ortho_vec_x
};
skim.blobtree.AreaTri.prototype.sphereIntersect = function (a) {
	for (var b = 0; 3 > b; b++)
		if (this.sphereIntersectSegment(a, this.segParams[b], skim.blobtree.KS))
			return !0;
	for (var b = 0, c = !0; 5 > b; b++) {
		this.tmpVect.subVectors(a.c, this.planeParams[b].orig);
		var d = this.tmpVect.dot(this.planeParams[b].n),
		c = c && 0 < d + a.r
	}
	return c
};
skim.blobtree.AreaTri.prototype.sphereIntersectSegment = function (a, b, c) {
	this.proj_computation(a.c, b);
	var d = b.v[0].getThickness(),
	e = b.v[1].getThickness();
	if (0 > this.segAttr.p_proj_x)
		return Math.sqrt(this.segAttr.p0_to_p_sqrnorm) - a.r < d * c;
	if (this.segAttr.p_proj_x > b.norm)
		return this.segAttr.p0_to_p.subVectors(a.c, b.v[1].getPos()), this.segAttr.p0_to_p.length() - a.r < e * c;
	var f = this.segAttr.x_p_2D - this.segAttr.p_proj_x;
	b = this.segAttr.p_proj_x / b.norm;
	a = a.r + (d * (1 - b) + b * e) * c;
	return f * f + this.segAttr.y_p_2DSq < a * a
};
skim.blobtree.AreaTri.prototype.contains = function (a) {
	return this.sphereIntersect({
		r : 0,
		c : a
	})
};
skim.blobtree.AreaTri.prototype.getAccSegment = function (a, b) {
	var c = {
		intersect : !1,
		currAcc : skim.blobtree.triNiceAccF * this.min_thick
	};
	if (this.sphereIntersectSegment(a, b, 1)) {
		var d = Math.abs(b.diffThick) / b.norm,
		e = 0.5 * a.r * Math.sqrt(1 + d * d),
		d = b.v[0].getThickness(),
		f = b.v[1].getThickness(),
		g = this.segAttr.p_proj_x,
		g = g + (d > f ? e : -e);
		0 >= g ? c.currAcc = d : g >= b.norm ? c.currAcc = f : (e = g / b.norm, c.currAcc = d * (1 - e) + e * f);
		c.intersect = !0
	}
	return c
};
skim.blobtree.AreaTri.prototype.getAccTri = function (a) {
	if (this.equal_weights)
		return this.min_thick;
	var b = this.v[0].getPos(),
	c = this.tmpVect.addVectors(a.c, this.main_dir.clone().multiplyScalar(a.r));
	this.tmpVect.subVectors(c, b);
	var c = this.tmpVect.lengthSq(),
	d = this.tmpVect.dot(this.unit_normal),
	c = Math.sqrt(c - d * d);
	a = this.tmpVect.clone().addVectors(a.c, this.unit_normal.clone().multiplyScalar(-d));
	var e = skim.triangleUtils.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), a),
	e = skim.triangleUtils.getMeanThick(this,
			e.u, e.v),
	e = 0 <= d ? e : -e,
	e = this.v[0].getThickness() - e,
	d = c + -d / c * e,
	b = this.tmpVect.subVectors(b, a).normalize(),
	b = this.tmpVect.addVectors(a, b.multiplyScalar(c - d)),
	e = skim.triangleUtils.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), b);
	return 1 >= e.u && 1 >= e.v && 1 >= e.u + e.v && 0 <= e.u && 0 <= e.v ? skim.triangleUtils.getMeanThick(this, e.u, e.v) : skim.geometry.Max
};
skim.blobtree.AreaTri.prototype.getAcc = function (a, b) {
	for (var c = 0, d = skim.geometry.Max; 3 > c; c++) {
		var e = this.getAccSegment(a, this.segParams[c]);
		e.intersect && (d = d > e.currAcc ? e.currAcc : d)
	}
	c = skim.geometry.Max;
	d !== this.min_thick && (c = this.getAccTri(a));
	d = Math.min(d, c);
	return d !== skim.geometry.Max ? d * b : this.max_thick * b
};
skim.blobtree.AreaTri.prototype.getNiceAcc = function (a) {
	return this.getAcc(a, skim.blobtree.triNiceAccF)
};
skim.blobtree.AreaTri.prototype.getCurrAcc = function (a) {
	return this.getAcc(a, skim.blobtree.triCurrAccF)
};
skim.blobtree.AreaTri.prototype.getRawAcc = function (a) {
	return this.getAcc(a, skim.blobtree.triRawAccF)
};
skim.blobtree.AreaTri.prototype.getMinAcc = function () {
	return skim.blobtree.triCurrAccF * this.min_thick
};
skim.blobtree.AreaTri.prototype.getMinRawAcc = function () {
	return skim.blobtree.triRawAccF * this.min_thick
};
skim.blobtree.AreaTri.prototype.getAxisProjectionMinStep = function (a, b) {
	for (var c = Number.MAX_VALUE, d = 0; 3 > d; ++d)
		c = Math.min(c, this.segAreas[d].getAxisProjectionMinStep(a, b));
	return c
};
skim.blobtree.AreaRing = function (a, b, c, d, e, f, g) {
	this.v = a;
	this.rz = b;
	this.theta = c;
	this.constraintsIndices = d;
	this.arcStep = e;
	this.interpolantFunctions = f;
	this.p0 = new THREE.Vector3;
	this.vector = new THREE.Vector3;
	this.p0_to_p = new THREE.Vector3;
	this.rMin = g.rMin;
	this.rMax = g.rMax;
	this.zMax = g.zMax;
	this.zMin = g.zMin;
	this.thickMin = g.thickMin;
	this.thickMax = g.thickMax;
	this.lMax = g.lMax
};
skim.blobtree.AreaRing.prototype.sphereIntersect = function (a) {
	return skim.ringUtils.isSphereInsideCylinders(a.c, a.r, this.rMax, this.rMin, this.zMax, this.zMin, this.thickMax, this.thickMin)
};
skim.blobtree.AreaRing.prototype.contains = function (a) {
	for (var b = new THREE.Vector3(0, 0, 0), c = 0, d = 0, c = skim.geometry.GetXAngleFromPoint(a), e = 1E17, f = 0, g = 0, h = 1E17, k = 1E18, l = 0, m, d = 0; 4 > d; d++)
		m = skim.ringUtils.getRZTFromAngle(this, c, d + 1), m.set(m.x * Math.cos(c), m.x * Math.sin(c), m.y), e > m.x && (e = m.x), f < m.x && (f = m.x), h > m.y && (h = m.y), g < m.y && (g = m.y), m = m.getThickness(), k > m && (k = m), l < m && (l = m);
	b.subVectors(a, this.p0);
	c = b.clone().set(b.x, b.y, 0).length();
	d = b.clone().set(0, 0, b.z).length();
	return c < f + l * skim.blobtree.KS2 && c > e -
	k * skim.blobtree.KS2 ? d < g + l * skim.blobtree.KS2 && d > h - k * skim.blobtree.KS2 : !1
};
skim.blobtree.AreaRing.prototype.getAcc = function (a, b) {
	var c = skim.geometry.GetXAngleFromPoint(a.c),
	d = Math.cos(c),
	e = Math.sin(c),
	f = skim.ringUtils.getRZTFromAngle(this, c, 1),
	g = skim.ringUtils.getRZTFromAngle(this, c, 2),
	h = skim.ringUtils.getRZTFromAngle(this, c, 3),
	c = skim.ringUtils.getRZTFromAngle(this, c, 4),
	k = f.z,
	l = g.z,
	m = h.z,
	n = c.z;
	f.set(f.x * d, f.x * e, f.y);
	g.set(g.x * d, g.x * e, g.y);
	h.set(h.x * d, h.x * e, h.y);
	c.set(c.x * d, c.x * e, c.y);
	d = [];
	d[0] = this.getAccForSegment(a, f, g, k, l);
	d[1] = this.getAccForSegment(a, g, h, l, m);
	d[2] = this.getAccForSegment(a,
			h, c, m, n);
	d[3] = this.getAccForSegment(a, c, f, n, k);
	return Math.min.apply(Math, d) * b
};
skim.blobtree.AreaRing.prototype.getAccForSegment = function (a, b, c, d, e) {
	var f = new THREE.Vector3;
	f.subVectors(c, b);
	b = f.lengthSq();
	c = Math.sqrt(b);
	var g = new THREE.Vector3(f.x, f.y, f.z);
	g.multiplyScalar(1 / c);
	var f = d - e,
	g = this.p0_to_p.dot(g),
	h = a.r * a.r - g * g,
	h =  - (0 < h ? Math.sqrt(h) : 0) / c,
	f = g + h * f,
	h = Math.abs(d - e) / c;
	a = 0.5 * a.r * Math.sqrt(1 + h * h);
	a = f + (d > e ? a : -a);
	if (0 > a)
		return d;
	if (a > b)
		return e;
	a /= b;
	return d * (1 - a) + a * e
};
skim.blobtree.AreaRing.prototype.getNiceAcc = function (a) {
	return this.getAcc(a, skim.blobtree.ringNiceAccF)
};
skim.blobtree.AreaRing.prototype.getCurrAcc = function (a) {
	return this.getAcc(a, skim.blobtree.ringCurrAccF)
};
skim.blobtree.AreaRing.prototype.getRawAcc = function (a) {
	return this.getAcc(a, skim.blobtree.ringRawAccF)
};
skim.blobtree.AreaRing.prototype.getMinAcc = function () {
	return skim.blobtree.segCurrAccF * this.thickMin
};
skim.blobtree.AreaRing.prototype.getMinRawAcc = function () {
	return skim.blobtree.segRawAccF * this.thickMin
};
skim.blobtree.AreaRing.prototype.getAxisProjectionMinStep = function (a, b) {
	var c = Number.MAX_VALUE;
	return b < this.zMin - 2 * this.thickMax ? Math.max(this.zMin - 2 * this.thickMax - b, this.getMinAcc()) : b < this.zMax + 2 * this.thickMax ? this.getMinAcc() : c
};
skim.blobtree.AreaTextRing = function (a, b) {
	this.sdfManager = b;
	this.v = a;
	this.thick = this.v[0].getThickness() || 10;
	this.radius = skim.textUtils.computeRadius(this.v);
	this.height = skim.textUtils.computeHeight(this.v);
	this.zMax = this.height / 2;
	this.zMin = -this.height / 2;
	var c = skim.textUtils.computeLength(this.v);
	this.rMax = this.radius + c / 2;
	this.rMin = this.radius - c / 2;
	this.thickMax = skim.textUtils.computeThickness(this.v);
	this.thickMin = skim.textUtils.computeThickness(this.v);
	this.rMaxTotal = this.rMax + this.thick;
	this.rMinTotal =
		this.rMin - this.thick;
	this.rLengthTotal = c + 2 * this.thick
};
skim.blobtree.AreaTextRing.prototype.sphereIntersect = function (a) {
	var b = skim.textUtils.getDistSq(this.sdfManager, a.c);
	return null !== b ? b < (a.r + this.thick * skim.blobtree.KS) * (a.r + this.thick * skim.blobtree.KS) : skim.ringUtils.isSphereInsideCylinders(a.c, a.r, this.rMax, this.rMin, this.zMax, this.zMin, this.thickMax, this.thickMin)
};
skim.blobtree.AreaTextRing.prototype.contains = function (a) {
	return skim.ringUtils.isInsideCappedCylinders(a, 0, this.rMax, this.rMin, this.zMax, this.zMin, this.thickMax, this.thickMin)
};
skim.blobtree.AreaTextRing.prototype.getNiceAcc = function (a) {
	return this.getAcc(a, skim.blobtree.textringNiceAccF)
};
skim.blobtree.AreaTextRing.prototype.getCurrAcc = function (a) {
	return this.getAcc(a, skim.blobtree.textringCurrAccF)
};
skim.blobtree.AreaTextRing.prototype.getAcc = function (a, b) {
	var c = skim.textUtils.getSdfDist(this.sdfManager, a.c, !0);
	if (null !== c && 0 > c) {
		var d = skim.textUtils.getDepthDist(this.sdfManager, a.c, !0);
		return c * c + d * d < a.r * a.r ? b * this.thick : this.rLengthTotal * skim.blobtree.textringRawOnTopAccF * b
	}
	return b * this.thick
};
skim.blobtree.AreaTextRing.prototype.getRawAcc = function (a) {
	if (this.sphereIntersect(a)) {
		var b = skim.textUtils.getSdfDist(this.sdfManager, a.c, !0);
		if (null !== b && 0 > b) {
			var c = skim.textUtils.getDepthDist(this.sdfManager, a.c, !0),
			b = b * b + c * c,
			c = skim.geometry.computeRadialDist(a.c);
			if (b < a.r * a.r && c - a.r > this.rMinTotal && c + a.r < this.rMaxTotal)
				return 2 * a.r
		}
		return Math.max(this.thick, 0.5 * this.rLengthTotal)
	}
	return 2 * a.r
};
skim.blobtree.AreaTextRing.prototype.getMinAcc = function () {
	return skim.blobtree.textringCurrAccF * Math.min(this.thick, this.rLengthTotal * skim.blobtree.textringRawOnTopAccF)
};
skim.blobtree.AreaTextRing.prototype.getMinRawAcc = function () {
	return skim.blobtree.textringRawAccF * Math.min(this.thick, this.rLengthTotal * skim.blobtree.textringRawOnTopAccF)
};
skim.blobtree.AreaTextRing.prototype.getAxisProjectionMinStep = function (a, b) {
	var c = Number.MAX_VALUE;
	return b < this.zMin - 2 * this.thickMax ? Math.max(this.zMin - 2 * this.thickMax - b, this.getMinAcc()) : b < this.zMax + 2 * this.thickMax ? this.getMinAcc() : c
};
skim.blobtree.AreaText = function (a, b, c) {
	this.sdfManager = b;
	this.aabb = c;
	this.thick = this.sdfManager.thickness;
	this.depthTotal = this.sdfManager.depth + 2 * this.thick;
	this.depthMinTotal = -this.depthTotal / 2;
	this.depthMaxTotal = this.depthTotal / 2
};
skim.blobtree.AreaText.prototype.sphereIntersect = function (a) {
	return this.aabb.sphereIntersect(a)
};
skim.blobtree.AreaText.prototype.contains = function (a) {
	console.error("contains function is never used");
	return !1
};
skim.blobtree.AreaText.prototype.getNiceAcc = function (a) {
	return this.getAcc(a, skim.blobtree.textNiceAccF)
};
skim.blobtree.AreaText.prototype.getCurrAcc = function (a) {
	return this.getAcc(a, skim.blobtree.textCurrAccF)
};
skim.blobtree.AreaText.prototype.getAcc = function (a, b) {
	var c = skim.textUtils.getSdfDist(this.sdfManager, a.c, !0),
	d = skim.textUtils.getDepthDist(this.sdfManager, a.c, !0);
	return null !== c && 0 > c && 0 > d ? c * c + d * d < a.r * a.r ? b * this.thick : this.depthTotal * skim.blobtree.textRawOnTopAccF * b : b * this.thick
};
skim.blobtree.AreaText.prototype.getRawAcc = function (a) {
	if (this.sphereIntersect(a)) {
		var b = skim.textUtils.getSdfDist(this.sdfManager, a.c, !0);
		if (null !== b && 0 > b) {
			var c = skim.textUtils.getDepthDist(this.sdfManager, a.c, !0);
			if (b * b + c * c < a.r * a.r && c - a.r > this.depthMinTotal && c + a.r < this.depthMaxTotal)
				return 2 * a.r
		}
		return Math.max(this.thick, 0.5 * this.depthTotal)
	}
	return 2 * a.r
};
skim.blobtree.AreaText.prototype.getMinAcc = function () {
	return skim.blobtree.textringCurrAccF * Math.min(this.thick, this.depthTotal * skim.blobtree.textRawOnTopAccF)
};
skim.blobtree.AreaText.prototype.getMinRawAcc = function () {
	return skim.blobtree.textringRawAccF * Math.min(this.thick, this.depthTotal * skim.blobtree.textRawOnTopAccF)
};
skim.blobtree.AreaText.prototype.getAxisProjectionMinStep = function (a, b) {
	var c = Number.MAX_VALUE;
	return b < this.aabb.min.z - this.thick ? Math.max(this.aabb.min.z - this.thick - b, this.getMinAcc()) : b < this.aabb.max.z + this.thick ? 0.98 * this.getMinAcc() : c
};
var Trackball = {
	vCalcRotVec : function (a, b, c, d, e) {
		var f = new THREE.Vector3,
		g = new THREE.Vector3;
		f.x = 2 * a / e;
		f.y = 2 * b / e;
		f.z = 1 - f.x * f.x - f.y * f.y;
		0 > f.z ? (a = Math.sqrt(1 - f.z), f.z = 0, f.x /= a, f.y /= a) : f.z = Math.sqrt(f.z);
		g.x = 2 * c / e;
		g.y = 2 * d / e;
		g.z = 1 - g.x * g.x - g.y * g.y;
		0 > g.z ? (a = Math.sqrt(1 - g.z), g.z = 0, g.x /= a, g.y /= a) : g.z = Math.sqrt(g.z);
		c = new THREE.Vector3;
		c.crossVectors(g, f);
		return c
	}
};
var CameraMan = function (a, b) {
	THREE.Object3D.call(this);
	this.name = a;
	this.p_camera = new THREE.PerspectiveCamera(45, 16 / 9, 1, 1E5);
	this.o_camera = new THREE.OrthographicCamera(-100, 100, 100, -100, 1, 1E5);
	this.camera = this.p_camera;
	this.rotNode = new THREE.Object3D;
	this.transNode = new THREE.Object3D;
	this.transNode.add(this.p_camera);
	this.transNode.add(this.o_camera);
	this.rotNode.add(this.transNode);
	this.rotMode = "trackball";
	this.rotcamSpeed = 1;
	this.canvas = b;
	this.max_dist = this.camera.far / 4;
	this.min_dist = this.camera.near;
	this.position_list = [];
	this.getName = function () {
		return this.name
	};
	this.render_required = !1;
	this.renderRequired = function () {
		return this.render_required
	};
	this.renderDone = function () {
		this.render_required = !1
	};
	this.getCamera = function () {
		return this.camera
	};
	this.getCameraType = function () {
		return this.camera.type
	};
	this.setCameraType = function (a, b) {
		switch (a) {
		case "OrthographicCamera":
			this.camera = this.o_camera;
			break;
		case "PerspectiveCamera":
			this.camera = this.p_camera;
			break;
		default:
			skim.utils.assert(!1, "Error : unknown camera type")
		}
		this.centerView(b,
			1);
		this.render_required = !0
	};
	this.setPerspectiveCameraParameters = function (a, b, e, f) {
		this.p_camera.fov = a;
		this.p_camera.aspect = b;
		this.p_camera.near = e;
		this.p_camera.far = f;
		this.p_camera.updateProjectionMatrix();
		this.render_required = !0
	};
	this.setOrthographicCameraParameters = function (a, b, e, f, g, h) {
		this.o_camera.left = a;
		this.o_camera.right = b;
		this.o_camera.top = e;
		this.o_camera.bottom = f;
		this.o_camera.near = g;
		this.o_camera.far = h;
		this.o_camera.updateProjectionMatrix();
		this.render_required = !0
	};
	this.centerView = function (a,
		b) {
		var e = a.getCenter(),
		f = a.getDimensions();
		this.setTarget(e.x, e.y, e.z);
		var e = this.p_camera.fov * Math.PI / 180,
		g = 2 * Math.atan(Math.tan(e / 2) * this.p_camera.aspect),
		e = Math.min(Math.tan(e / 2), Math.tan(g / 2)),
		f = Math.max(Math.max(f.x, f.y), f.z);
		this.setDistToTarget(0.5 * 1.5 * b * f / e);
		e = this.p_camera.aspect;
		1 <= e ? this.setOrthographicCameraParameters(-b * e * f / 2, b * e * f / 2, b * f / 2, -b * f / 2, this.o_camera.near, this.o_camera.far) : this.setOrthographicCameraParameters(-b * f / 2, b * f / 2, b * f / 2 / e,  - (b * f / 2) / e, this.o_camera.near, this.o_camera.far)
	};
	this.attachLightToCamera = function (a, b) {
		this.transNode.add(a);
		this.transNode.add(b)
	};
	this.removeLightFromCamera = function (a, b) {
		this.transNode.remove(a);
		this.transNode.remove(b)
	};
	this.setMinDist = function (a) {
		this.min_dist = a > this.camera.near ? a : this.camera.near
	};
	this.setMaxDist = function (a) {
		this.max_dist = a < this.camera.far / 3 ? a : this.camera.far / 4
	};
	this.setRotMode = function (a) {
		this.rotMode = a
	};
	this.getRotMode = function () {
		return this.rotMode
	};
	this.manualUpdate = function () {
		this.rotNode.updateMatrixWorld();
		this.rotNode.updateMatrix();
		this.transNode.updateMatrixWorld();
		this.transNode.updateMatrix();
		this.camera.updateMatrixWorld();
		this.camera.updateMatrix()
	};
	this.setTarget = function (a, b, e) {
		this.rotNode.position.x = a;
		this.rotNode.position.y = b;
		this.rotNode.position.z = e;
		this.render_required = !0
	};
	this.getTarget = function () {
		return this.rotNode.position
	};
	this.getCameraWorldPosition = function () {
		return this.camera.localToWorld(new THREE.Vector3(0, 0, 0))
	};
	this.getCameraWorldDirection = function () {
		var a = this.camera.localToWorld(new THREE.Vector3(0,
					0, -1)),
		b = this.getCameraWorldPosition();
		return a.sub(b)
	};
	this.getCameraWorldNormal = function () {
		var a = this.camera.localToWorld(new THREE.Vector3(0, 1, 0)),
		b = this.getCameraWorldPosition();
		return a.sub(b)
	};
	this.getCameraWorldBinormal = function () {
		var a = this.camera.localToWorld(new THREE.Vector3(1, 0, 0)),
		b = this.getCameraWorldPosition();
		return new THREE.Vector3(a.x - b.x, a.y - b.y, a.z - b.z)
	};
	this.setDistToTarget = function (a) {
		this.transNode.position.z = a < this.min_dist ? this.min_dist : a > this.max_dist ? this.max_dist : a;
		this.render_required =
			!0
	};
	this.getDistToTarget = function () {
		return this.transNode.position.z
	};
	this.getPosition = function () {
		return {
			rotNode : {
				px : this.rotNode.position.x,
				py : this.rotNode.position.y,
				pz : this.rotNode.position.z,
				rx : this.rotNode.rotation.x,
				ry : this.rotNode.rotation.y,
				rz : this.rotNode.rotation.z
			},
			distToTarget : this.getDistToTarget()
		}
	};
	this.setPosition = function (a) {
		this.rotNode.position.x = a.rotNode.px;
		this.rotNode.position.y = a.rotNode.py;
		this.rotNode.position.z = a.rotNode.pz;
		this.rotNode.rotation.x = a.rotNode.rx;
		this.rotNode.rotation.y =
			a.rotNode.ry;
		this.rotNode.rotation.z = a.rotNode.rz;
		this.setDistToTarget(a.distToTarget)
	};
	this.pushPosition = function () {
		this.position_list.push(this.getPosition())
	};
	this.popPosition = function () {
		var a = this.position_list.pop();
		this.setPosition(a)
	};
	this.setRotSpeed = function (a) {
		this.rotcamSpeed = a
	};
	this.getRotSpeed = function () {
		return this.rotcamSpeed
	};
	this.resetOrientation = function () {
		this.rotNode.rotation.x = 0;
		this.rotNode.rotation.y = 0;
		this.rotNode.rotation.z = 0;
		this.render_required = !0
	};
	this.zoomTarget = function (a) {
		switch (this.getCameraType()) {
		case "OrthographicCamera":
			var b =
				0.5 * a * (this.o_camera.right - this.o_camera.left);
			this.o_camera.left += b;
			this.o_camera.right -= b;
			a = 0.5 * a * (this.o_camera.bottom - this.o_camera.top);
			this.o_camera.top += a;
			this.o_camera.bottom -= a;
			this.o_camera.updateProjectionMatrix();
			break;
		case "PerspectiveCamera":
			this.setDistToTarget((1 - a) * this.transNode.position.z);
			break;
		default:
			skim.utils.assert(!1, "Error : unknown camera type")
		}
		this.render_required = !0
	};
	this.zoomPoint = function (a, b) {
		switch (this.getCameraType()) {
		case "OrthographicCamera":
			var e = 0.5 * a * (this.o_camera.right -
					this.o_camera.left);
			this.o_camera.left += e;
			this.o_camera.right -= e;
			e = 0.5 * a * (this.o_camera.bottom - this.o_camera.top);
			this.o_camera.top += e;
			this.o_camera.bottom -= e;
			this.o_camera.updateProjectionMatrix();
			break;
		case "PerspectiveCamera":
			var e = (new THREE.Vector3).subVectors(b, this.getTarget()),
			e = VectorUtils.newLinearVect(this.getTarget(), e, a),
			f = this.getDistToTarget(),
			g = (1 - a) * f;
			this.setDistToTarget((1 - a) * f);
			this.getDistToTarget() != g ? this.setDistToTarget(f) : this.setTarget(e.x, e.y, e.z);
			break;
		default:
			skim.utils.assert(!1,
				"Error : unknown camera type")
		}
		this.render_required = !0
	};
	this.prepareRotation = function (a, b) {
		switch (this.rotMode) {
		case "basic":
		case "trackball":
			this.Xp = a;
			this.Yp = b;
			break;
		case "superball":
			this.Xp = a,
			this.Yp = b,
			this.rotMatp = new THREE.Vector3(this.rotNode.rotation.x, this.rotNode.rotation.y, this.rotNode.rotation.z)
		}
	};
	this.rotateFromMouse = function (a, b) {
		switch (this.rotMode) {
		case "basic":
			var e = 0.4 * (a - this.Xp),
			f = 0.4 * (this.Yp - b);
			ObjectUtils.rotateObjectAroundAxis(this.rotNode, new THREE.Vector3(0, 1, 0), -Math.PI *
				e / 180);
			ObjectUtils.rotateObjectAroundAxis(this.rotNode, new THREE.Vector3(1, 0, 0), Math.PI * f / 180);
			this.Xp = a;
			this.Yp = b;
			break;
		case "trackball":
			var e = this.canvas.width,
			f = this.canvas.height,
			g = Math.min(f, e),
			e = Trackball.vCalcRotVec(a - 0.5 * e, f - b - 0.5 * f, this.Xp - 0.5 * e, f - this.Yp - 0.5 * f, g),
			f = 2 * e.length();
			e.normalize();
			ObjectUtils.rotateObjectAroundAxis(this.rotNode, new THREE.Vector3(-e.x, -e.y, -e.z), f);
			this.Xp = a;
			this.Yp = b;
			break;
		case "superball":
			if (this.rotNode.rotation.x = this.rotMatp.x, this.rotNode.rotation.y = this.rotMatp.y,
				this.rotNode.rotation.y = this.rotMatp.y, this.rotNode.updateMatrix(), e = this.canvas.width, f = this.canvas.height, g = Math.min(f, e), f = new THREE.Vector3((a - this.Xp) / g, (this.Yp - b) / g, 0), 0 !== f.x || 0 !== f.y)
				g = f.length() * Math.PI, e = new THREE.Vector3, e.crossVectors(f, new THREE.Vector3(0, 0, 1)), e.normalize(), ObjectUtils.rotateObjectAroundAxis(this.rotNode, e, g)
		}
		this.render_required = !0
	};
	this.rotateAxis = function (a, b) {
		ObjectUtils.rotateObjectAroundAxis(this.rotNode, a, b)
	};
	this.getRay = function (a, b) {
		var e = new THREE.Vector3(0,
				0, -1);
		e.x = 2 * (a / this.canvas.width) - 1;
		e.y = 2 *  - (b / this.canvas.height) + 1;
		var f = e.clone();
		f.unproject(this.camera);
		e.z = 1;
		e.unproject(this.camera);
		e = (new THREE.Vector3).subVectors(e, f);
		e.normalize();
		return new skim.Ray(f, e)
	};
	this.dispose = function () {
		this.transNode.remove(this.p_camera);
		this.transNode.remove(this.o_camera);
		this.rotNode.remove(this.transNode)
	}
};
CameraMan.prototype = Object.create(THREE.Object3D.prototype);
var VectorUtils = {
	newLinearVect : function (a, b, c) {
		return new THREE.Vector3(a.x + c * b.x, a.y + c * b.y, a.z + c * b.z)
	},
	setLinearVect : function (a, b, c, d) {
		a.set(b.x + d * c.x, b.y + d * c.y, b.z + d * c.z)
	},
	setWeightedMean : function (a, b, c, d, e) {
		a.set(b.x * d + c.x * e, b.y * d + c.y * e, b.z * d + c.z * e);
		a.multiplyScalar(1 / (d + e))
	},
	rotateAroundAxis : function (a, b, c) {
		var d = new THREE.Matrix4;
		d.makeRotationAxis(b.normalize(), c);
		a.applyMatrix4(d)
	}
};
THREE.Vector4.prototype.sphereAABB = function () {
	return new THREE.Box3(new THREE.Vector3(this.x - this.w, this.y - this.w, this.z - this.w), new THREE.Vector3(this.x + this.w, this.y + this.w, this.z + this.w))
};
THREE.Vector3.prototype.toVec2 = function () {
	return new THREE.Vector2(this.x, this.y)
};
THREE.Vector3.prototype.toGlsl = function () {
	return "vec3(" + this.x.toFixed(4) + "," + this.y.toFixed(4) + "," + this.z.toFixed(4) + ")"
};
THREE.Vector4.prototype.addVectors = function (a, b) {
	this.x = a.x + b.x;
	this.y = a.y + b.y;
	this.z = a.z + b.z;
	this.w = a.w + b.w;
	return this
};
THREE.Vector4.prototype.toGlsl = function () {
	return "vec4(" + this.x.toFixed(4) + "," + this.y.toFixed(4) + "," + this.z.toFixed(4) + "," + this.w.toFixed(4) + ")"
};
THREE.Vector3.prototype.operatorCompare = function (a, b) {
	this.set(b(this.x, a.x), b(this.y, a.y), b(this.z, a.z))
};
THREE.Vector2.prototype.operatorCompare = function (a, b) {
	this.set(b(this.x, a.x), b(this.y, a.y))
};
THREE.Vector2.prototype.isLeftSide = function (a, b) {
	var c = (new THREE.Vector3(b.x - a.x, b.y - a.y, 0)).normalize(),
	d = (new THREE.Vector3(this.x - a.x, this.y - a.y, 0)).normalize();
	return 0 < (new THREE.Vector3).crossVectors(c, d).z
};
THREE.Box3.prototype.render = function (a, b) {
	for (var c = new THREE.LineBasicMaterial({
				color : 255,
				opacity : 1,
				linewidth : 3
			}), d = new THREE.Geometry, e = new THREE.Vector3(this.min.x, this.min.y, this.min.z), f = 0; 3 > f; f++)
		d.vertices.push(e.clone()), e[f] = this.max[f];
	for (f = 0; 3 > f; f++)
		d.vertices.push(e.clone()), e[f] = this.min[f];
	c = new THREE.Line(d, c);
	d = new THREE.Scene;
	d.add(c);
	a.render(d, b)
};
var makeTileGeom = function (a, b) {
	var c = new THREE.Geometry,
	d = new THREE.Vector3(a.x, a.y, 0),
	e = new THREE.Vector3(b.x, a.y, 0),
	f = new THREE.Vector3(b.x, b.y, 0),
	g = new THREE.Vector3(a.x, b.y, 0);
	c.vertices.push(d);
	c.vertices.push(e);
	c.vertices.push(f);
	c.vertices.push(g);
	c.faces.push(new THREE.Face3(0, 1, 2));
	c.faces.push(new THREE.Face3(0, 2, 3));
	return c
};
THREE.Box2.prototype.isIntersectionHull = function (a) {
	for (var b = [(new THREE.Vector2).set(this.min.x, this.min.y), (new THREE.Vector2).set(this.min.x, this.max.y), (new THREE.Vector2).set(this.max.x, this.max.y), (new THREE.Vector2).set(this.max.x, this.min.y)], c = [(new THREE.Vector2).set(1, 0), (new THREE.Vector2).set(0, 1)], d, e, f = 0; 2 > f; f++)
		if (d = projectPointsOnAxis(b, c[f]), e = projectPointsOnAxis(a, c[f]), d.max < e.min || d.min > e.max)
			return !1;
	for (c = 0; c < a.length - 1; c++)
		if (e = (new THREE.Vector2(a[c].y - a[c + 1].y, a[c + 1].x -
					a[c].x)).normalize(), d = projectPointsOnAxis(b, e), e = projectPointsOnAxis(a, e), d.max < e.min || d.min > e.max)
			return !1;
	return !0
};
var projectPointsOnAxis = function (a, b) {
	for (var c = a[0].dot(b), d = {
			min : c,
			max : c
		}, e = 1; e < a.length; e++)
		c = a[e].dot(b), c < d.min ? d.min = c : c > d.max && (d.max = c);
	return d
}, projectSetOfHullsOnScreen = function (a, b, c) {
	var d = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3],
	e = [],
	f = new THREE.Vector3,
	g = new THREE.Vector3,
	h = new THREE.Vector3,
	k = [];
	new THREE.Vector2;
	for (var l = 0; l < a.length; l++) {
		h.subVectors(a[l].pointB, a[l].pointA);
		f.copy(a[l].expendingVector);
		g.crossVectors(a[l].expendingVector, h).normalize();
		d[0].copy(a[l].pointA).add(f).add(g);
		d[1].copy(a[l].pointA).add(f).sub(g);
		d[2].copy(a[l].pointA).sub(f).sub(g);
		d[3].copy(a[l].pointA).sub(f).add(g);
		d[4].copy(a[l].pointB).add(f).add(g);
		d[5].copy(a[l].pointB).add(f).sub(g);
		d[6].copy(a[l].pointB).sub(f).sub(g);
		d[7].copy(a[l].pointB).sub(f).add(g);
		for (k = 0; 8 > k; k++)
			e[k] = d[k].project(c).toVec2();
		k = computeConvexHull(e);
		b.push(k.slice(0))
	}
}, computeConvexHull = function (a) {
	for (var b =
			[], c = new THREE.Vector2, d = a[0].x, e = 0, f = 1; f < a.length; f++)
		a[f].x < d && (d = a[f].x, e = f);
	b.push(a[e]);
	e = 0;
	do {
		c.copy(a[0]);
		for (d = 0; d < a.length; d++)
			(c.equals(b[e]) || a[d].isLeftSide(b[e], c)) && c.copy(a[d]);
		e++;
		b[e] = c.clone()
	} while (!c.equals(b[0]));
	return b
};
var Overlays = function () {
	this.overlaysScene = new THREE.Scene;
	this.overlaysCam = new THREE.Camera;
	this.overlaysScene.add(this.overlaysCam);
	this.addElement = function (a) {
		this.overlaysScene.add(a)
	};
	this.removeElement = function (a) {
		this.overlaysScene.remove(a)
	};
	this.render = function (a) {
		a.render(this.overlaysScene, this.overlaysCam)
	}
};
var ObjectUtils = {
	rotateObjectAroundAxis : function (a, b, c) {
		var d = new THREE.Matrix4;
		d.makeRotationAxis(b.normalize(), c);
		a.updateMatrixWorld();
		a.updateMatrix();
		a.matrix.multiply(d);
		a.rotation.setFromRotationMatrix(a.matrix)
	}
};
function CylinderAB(a) {
	this.pointA = a.pointA;
	this.pointB = a.pointB;
	this.radius = a.radius
}
function ConeAB(a) {
	this.pointA = a.pointA;
	this.pointB = a.pointB
}
CylinderAB.prototype = {
	computeOBB : function () {
		var a = (new THREE.Vector3).crossVectors(this.axis, new THREE.Vector3(0, 1, 0));
		1E-4 > a.lengthSq && a.crossVectors(this.axis, new THREE.Vector3(1, 0, 0));
		this.expendingVector = a;
		return this
	},
	formatVTtheta : function (a, b, c) {
		this.v = this.pointA;
		this.axis = b;
		this.inf = 0;
		this.sup = a;
		return this
	}
};
ConeAB.prototype = {
	computeOBB : function () {
		var a = (new THREE.Vector3).crossVectors(this.axis, new THREE.Vector3(0, 1, 0));
		1E-4 > a.lengthSq && a.crossVectors(this.axis, new THREE.Vector3(1, 0, 0));
		this.radius = Math.max(Math.max(this.pointA.w, this.pointB.w));
		this.expendingVector = a.normalize();
		return this
	},
	formatVTtheta : function (a, b, c, d) {
		var e = this.pointB.w * a / d;
		this.v = new THREE.Vector3(this.pointB.x + e * b.x, this.pointB.y + e * b.y, this.pointB.z + e * b.z);
		0 < d ? (this.axis = new THREE.Vector3(-b.x, -b.y, -b.z), this.inf = Math.abs(e),
			this.sup = this.inf + a) : (this.axis = b, this.sup = Math.abs(e), this.inf = this.sup - a);
		this.ctheta = 1 / Math.sqrt(1 + c * c);
		return this
	}
};
ConeAB.scaleConeThickness = function (a, b) {
	return Math.cos(Math.atan(b * Math.tan(Math.acos(a))))
};
THREE.Vector4.prototype.computeOBB = function () {
	this.expendingVector = new THREE.Vector3(0, 0, 1);
	var a = (new THREE.Vector3(1, 0, 0)).multiplyScalar(this.w);
	this.radius = this.w;
	this.pointA = (new THREE.Vector3(this.x, this.y, this.z)).sub(a);
	this.pointB = (new THREE.Vector3(this.x, this.y, this.z)).add(a);
	return this
};
skim.file = {
	states : [],
	firstStateIndex : 0,
	max_states : 50,
	state_index : 0,
	lastSavedStateIndex : -1,
	localStorageFileKey : "skimlab-code",
	saveState : function () {
		console.log("%c saving state " + this.state_index, "background: #CD7300; color: #000");
		var a = skim.engine.getJSON();
		this.states[this.state_index++] = a;
		this.states.length = this.state_index;
		if (this.state_index - 1 > this.firstStateIndex + this.max_states) {
			for (var b = this.state_index - 1 - this.max_states, c = this.firstStateIndex; c < b; c++)
				this.states[c] = null;
			this.firstStateIndex =
				b
		}
		this.storeInLocalStorage(a)
	},
	restoreLastState : function () {
		this.state_index > this.firstStateIndex + 1 && (this.state_index--, console.log("%c restoring state " + (this.state_index - 1), "background: #CD7300; color: #000"), console.log(this.states[this.state_index - 1]), skim.engine.loadJSON(this.states[this.state_index - 1]))
	},
	restoreNextState : function () {
		this.state_index < this.states.length && (console.log("%c restoring state " + this.state_index, "background: #CD7300; color: #000"), skim.engine.loadJSON(this.states[this.state_index++]))
	},
	isSaved : function () {
		return this.lastSavedStateIndex == this.state_index - 1
	},
	notifySave : function () {
		this.lastSavedStateIndex = this.state_index - 1;
		this.deleteLocalStorage()
	},
	storeInLocalStorage : function (a) {
		window.localStorage && window.localStorage.setItem(this.localStorageFileKey, JSON.stringify(a))
	},
	loadFromLocalStorage : function () {
		if (this.hasLocalStorage())
			return window.localStorage.getItem(this.localStorageFileKey)
	},
	deleteLocalStorage : function () {
		window.localStorage && (console.log("removing the local storage"),
			window.localStorage.removeItem(this.localStorageFileKey))
	},
	hasLocalStorage : function () {
		return window.localStorage && window.localStorage.getItem(this.localStorageFileKey)
	},
	standardConfirm : function (a, b) {
		var c = window.confirm("We have a backup file that you didn't save. Would you like to load it ?");
		b(c)
	},
	promptLocalStorage : function (a, b, c, d) {
		var e = c || function () {};
		console.log("prompting the local storage");
		if (this.hasLocalStorage()) {
			console.log("there's a local storage");
			c = "We have a backup file that you didn't save. Would you like to load it ?";
			null !== a && void 0 !== a & "" !== a && (c = a);
			var f = d || function () {};
			(b || this.standardConfirm)(c, function (a) {
				a ? f(JSON.parse(skim.file.loadFromLocalStorage())) : e()
			})
		} else
			e()
	},
	manageUnloadEvents : function (a) {
		var b = "You did not save your file!";
		null !== a && void 0 !== a & "" !== a && (b = a);
		window.onbeforeunload = function () {
			if (!skim.file.isSaved())
				return b
		};
		window.onunload = function () {
			skim.instances.modeler.dispose();
			skim.file.deleteLocalStorage()
		}
	}
};
skim.engine = {
	functorPrecision : 1E-4,
	symmetry : {
		x : !0,
		y : !1,
		z : !1
	},
	getSymmetries : function () {
		return JSON.parse(JSON.stringify(this.symmetry))
	},
	setSymmetries : function (a) {
		for (var b = Object.keys(a), c = 0; c < b.length; ++c)
			this.symmetry[b[c]] = a[b[c]];
		skim.instances.modeler.pageInterface.showSymmetries(this.symmetry)
	},
	adjust_functors : {},
	vars : {
		vertices : {},
		primitives : {},
		relations : {}

	},
	materialInfos : {
		print_wall : 5,
		print_detail : 3
	},
	setMaterialInfos : function (a) {
		skim.utils.assert(void 0 !== a.print_wall && void 0 !== a.print_detail,
			"Error : material infos must define all parameters");
		this.materialInfos = a
	},
	getMaterialInfos : function () {
		return this.materialInfos
	},
	init_vars : function () {
		this.vars = {
			vertices : {},
			primitives : {},
			relations : {}

		};
		0 === skim.instances.modeler.meshManager.getBlobtrees().length && skim.instances.modeler.meshManager.add(new skim.blobtree.Root)
	},
	init : function (a) {
		this.init_vars();
		if (void 0 !== a.adjust_functors)
			for (var b = Object.keys(a.adjust_functors), c = 0; c < b.length; ++c)
				skim.utils.assert(void 0 === this.adjust_functors[b[c]],
					"Error : sim.engine.init : weveral adjust_functors have the same name."), this.adjust_functors[b[c]] = a.adjust_functors[b[c]]
	},
	clean : function () {
		this.reset();
		this.adjust_functors = {}

	},
	getJSON : function (a) {
		for (var b = {
				version : 1,
				vertices : [],
				primitives : {},
				relations : {
					v : {},
					p : {}

				}
			}, c = {}, d = {}, e = Object.keys(this.vars.vertices), f = 0; f < e.length; ++f) {
			var g = this.vars.vertices[e[f]];
			b.vertices[f] = g.getJSON(a);
			c[g.id] = f
		}
		e = Object.keys(this.vars.primitives);
		for (f = 0; f < e.length; ++f)
			g = this.vars.primitives[e[f]], void 0 === b.primitives[g.getJSONKey()] &&
			(b.primitives[g.getJSONKey()] = []), b.primitives[g.getJSONKey()].push(g.getJSON(b.vertices, c, a)), d[g.id] = b.primitives[g.getJSONKey()].length - 1;
		a = Object.keys(this.vars.relations);
		for (f = 0; f < a.length; ++f) {
			var e = this.vars.relations[a[f]],
			g = e.getJSONKey(),
			h = e instanceof skim.engine.linkFunctors.VertexVirtualLinkFunctor ? "v" : "p";
			void 0 === b.relations[h][g] && (b.relations[h][g] = []);
			b.relations[h][g].push(e.getJSON(b.vertices, b.primitives, c, d))
		}
		return b
	},
	loadJSON : function (a) {
		this.reset();
		if (a.vertices && a.primitives &&
			a.relations) {
			for (var b = [], c = 0; c < a.vertices.length; ++c)
				b.push(skim.engine.VertexDef.buildFromJSON(a.vertices[c]));
			for (var d = {}, e = Object.keys(a.primitives), f = 0; f < e.length; ++f) {
				var g = e[f];
				d[g] = [];
				for (c = 0; c < a.primitives[g].length; ++c) {
					var h = skim.engine.PrimitiveDef.RegisterJSONKey[g];
					skim.utils.assert(void 0 !== h, "Error : unknown type key " + g + " Cannot load primitive.");
					d[g].push(h(a.primitives[g][c], b))
				}
			}
			e = Object.keys(a.relations.v);
			for (f = 0; f < e.length; ++f)
				for (g = e[f], c = 0; c < a.relations.v[g].length; ++c)
					h =
						skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[g], skim.utils.assert(void 0 !== h, "Error : unknown type key " + g + " Cannot load link."), h(a.relations.v[g][c], b, d);
			e = Object.keys(a.relations.p);
			for (f = 0; f < e.length; ++f)
				for (g = e[f], c = 0; c < a.relations.p[g].length; ++c)
					h = skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[g], skim.utils.assert(void 0 !== h, "Error : unknown type key " + g + " Cannot load link."), h(a.relations.p[g][c], b, d);
			this.update_skeleton();
			this.update_blobtree();
			this.update_parametrics()
		}
	},
	reset : function () {
		skim.instances.skel && skim.instances.skel.clean();
		skim.instances.modeler && (skim.instances.skel && skim.instances.modeler.meshManager) && (0 !== skim.instances.modeler.meshManager.getBlobtrees().length && this.update_blobtree(), this.update_parametrics());
		skim.instances.modeler && skim.instances.modeler.meshManager && (skim.instances.modeler.meshManager.remove(skim.instances.modeler.meshManager.getBlobtrees()[0]), this.init_vars());
		skim.instances.modeler && skim.instances.modeler.sceneManager && skim.instances.modeler.sceneManager.setShowSurface(!1)
	},
	getVertexById : function (a) {
		return void 0 !== this.vars.vertices[a] ? this.vars.vertices[a] : null
	},
	getPrimitiveById : function (a) {
		return void 0 !== this.vars.primitives[a] ? this.vars.primitives[a] : null
	},
	getPrimitiveByName : function (a) {
		for (var b = Object.keys(this.vars.primitives), c = 0; c < b.length; ++c) {
			var d = this.vars.primitives[b[c]];
			if (d.name === a)
				return d
		}
		return null
	},
	getSymConstrainsForGroup : function (a) {
		for (var b = {
				x : !1,
				y : !1,
				z : !1
			}, c = Object.keys(a), d = 0; d < c.length; ++d)
			for (var e = this.vars.vertices[c[d]], f = e.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis),
				g = 0; g < f.length; ++g) {
				var h = f[g].getSym(e);
				void 0 !== a[h.id] && (b[f[g].a] = !0)
			}
		return b
	},
	processVertices : function (a, b) {
		for (var c = Object.keys(b || this.vars.vertices), d = 0; d < c.length; d++)
			a(this.vars.vertices[c[d]])
	},
	removeAllVertexSymmetries : function () {
		for (var a = Object.keys(this.vars.vertices), b = 0; b < a.length; b++) {
			var c = this.vars.vertices[a[b]];
			if (void 0 !== c)
				for (var c = c.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis), d = 0; d < c.length; ++d)
					c[d].destroy()
		}
	},
	close_to_axis : function (a, b) {
		var c = b /
			3;
		return -c < a.x && a.x < c
	},
	getVSymLinks : function (a) {
		a = a.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis);
		for (var b = {
				x : null,
				y : null,
				z : null
			}, c = 0; c < a.length; ++c)
			b[a[c].getAxis()] = a[c];
		return b
	},
	getVArrSym : function (a, b) {
		if (null !== a && void 0 !== a) {
			var c = this.getVertexById(a.id),
			d = {};
			this.getVArrSymDef(c, d);
			for (var c = Object.keys(d), e = 0; e < c.length; e++)
				b[d[c[e]].id] = d[c[e]].getReactor()
		}
		return b
	},
	getVArrSymDef : function (a, b) {
		null !== a && void 0 !== a && (a.getSyms({}, b), delete b[a.id]);
		return b
	},
	getPArrSym : function (a,
		b) {
		if (null !== a && void 0 !== a) {
			var c = this.getPrimitiveById(a.id),
			d = {};
			this.getPArrSymDef(c, d);
			for (var c = Object.keys(d), e = 0; e < c.length; e++)
				b[d[c[e]].id] = d[c[e]].getReactor()
		}
		return b
	},
	getPArrSymDef : function (a, b) {
		null !== a && void 0 !== a && (a.getSyms({}, b), delete b[a.id]);
		return b
	},
	hasOwnersRings : function (a) {
		if (null !== a && void 0 !== a)
			return this.getVertexById(a.id).hasOwnersRings()
	},
	getSegSymLinks : function (a) {
		a = a.getLinkFunctorByClass(skim.engine.linkFunctors.SegPlaneSymmetryAxis);
		for (var b = {
				x : null,
				y : null,
				z : null
			},
			c = 0; c < a.length; ++c)
			b[a[c].getAxis()] = a[c];
		return b
	},
	getTriSymLinks : function (a) {
		a = a.getLinkFunctorByClass(skim.engine.linkFunctors.TriPlaneSymmetryAxis);
		for (var b = {
				x : null,
				y : null,
				z : null
			}, c = 0; c < a.length; ++c)
			b[a[c].getAxis()] = a[c];
		return b
	},
	addVertexPlaneSymProcess : function (a, b, c, d, e, f) {
		if (null === f.v[e]) {
			var g = d[a.v.id].clone();
			g[e] = 0 === g[e] ? 1 : 0;
			g = c[g.getKey()];
			f.v[e] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.v, void 0 !== g ? g.v : null, e)
		}
		if (null !== f.v[e]) {
			var h = d[a.v.id].clone();
			h[e] = 0 === h[e] ? 1 : 0;
			g = c[h.getKey()];
			void 0 === g && (g = {
					v : f.v[e].getSym(a.v)
				}, d[g.v.id] = h, c[h.getKey()] = g);
			b[g.v.id] = {
				v : g.v
			}
		}
	},
	addVertex : function (a, b, c, d, e, f) {
		a = new skim.engine.VertexDef(new THREE.Vector3(a, b, c), d, e, f);
		a.commit();
		b = a;
		c = {};
		d = {};
		d[b.id] = {
			v : b
		};
		e = {};
		f = {};
		f[b.id] = this.addSegGetFirstTopoPos(b);
		e[f[b.id].getKey()] = {
			v : b
		};
		for (var g = Object.keys(d), h = ["x", "y", "z"]; 0 !== g.length; ) {
			var k = d[g[0]];
			b = k.v;
			if (void 0 === c[b.id]) {
				for (var l = {
						v : this.getVSymLinks(k.v)
					}, m = 0; m < h.length; m++)
					this.symmetry[h[m]] && this.addVertexPlaneSymProcess(k,
						d, e, f, h[m], l);
				c[b.id] = b
			}
			delete d[g[0]];
			g = Object.keys(d)
		}
		return a
	},
	getVertexSymmetries : function (a) {
		var b = {};
		a = a.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis);
		for (var c = 0; c < a.length; ++c)
			b[a[c].getAxis()] = a[c];
		return b
	},
	getPrimitiveSymmetries : function (a) {
		var b = null,
		c = {},
		b = [];
		a instanceof skim.engine.SegmentDef ? (b = skim.engine.linkFunctors.SegPlaneSymmetryAxis, b = a.getLinkFunctorByClass(b)) : a instanceof skim.engine.TriangleDef ? (b = skim.engine.linkFunctors.TriPlaneSymmetryAxis, b = a.getLinkFunctorByClass(b)) :
		a instanceof skim.engine.RingDef ? (b = skim.engine.linkFunctors.RingPlaneSymmetryAxis, b = a.getLinkFunctorByClass(b)) : skim.utils.assert(!1, "Error : cannot get symmetries for this type of primitive (not implemented)");
		for (a = 0; a < b.length; ++a)
			c[b[a].getAxis()] = b[a];
		return c
	},
	getRingSymmetries : function (a) {
		return this.getPrimitiveSymmetries(a)
	},
	splitTriangle : function (a, b, c) {
		var d = {
			vnew : null,
			t1 : null,
			t2 : null,
			t3 : null,
			edge : skim.engine.TriEdge.E_NONE
		},
		e = a.v[0],
		f = a.v[1],
		g = a.v[2],
		h = (new THREE.Vector3).subVectors(f.getPos(),
			e.getPos()),
		k = (new THREE.Vector3).subVectors(g.getPos(), e.getPos());
		skim.utils.assert(a instanceof skim.engine.TriangleDef, "Error : splitTriangleDef can only operate on a triangle...");
		var l = null,
		m = null,
		m = function (a, b, c, d, f) {
			l = skim.triangleUtils.getParametrisedVertexAttr(a, b, c);
			a = l.pos;
			b = (new THREE.Vector3).subVectors(f.getPos(), d.getPos());
			c = b.length();
			b.normalize();
			var g = (new THREE.Vector3).subVectors(l.pos, d.getPos()).dot(b),
			g = Math.max(Math.min(g, c - f.getThickness()), d.getThickness());
			a.copy(b).multiplyScalar(g).add(d.getPos());
			return skim.triangleUtils.getUVCoord(h, k, e.getPos(), a)
		},
		n = this.getTriSymLinks(a),
		p = {
			x : this.symmetry.x,
			y : this.symmetry.y,
			z : this.symmetry.z
		};
		this.setSymmetries({
			x : null !== n.x,
			y : null !== n.y,
			z : null !== n.z
		});
		0 >= c ? (c = m(a, b, c, e, f), b = c.u, c = c.v, n = skim.triangleUtils.getMeanMat(a, b, c), l = skim.triangleUtils.getParametrisedVertexAttr(a, b, c), d.vnew = skim.engine.addVertex(l.pos.x, l.pos.y, l.pos.z, l.thick, n.clone(), a.getVolType()), m = null === a.materials ? null : [a.materials[1].clone(), a.materials[2].clone(), n.clone()], d.t1 =
				skim.engine.addTriangle(f, g, d.vnew, m, a.getVolType()), m = null === a.materials ? null : [a.materials[2].clone(), a.materials[0].clone(), n.clone()], d.t2 = skim.engine.addTriangle(g, e, d.vnew, m, a.getVolType()), d.edge = skim.engine.TriEdge.E_P0P1) : 0 <= b + c - 1 ? (c = m(a, b, c, f, g), b = c.u, c = c.v, n = skim.triangleUtils.getMeanMat(a, b, c), l = skim.triangleUtils.getParametrisedVertexAttr(a, b, c), d.vnew = skim.engine.addVertex(l.pos.x, l.pos.y, l.pos.z, l.thick, n.clone(), a.getVolType()), m = null === a.materials ? null : [a.materials[0].clone(), a.materials[1].clone(),
					n.clone()], d.t1 = skim.engine.addTriangle(e, f, d.vnew, m, a.getVolType()), m = null === a.materials ? null : [a.materials[2].clone(), a.materials[0].clone(), n.clone()], d.t2 = skim.engine.addTriangle(g, e, d.vnew, m, a.getVolType()), d.edge = skim.engine.TriEdge.E_P1P2) : 0 >= b ? (c = m(a, b, c, g, e), b = c.u, c = c.v, n = skim.triangleUtils.getMeanMat(a, b, c), l = skim.triangleUtils.getParametrisedVertexAttr(a, b, c), d.vnew = skim.engine.addVertex(l.pos.x, l.pos.y, l.pos.z, l.thick, n.clone(), a.getVolType()), m = null === a.materials ? null : [a.materials[0].clone(),
					a.materials[1].clone(), n.clone()], d.t1 = skim.engine.addTriangle(e, f, d.vnew, m, a.getVolType()), m = null === a.materials ? null : [a.materials[1].clone(), a.materials[2].clone(), n.clone()], d.t2 = skim.engine.addTriangle(f, g, d.vnew, m, a.getVolType()), d.edge = skim.engine.TriEdge.E_P2P0) : (n = skim.triangleUtils.getMeanMat(a, b, c), l = skim.triangleUtils.getParametrisedVertexAttr(a, b, c), d.vnew = skim.engine.addVertex(l.pos.x, l.pos.y, l.pos.z, l.thick, n.clone(), a.getVolType()), d.vnew.commit(), m = null === a.materials ? null : [a.materials[0].clone(),
					a.materials[1].clone(), n.clone()], d.t1 = skim.engine.addTriangle(e, f, d.vnew, m, a.getVolType()), m = null === a.materials ? null : [a.materials[1].clone(), a.materials[2].clone(), n.clone()], d.t2 = skim.engine.addTriangle(f, g, d.vnew, m, a.getVolType()), m = null === a.materials ? null : [a.materials[2].clone(), a.materials[0].clone(), n.clone()], d.t3 = skim.engine.addTriangle(g, e, d.vnew, m, a.getVolType()));
		a.destroy();
		this.setSymmetries(p);
		return d
	},
	splitSegment : function (a, b) {
		var c = a.v[0],
		d = a.v[1];
		skim.utils.assert(a instanceof skim.engine.SegmentDef,
			"Error : splitSegment can only operate on a segment...");
		var e = null,
		f = null,
		g = null;
		null === a.materials ? (e = c.getMaterial().clone(), e.lerp(d.getMaterial(), b)) : (e = a.materials[0].clone(), e.lerp(a.materials[1], b), f = [a.materials[0].clone(), e.clone()], g = [e.clone(), a.materials[0].clone()]);
		var h = this.getSegSymLinks(a),
		k = {
			x : this.symmetry.x,
			y : this.symmetry.y,
			z : this.symmetry.z
		};
		this.setSymmetries({
			x : null !== h.x,
			y : null !== h.y,
			z : null !== h.z
		});
		e = skim.engine.addVertex(c.getPos().x * (1 - b) + d.getPos().x * b, c.getPos().y * (1 -
					b) + d.getPos().y * b, c.getPos().z * (1 - b) + d.getPos().z * b, c.getThickness() * (1 - b) + d.getThickness() * b, e, a.getVolType());
		skim.engine.addSegment(c, e, f, a.getVolType());
		skim.engine.addSegment(e, d, g, a.getVolType());
		a.destroy();
		this.setSymmetries(k)
	},
	addSegPlaneSymProcess : function (a, b, c, d, e, f) {
		if (null === f.v[e] && 0 === a.v.getPos()[e]) {
			var g = d[a.v.id].clone();
			g[e] = 0 === g[e] ? 1 : 0;
			g = c[g.getKey()];
			f.v[e] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.v, void 0 !== g ? g.v : null, e)
		}
		if (null !== f.v[e]) {
			var h = d[a.v.id].clone();
			h[e] = 0 === h[e] ? 1 : 0;
			g = c[h.getKey()];
			void 0 !== g && skim.utils.assert(void 0 !== g.vnew && void 0 !== g.s, "FUCCCCCCCCKKKKK");
			null === f.vnew[e] && (f.vnew[e] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.vnew, void 0 !== g ? g.vnew : null, e));
			null === f.s[e] && (f.s[e] = new skim.engine.linkFunctors.SegPlaneSymmetryAxis(a.s, void 0 !== g ? g.s : null, e));
			void 0 === g && (g = {
					v : f.v[e].getSym(a.v),
					vnew : f.vnew[e].getSym(a.vnew),
					s : f.s[e].getSym(a.s)
				}, d[g.v.id] = h, c[h.getKey()] = g);
			b[g.v.id] = {
				v : g.v,
				vnew : g.vnew,
				s : g.s
			}
		}
	},
	addSegGetFirstTopoPos : function (a) {
		var b =
			new skim.engine.TopoPosition({});
		this.getVSymLinks(a);
		return b
	},
	addSegment : function (a, b, c, d) {
		c = new skim.engine.SegmentDef([a, b], c, d);
		c.commit();
		d = {};
		var e = {};
		e[a.id] = {
			v : a,
			vnew : b,
			s : c
		};
		var f = {},
		g = {};
		g[a.id] = this.addSegGetFirstTopoPos(a);
		f[g[a.id].getKey()] = {
			v : a,
			vnew : b,
			s : c
		};
		b = Object.keys(e);
		for (var h = ["x", "y", "z"]; 0 !== b.length; ) {
			var k = e[b[0]];
			a = k.v;
			if (void 0 === d[a.id]) {
				for (var l = {
						v : this.getVSymLinks(k.v),
						vnew : this.getVSymLinks(k.vnew),
						s : this.getSegSymLinks(k.s)
					}, m = 0; m < h.length; m++)
					this.symmetry[h[m]] &&
					this.addSegPlaneSymProcess(k, e, f, g, h[m], l);
				d[a.id] = a
			}
			delete e[b[0]];
			b = Object.keys(e)
		}
		return c
	},
	addTriPlaneSymProcess : function (a, b, c, d, e, f) {
		if (null === f.v[e] && 0 === a.v.getPos()[e]) {
			var g = d[a.v.id].clone();
			g[e] = 0 === g[e] ? 1 : 0;
			g = c[g.getKey()];
			f.v[e] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.v, void 0 !== g ? g.v : null, e)
		}
		if (null !== f.v[e]) {
			var h = d[a.v.id].clone();
			h[e] = 0 === h[e] ? 1 : 0;
			g = c[h.getKey()];
			void 0 !== g && skim.utils.assert(void 0 !== g.vnew1 && void 0 !== g.vnew2 && void 0 !== g.t, "FUCCCCCCCCKKKKK");
			null === f.vnew1[e] &&
			(f.vnew1[e] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.vnew1, void 0 !== g ? g.vnew1 : null, e));
			null === f.vnew2[e] && (f.vnew2[e] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.vnew2, void 0 !== g ? g.vnew2 : null, e));
			null === f.t[e] && (f.t[e] = new skim.engine.linkFunctors.TriPlaneSymmetryAxis(a.t, void 0 !== g ? g.t : null, e));
			void 0 === g && (g = {
					v : f.v[e].getSym(a.v),
					vnew1 : f.vnew1[e].getSym(a.vnew1),
					vnew2 : f.vnew2[e].getSym(a.vnew2),
					t : f.t[e].getSym(a.t)
				}, d[g.v.id] = h, c[h.getKey()] = g);
			b[g.v.id] = {
				v : g.v,
				vnew1 : g.vnew1,
				vnew2 : g.vnew2,
				t : g.t
			}
		}
	},
	addTriGetFirstTopoPos : function (a) {
		var b = new skim.engine.TopoPosition({});
		this.getVSymLinks(a);
		return b
	},
	addTriangle : function (a, b, c, d, e) {
		d = new skim.engine.TriangleDef([a, b, c], d, e);
		d.commit();
		e = {};
		var f = {};
		f[a.id] = {
			v : a,
			vnew1 : b,
			vnew2 : c,
			t : d
		};
		var g = {},
		h = {};
		h[a.id] = this.addTriGetFirstTopoPos(a);
		g[h[a.id].getKey()] = {
			v : a,
			vnew1 : b,
			vnew2 : c,
			t : d
		};
		b = Object.keys(f);
		for (c = ["x", "y", "z"]; 0 !== b.length; ) {
			var k = f[b[0]];
			a = k.v;
			if (void 0 === e[a.id]) {
				for (var l = {
						v : this.getVSymLinks(k.v),
						vnew1 : this.getVSymLinks(k.vnew1),
						vnew2 : this.getVSymLinks(k.vnew2),
						t : this.getTriSymLinks(k.t)
					}, m = 0; m < c.length; m++)
					this.symmetry[c[m]] && this.addTriPlaneSymProcess(k, f, g, h, c[m], l);
				e[a.id] = a
			}
			delete f[b[0]];
			b = Object.keys(f)
		}
		return d
	},
	addMesh : function (a, b, c) {
		a = new skim.engine.MeshDef([], a, b, c);
		a.commit();
		return a
	},
	merge_vertex : function (a, b) {
		var c = this.getVertexById(a.id),
		d = this.getVertexById(b.id);
		this.mergeVertexDef(c, d)
	},
	mergeVertexFirstTopoPos : function (a) {
		return new skim.engine.TopoPosition({})
	},
	mergeVertexDef : function (a, b) {
		var c = this.getVertexSymmetries(a),
		d = this.getVertexSymmetries(b),
		e = function (a) {
			return (void 0 !== c[a] || void 0 !== d[a]) && d[a] === c[a]
		};
		a.setVertexAndPropagate(e("x") ? 0 : b.getPos().x, e("y") ? 0 : b.getPos().y, e("z") ? 0 : b.getPos().z, b.getThickness(), b.getMaterial(), b.getVolType());
		var f = function (a, b) {
			return (null === a ? "x" : a.id.toString()) + "#" + (null === b ? "x" : b.id.toString())
		},
		g = {},
		h = {};
		h[f(a, b)] = {
			v0 : a,
			v1 : b
		};
		var k = {},
		l = {};
		l[a.id] = this.addSegGetFirstTopoPos(a);
		l[b.id] = l[a.id].clone();
		k[l[a.id].getKey()] = {
			v0 : a,
			v1 : b,
			links0 : c,
			links1 : d
		};
		for (var m = ["x", "y",
				"z"], n = Object.keys(h); 0 !== n.length; ) {
			var e = h[n[0]],
			p = e.v0,
			q = e.v1;
			if (void 0 === g[f(p, q)]) {
				for (var r = null === p ? {}

					 : this.getVertexSymmetries(p), t = null === q ? {}

					 : this.getVertexSymmetries(q), e = 0; 3 > e; e++) {
					var s = m[e],
					u = l[p.id].clone();
					u[s] = 0 === u[s] ? 1 : 0;
					var w = k[u.getKey()];
					if (void 0 !== r[s] || void 0 !== t[s])
						void 0 !== r[s] && r[s] === t[s] ? (r[s].destroy(), delete r[s], delete t[s]) : (void 0 === w ? (w = {
									v0 : void 0 === r[s] ? null : r[s].getSym(p),
									v1 : void 0 === t[s] ? null : t[s].getSym(q),
									links0 : null,
									links1 : null
								}, k[u.getKey()] = w) : (skim.utils.assert(null ===
									w.v0 || void 0 === r[s] || r[s].getSym(p) === w.v0, "Oh god, merging assertion can be f*****."), skim.utils.assert(null === w.v1 || void 0 === t[s] || t[s].getSym(q) === w.v1, "Oh god, merging assertion can be f*****."), w.v0 = void 0 === r[s] ? w.v0 : r[s].getSym(p), w.v1 = void 0 === t[s] ? w.v1 : t[s].getSym(q)), w.links0 = null === w.v0 ? {}

							 : this.getVertexSymmetries(w.v0), w.links1 = null === w.v1 ? {}

							 : this.getVertexSymmetries(w.v1));
					w = k[u.getKey()];
					void 0 !== w && (null !== w.v0 && null !== w.v1) && (h[f(w.v0, w.v1)] = w, null !== w.v0 && (l[w.v0.id] = u), null !== w.v1 &&
						(l[w.v1.id] = u))
				}
				g[f(p, q)] = !0
			}
			delete h[n[0]];
			n = Object.keys(h)
		}
		h = {};
		f = {};
		l = Object.keys(k);
		for (g = 0; g < l.length; ++g)
			if (n = k[l[g]], null !== n.v0 && null !== n.v1) {
				for (e = 0; 3 > e; e++)
					s = m[e], void 0 !== n.links0[s] && (void 0 === n.links1[s] ? n.links0[s].swapVertex(n.v0, n.v1) : n.links0[s] === n.links1[s] && (n.links0[s].destroy(), delete n.links0[s]));
				var e = n.v0.getOwners(),
				y;
				for (y in e)
					e.hasOwnProperty(y) && (s = e[y], s.swapVertex(n.v0, n.v1), s instanceof skim.engine.SegmentDef ? h[y] = s : s instanceof skim.engine.TriangleDef && (f[y] = s))
			}
		for (g =
				0; g < l.length; ++g)
			n = k[l[g]], null !== n.v0 && null !== n.v1 && n.v0.destroy();
		y = Object.keys(h);
		for (g = 0; g < y.length; ++g)
			for (s = h[y[g]], e = s.v[0].getOwnersSegments(), k = s.v[1].getOwnersSegments(), m = Object.keys(e), e = 0; e < m.length; ++e)
				if (k[m[e]] !== s && void 0 !== k[m[e]]) {
					s.destroy();
					break
				}
		y = Object.keys(f);
		for (g = 0; g < y.length; ++g)
			for (s = f[y[g]], e = s.v[0].getOwnersTriangles(), k = s.v[1].getOwnersTriangles(), h = s.v[2].getOwnersTriangles(), m = Object.keys(e), e = 0; e < m.length; ++e)
				if (k[m[e]] !== s && void 0 !== k[m[e]] && void 0 !== h[m[e]]) {
					s.destroy();
					break
				}
	},
	splitRingSymProcessXY : function (a, b, c, d, e, f) {
		if (null === f[0][e]) {
			var g = d[a.vdef[0].id].clone();
			g[e] = 0 === g[e] ? 1 : 0;
			for (var h = c[g.getKey()], k = 0; 4 > k; ++k)
				null === f[k][e] && (f[k][e] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.vdef[k], void 0 !== h ? h.vdef[k] : null, e));
			void 0 === h && (h = {
					vdef : [f[0][e].getSym(a.vdef[0]), f[1][e].getSym(a.vdef[1]), f[2][e].getSym(a.vdef[2]), f[3][e].getSym(a.vdef[3])]
				}, d[h.vdef[0].id] = g, c[g.getKey()] = h);
			b[h.vdef[0].id] = h
		}
	},
	splitRing : function (a, b) {
		var c = this.getPrimitiveById(a.id);
		skim.utils.assert(c instanceof skim.engine.RingDef, "Error : splitRing can only operate on a ring...");
		this.splitRingDef(c, b)
	},
	splitRingDef : function (a, b) {
		var c = skim.engine.getRingSymmetries(a);
		if (void 0 === c.z)
			return [this.doSplitRingDef(a, b)];
		var d = skim.engine.symmetry.z;
		skim.engine.setSymmetries({
			z : !1
		});
		for (var e = this.doSplitRingDef(a, b), c = this.doSplitRingDef(c.z.getSym(a), b), f = Object.keys(e), g = 0; g < f.length; ++g) {
			var h = e[f[g]].vdef,
			k = c[f[g]].vdef;
			new skim.engine.linkFunctors.VPlaneSymmetryAxis(h[0],
				k[3], "z");
			new skim.engine.linkFunctors.VPlaneSymmetryAxis(h[1], k[2], "z");
			new skim.engine.linkFunctors.VPlaneSymmetryAxis(h[2], k[1], "z");
			new skim.engine.linkFunctors.VPlaneSymmetryAxis(h[3], k[0], "z")
		}
		skim.engine.setSymmetries({
			z : d
		});
		return [e, c]
	},
	doSplitRingDef : function (a, b) {
		for (var c = Math.cos(b), d = Math.sin(b), e = [], f = [], g = [], h = new skim.ringUtils.RingNode(a.v), k = 0; 4 > k; k++)
			e[k] = skim.ringUtils.getRZTFromAngle(h, b, k + 1), f[k] = e[k].z, e[k] = e[k].set(e[k].x * c, e[k].x * d, e[k].y), g[k] = new skim.engine.VertexDef(e[k],
					f[k], skim.instances.defaultMaterial, a.getVolType()), g[k].commit();
		k = g[0];
		d = {};
		e = {};
		e[k.id] = {
			vdef : g
		};
		c = {};
		f = {};
		f[k.id] = new skim.engine.TopoPosition({});
		c[f[k.id].getKey()] = {
			vdef : g
		};
		for (var h = Object.keys(e), l = ["x", "y"]; 0 !== h.length; ) {
			var m = e[h[0]],
			k = m.vdef[0];
			if (void 0 === d[k.id]) {
				for (var n = [], g = 0; 4 > g; ++g)
					n.push(skim.engine.getVSymLinks(m.vdef[0]));
				for (g = 0; g < l.length; ++g)
					skim.engine.symmetry[l[g]] && skim.engine.splitRingSymProcessXY(m, e, c, f, l[g], n);
				d[k.id] = k
			}
			delete e[h[0]];
			h = Object.keys(e)
		}
		if (skim.engine.symmetry.z)
			for (d =
					Object.keys(c), k = 0; k < d.length; ++k) {
				f = c[d[k]];
				e = [];
				for (g = 0; 4 > g; ++g)
					h = f.vdef[g].getPos().clone(), h.z = 0, e.push({
						v : f.vdef[g],
						d : h.length()
					});
				e.sort(function (a, b) {
					return b.d - a.d
				});
				for (g = 0; 4 > g; g += 2)
					f = e[g].v.getPos(), h = e[g + 1].v.getPos(), l = 0.5 * (f.z + h.z), e[g].v.setVertexAndPropagate(f.x, f.y, f.z - l, e[g].v.getThickness(), e[g].v.getMaterial(), e[g].v.getVolType()), e[g + 1].v.setVertexAndPropagate(h.x, h.y, h.z - l, e[g + 1].v.getThickness(), e[g + 1].v.getMaterial(), e[g + 1].v.getVolType()), new skim.engine.linkFunctors.VPlaneSymmetryAxis(e[g].v,
						e[g + 1].v, "z")
			}
		d = Object.keys(c);
		for (k = 0; k < d.length; ++k)
			a.addConstraints(c[d[k]].vdef);
		return c
	},
	removeOldVerticesFromSkeleton : function () {
		for (var a = Object.keys(skim.instances.skel.vertices), b = 0; b < a.length; b++) {
			var c = skim.instances.skel.vertices[a[b]],
			d = this.vars.vertices[c.id];
			void 0 !== d && d.getMaster() === d || skim.instances.skel.removeVertex(c)
		}
	},
	addMissingVerticesToSkeleton : function () {
		for (var a = Object.keys(this.vars.vertices), b = 0; b < a.length; b++) {
			var c = this.vars.vertices[a[b]],
			d = c.getReactor(),
			c = c.getMaster() ===
				c;
			void 0 === skim.instances.skel.vertices[d.id] && c && skim.instances.skel.addVertex(d)
		}
	},
	updateSkeletonPrimitives : function () {
		for (var a = Object.keys(this.vars.primitives), b = 0; b < a.length; b++) {
			var c = a[b],
			d = this.vars.primitives[c];
			d.getMaster() === d ? (d.updateReactor(), void 0 === skim.instances.skel.prims[c] && d.hasReactor() && skim.instances.skel.addPrim(d.getReactor())) : d.destroyReactor()
		}
	},
	removeOldPrimsFromSkeleton : function () {
		for (var a = Object.keys(skim.instances.skel.prims), b = a.length, c = 0; c < b; ++c) {
			var d = a[c],
			e = this.vars.primitives[d];
			if (void 0 === e || e.getMaster() !== e)
				skim.instances.skel.removePrim(skim.instances.skel.prims[d]), void 0 !== e && e.destroyReactor()
		}
	},
	DEBUGCheck_skel_adjacency : function () {
		for (var a = Object.keys(skim.instances.skel.prims), b = a.length, c = 0; c < b; ++c) {
			var d = skim.instances.skel.prims[a[c]];
			if (2 == d.v.length)
				for (var e = 0; e < d.v.length; ++e)
					skim.utils.assert(d.v[0].vAdj[d.v[1].id].v === d.v[1] && d.v[1].vAdj[d.v[0].id].v === d.v[0], " FUCK")
		}
	},
	update_skeleton : function () {
		console.time("update_skeleton");
		this.removeOldPrimsFromSkeleton();
		this.addMissingVerticesToSkeleton();
		this.updateSkeletonPrimitives();
		this.removeOldVerticesFromSkeleton();
		this.DEBUGCheck_skel_adjacency();
		console.timeEnd("update_skeleton")
	},
	prims_to_param_prims : {},
	update_parametrics : function () {
		for (var a = skim.instances.skel.prims, b = Object.keys(a), c = b.length, d = 0; d < c; ++d) {
			var e = a[b[d]],
			f = this.prims_to_param_prims[e.id];
			if (void 0 !== f)
				switch (e.type) {
				case skim.skel.typeHeightMapRing:
					e.getRLength() === f.getRLength() && e.getZLength() === f.getZLength() &&
					e.getRound() === f.getRound() && e.getBump() === f.getBump() || f.set(e.getRLength(), e.getZLength(), e.getRound(), e.getBump(), e.getRadius());
					e.getImage() !== f.getImage() && f.setImage(e.getImage());
					e.getColorImageData() !== f.getColorImageData() && f.setColorImageData(e.getColorImageData());
					if (this.materialInfos.print_wall !== f.getPrintWall() || this.materialInfos.print_detail !== f.getPrintDetail())
						f.setPrintWall(this.materialInfos.print_wall), f.setPrintDetail(this.materialInfos.print_detail);
					break;
				case skim.skel.typeMesh:
					skim.instances.modeler.meshManager.remove(f);
					f = new skim.parametrics.Mesh(e.getMesh());
					this.prims_to_param_prims[e.id] = f;
					skim.instances.modeler.meshManager.add(f);
					break;
				default:
					skim.utils.assert(!1, "update_parametrics found an unmanaged primitive type")
				}
			else if (this.vars.primitives[e.id].isParametric())
				switch (e.type) {
				case skim.skel.typeHeightMapRing:
					f = new skim.parametrics.HeightMapRing(e.getRLength(), e.getZLength(), e.getRound(), e.getBump(), e.getRadius(), e.getLambda(), e.isUniformZLength(), this.materialInfos.print_wall, this.materialInfos.print_detail,
							e.getImage(), e.getColorImageData());
					this.prims_to_param_prims[e.id] = f;
					skim.instances.modeler.meshManager.add(f);
					break;
				case skim.skel.typeMesh:
					f = new skim.parametrics.Mesh(e.getMesh());
					this.prims_to_param_prims[e.id] = f;
					skim.instances.modeler.meshManager.add(f);
					break;
				default:
					skim.utils.assert(!1, "update_parametrics found an unmanaged primitive type")
				}
		}
		b = Object.keys(this.prims_to_param_prims);
		c = b.length;
		for (d = 0; d < c; ++d)
			e = b[d], void 0 === a[e] && (f = this.prims_to_param_prims[e], skim.instances.modeler.meshManager.remove(f),
				delete this.prims_to_param_prims[e])
	},
	vtx_to_bt_vtx : {},
	lone_vtx_nodes : {},
	prims_to_bt_prims : {},
	zanni_corrector : null,
	update_blobtree : function () {
		console.time("update_blobtree");
		var a = {},
		b = skim.instances.modeler.meshManager.getBlobtrees()[0],
		c = {};
		c[skim.VolType.Mech] = null;
		c[skim.VolType.Orga] = null;
		2 !== b.children.length ? (skim.utils.assert(0 === b.children.length, "Error : in current Engine config, root can only have 2 or 0 children"), c[skim.VolType.Mech] = new skim.blobtree.RicciNode(64), b.addChild(c[skim.VolType.Mech]),
			c[skim.VolType.Orga] = new skim.blobtree.RicciNode(1), b.addChild(c[skim.VolType.Orga])) : 1 === b.children[0].ricci_n ? (c[skim.VolType.Orga] = b.children[0], c[skim.VolType.Mech] = b.children[1]) : (c[skim.VolType.Orga] = b.children[1], c[skim.VolType.Mech] = b.children[0]);
		for (var d = skim.instances.skel.prims, e = Object.keys(d), f = e.length, g = 0; g < f; ++g) {
			var h = d[e[g]],
			k = this.prims_to_bt_prims[h.id];
			if (void 0 !== k) {
				if (k.mutableVolType() && h.getVolType() !== k.getVolType()) {
					k.setVolType(h.getVolType());
					for (var l = 0; l < h.v.length; ++l)
						a[h.v[l].id] =
							h.v[l];
					k.getParentNode().removeChild(k);
					c[h.getVolType()].addChild(k)
				}
				if (h.type == skim.skel.typeRing && h.v.length != k.v.length) {
					for (var l = Array(h.v.length), m = 0; m < h.v.length; ++m)
						l[m] = new skim.blobtree.Vertex(h.v[m].getPos().clone(), h.v[m].getThickness()), a[h.v[m].id] = h.v[m];
					k.setV(l);
					k.setTheta(h.theta);
					k.setRZ(h.rz);
					k.setarcStep(h.arcStep);
					k.setconstraintsIndices(h.constraintsIndices);
					k.setMins([h.rMin, h.zMin, h.thickMin]);
					k.setMaxs([h.rMax, h.zMax, h.thickMax, h.lMax]);
					k.invalidAABB()
				}
				if (null !== h.getMaterials())
					k.setMaterials(h.getMaterials());
				else {
					m = [];
					for (l = 0; l < k.getMaterials().length; ++l)
						m.push(h.v[l].getMaterial()), a[h.v[l].id] = h.v[l];
					k.setMaterials(m)
				}
			} else if (this.vars.primitives[h.id].isImplicit())
				switch (h.type) {
				case skim.skel.typeSegment:
					k = new skim.blobtree.Segment(new skim.blobtree.Vertex(h.v[0].getPos().clone(), h.v[0].getThickness()), new skim.blobtree.Vertex(h.v[1].getPos().clone(), h.v[1].getThickness()), h.getVolType(), 1, null !== h.get("materials") ? [h.get("materials")[0].clone(), h.get("materials")[0].clone()] : [h.v[0].getMaterial().clone(),
								h.v[1].getMaterial().clone()]);
					c[h.getVolType()].addChild(k);
					this.prims_to_bt_prims[h.id] = k;
					a[h.v[0].id] = h.v[0];
					a[h.v[1].id] = h.v[1];
					break;
				case skim.skel.typeRing:
					l = Array(h.v.length);
					for (m = 0; m < h.v.length; ++m)
						l[m] = new skim.blobtree.Vertex(h.v[m].getPos().clone(), h.v[m].getThickness()), a[h.v[m].id] = h.v[m];
					k = new skim.blobtree.Ring(l, h.getVolType(), [skim.instances.defaultMaterial]);
					k.computeHelpVariables();
					c[h.getVolType()].addChild(k);
					this.prims_to_bt_prims[h.id] = k;
					break;
				case skim.skel.typeTextRing:
					l =
						Array(h.v.length);
					for (m = 0; m < h.v.length; ++m)
						l[m] = new skim.blobtree.Vertex(h.v[m].getPos().clone(), h.v[m].getThickness()), a[h.v[m].id] = h.v[m];
					k = new skim.blobtree.TextRing(l, h.imageData, h.getVolType(), [skim.instances.defaultMaterial]);
					k.computeHelpVariables();
					c[h.getVolType()].addChild(k);
					this.prims_to_bt_prims[h.id] = k;
					break;
				case skim.skel.typeText:
					l = Array(h.v.length);
					for (m = 0; m < h.v.length; ++m)
						l[m] = new skim.blobtree.Vertex(h.v[m].getPos().clone(), h.v[m].getThickness()), a[h.v[m].id] = h.v[m];
					k = new skim.blobtree.Text(l,
							h.imageData, h.getVolType(), [skim.instances.defaultMaterial]);
					c[h.getVolType()].addChild(k);
					this.prims_to_bt_prims[h.id] = k;
					break;
				case skim.skel.typeTriangle:
					k = Array(h.v.length);
					for (l = 0; l < h.v.length; ++l)
						k[l] = new skim.blobtree.Vertex(h.v[l].getPos().clone(), h.v[l].getThickness()), a[h.v[l].id] = h.v[l];
					k = new skim.blobtree.Triangle(k, h.getVolType(), null !== h.get("materials") ? [h.get("materials")[0].clone(), h.get("materials")[1].clone(), h.get("materials")[2].clone()] : [h.v[0].getMaterial().clone(), h.v[1].getMaterial().clone(),
								h.v[2].getMaterial().clone()]);
					k.computeHelpVariables();
					c[h.getVolType()].addChild(k);
					this.prims_to_bt_prims[h.id] = k;
					break;
				default:
					skim.utils.assert(!1, "update_blobtree found an unmanaged primitive type")
				}
		}
		e = Object.keys(this.prims_to_bt_prims);
		f = e.length;
		for (g = 0; g < f; ++g)
			h = e[g], void 0 === d[h] && (k = this.prims_to_bt_prims[h], k.getParentNode().removeChild(k), delete this.prims_to_bt_prims[h]);
		d = skim.instances.skel.vertices;
		e = Object.keys(d);
		f = e.length;
		for (g = 0; g < f; ++g) {
			for (var m = d[e[g]], n = !1, p = Object.keys(m.owners),
				q = p.length, r = 0; r < q; r++)
				for (var t = m.owners[p[r]], s = Object.keys(t), u = s.length, l = 0; l < u; ++l) {
					var h = t[s[l]],
					k = this.prims_to_bt_prims[h.id],
					h = h.getVertexIndex(m),
					w = k.getVPos(h),
					y = k.getVThickness(h);
					w.equals(m.getPos()) || (k.setVPos(h, m.getPos().clone()), n = !0);
					y != m.getThickness() && (k.setVThickness(h, m.getThickness()), n = !0)
				}
			k = this.lone_vtx_nodes[m.id];
			skim.utils.isEmpty(m.owners) ? (void 0 === k && (k = new skim.blobtree.Point(new skim.blobtree.Vertex(m.getPos().clone(), m.getThickness()), m.getVolType(), 1, m.getMaterial().clone()),
					c[m.getVolType()].addChild(k), this.lone_vtx_nodes[m.id] = k, n = !0), h = k.getVPos(0), l = k.getVThickness(0), h.equals(m.getPos()) || (k.setVPos(0, m.getPos().clone()), n = !0), l != m.getThickness() && (k.setVThickness(0, m.getThickness()), n = !0), k.getVolType() !== m.getVolType() && (k.setVolType(m.getVolType()), k.getParentNode().removeChild(k), c[m.getVolType()].addChild(k), n = !0), k.getMaterials()[0].equals(m.getMaterial()) || (k.setMaterial(m.getMaterial()), n = !0)) : void 0 !== k && (k.getParentNode().removeChild(k), delete this.lone_vtx_nodes[m.id],
				n = !0);
			n && (a[m.id] = m)
		}
		e = Object.keys(this.lone_vtx_nodes);
		f = e.length;
		for (g = 0; g < f; ++g)
			h = e[g], void 0 === d[h] && (k = this.lone_vtx_nodes[h], k.getParentNode().removeChild(k), delete this.lone_vtx_nodes[h]);
		null === this.zanni_corrector && (this.zanni_corrector = new skim.engine.ZanniCorrector);
		this.zanni_corrector.performCorrection(a, c[skim.VolType.Orga]);
		a = !0;
		for (g = 0; g < b.children.length; ++g)
			0 !== b.children[g].children.length && (a = !1);
		if (a)
			for (; 0 !== b.children.length; )
				b.removeChild(b.children[0]);
		skim.instances.modeler &&
		(skim.instances.modeler.meshManager && !b.isValidAABB()) && (b.prepareForEval(), skim.instances.modeler.meshManager.invalidate(b.id));
		console.timeEnd("update_blobtree")
	}
};
skim.engine.ZanniCorrector = function () {
	this.v_valency = {};
	this.seg_correctors = {};
	this.point_correctors = {};
	this.zanni_tmp_segs = []
};
skim.engine.ZanniCorrector.prototype.increaseZanniTmpSegs = function (a) {
	for (; this.zanni_tmp_segs.length < a; ) {
		var b = new skim.blobtree.Vertex(new THREE.Vector3, 1),
		c = new skim.blobtree.Vertex(new THREE.Vector3, 1);
		this.zanni_tmp_segs.push(new skim.blobtree.Segment(b, c, skim.VolType.Orga, 1, [skim.instances.defaultMaterial.clone(), skim.instances.defaultMaterial.clone()]))
	}
};
skim.engine.ZanniCorrector.prototype.removeSegCorrector = function (a, b) {
	b.getParentNode().removeChild(b);
	delete this.seg_correctors[a]
};
skim.engine.ZanniCorrector.prototype.removePointCorrector = function (a, b) {
	b.getParentNode().removeChild(b);
	delete this.point_correctors[a]
};
skim.engine.ZanniCorrector.prototype.getOrgaSegmentsOwners = function (a) {
	for (var b = Object.keys(a.owners[skim.skel.tokenVSegment]), c = [], d = 0; d < b.length; ++d)
		a.owners[skim.skel.tokenVSegment][b[d]].getVolType() === skim.VolType.Orga && c.push(a.owners[skim.skel.tokenVSegment][b[d]]);
	return c
};
skim.engine.ZanniCorrector.prototype.checkAndUpdateValency = function (a) {
	for (var b = skim.instances.skel.getValencyMap(), c = Object.keys(this.v_valency), d = 0; d < c.length; ++d) {
		var e = c[d];
		void 0 !== b[e] && this.v_valency[e] !== b[e] && (a[e] = skim.instances.skel.vertices[e])
	}
	this.v_valency = b
};
skim.engine.ZanniCorrector.prototype.cleanRemovedVerticesCorrection = function () {
	for (var a = Object.keys(this.point_correctors), b = a.length, c = 0; c < b; ++c) {
		var d = a[c];
		void 0 === skim.instances.skel.vertices[a[c]] && this.removePointCorrector(d, this.point_correctors[d])
	}
	a = Object.keys(this.seg_correctors);
	b = a.length;
	for (c = 0; c < b; ++c)
		d = a[c], void 0 === skim.instances.skel.vertices[a[c]] && this.removeSegCorrector(d, this.seg_correctors[d])
};
skim.engine.ZanniCorrector.prototype.performCorrection = function (a, b) {
	var c = skim.skel.VertexReactor.getAdjVertices(a),
	c = skim.utils.mergeMapObjects([a, c]);
	this.checkAndUpdateValency(c);
	this.cleanRemovedVerticesCorrection();
	for (var d = Object.keys(c), e = d.length, f = null, g = 0; g < e; ++g)
		if (f = c[d[g]], void 0 !== f.owners[skim.skel.tokenVSegment]) {
			var h = this.getOrgaSegmentsOwners(f);
			if (0 !== h.length && f.isLocalMaximum()) {
				this.increaseZanniTmpSegs(h.length);
				for (var k = 0, l = new THREE.Vector3(f.get("thickness"), 0, 0), m = {
						v : 0
					},
					n = [], p = [], q = 0; q < h.length; ++q) {
					var r = h[q],
					t = null;
					r.v[0] == f ? (t = r.v[1], null !== r.get("materials") ? n.push(r.get("materials")[0]) : n.push(f.getMaterial())) : (t = r.v[0], null !== r.get("materials") ? n.push(r.get("materials")[1]) : n.push(f.getMaterial()));
					p.push(1);
					this.zanni_tmp_segs[q].setVAll(0, new THREE.Vector3, f.get("thickness"));
					r = (f.get("thickness") - t.get("thickness")) / r.length;
					1E-5 < r ? (r = f.get("thickness") / r, this.zanni_tmp_segs[q].setVAll(1, new THREE.Vector3(0, r, 0), 0)) : 1E-5 > Math.abs(r) ? this.zanni_tmp_segs[q].setVAll(1,
						new THREE.Vector3(0, skim.blobtree.KS * Math.max(f.get("thickness"), t.get("thickness")), 0), t.get("thickness")) : console.log("Error : v should be a maxima");
					this.zanni_tmp_segs[q].prepareForEval();
					this.zanni_tmp_segs[q].value(l, skim.blobtree.EvalTags.Value, m);
					k += m.v
				}
				l = new skim.Material(null, null, null);
				l.weightedMean(n, p);
				m = this.point_correctors[f.id];
				void 0 === m && (m = new skim.blobtree.Point(new skim.blobtree.Vertex(new THREE.Vector3, 1), skim.VolType.Mech, 1, skim.instances.defaultMaterial), b.addChild(m), this.point_correctors[f.id] =
						m);
				m.setVAll(0, f.get("pos").clone(), f.get("thickness"));
				m.setMaterial(l);
				m.setDensity((skim.blobtree.iso_value - k) / (skim.blobtree.Poly6Eval(1) * skim.blobtree.Poly6NF0D))
			} else
				m = this.point_correctors[f.id], void 0 !== m && this.removePointCorrector(f.id, m);
			if (1 == h.length) {
				r = h[0];
				h = null;
				h = r.v[0] == f ? null !== r.get("materials") ? r.get("materials")[0] : f.get("material") : null !== r.get("materials") ? r.get("materials")[1] : f.get("material");
				k = r.unit_dir.clone();
				r.v[0] == f && k.multiplyScalar(-1);
				l = 0;
				n = new skim.blobtree.Segment(new skim.blobtree.Vertex(new THREE.Vector3(-200,
								0, 0), 1), new skim.blobtree.Vertex(new THREE.Vector3(0, 0, 0), 1), skim.VolType.Orga, 1, [skim.instances.defaultMaterial.clone(), skim.instances.defaultMaterial.clone()]);
				n.prepareForEval();
				p = 0;
				q = 3;
				l = new THREE.Vector3(0, 0, 0);
				for (m = {
						v : 0
					}; 1E-11 < Math.abs(m.v - 1); )
					n.value(l, skim.blobtree.EvalTags.Value, m), 1 > m.v ? q = l.x : p = l.x, l.x = (q + p) / 2;
				l = 1 - l.x;
				skim.utils.assert(0 < l, "Fuck it, l0 should be positive");
				k.multiplyScalar(l * f.get("thickness"));
				r = Math.abs((r.v[0].get("thickness") - r.v[1].get("thickness")) / r.length);
				0.5 >
				r ? (l = this.seg_correctors[f.id], void 0 === l && (l = new skim.blobtree.Segment(new skim.blobtree.Vertex(new THREE.Vector3, 1), new skim.blobtree.Vertex(new THREE.Vector3, 1), skim.VolType.Orga, 1, [skim.instances.defaultMaterial.clone(), skim.instances.defaultMaterial.clone()]), b.addChild(l), this.seg_correctors[f.id] = l), l.setVAll(0, f.get("pos").clone(), f.get("thickness")), l.setVAll(1, f.get("pos").clone().add(k), f.get("thickness")), l.setMaterials([h.clone(), h.clone()]), r = (1 - 2 * r) * (1 - 2 * r), l.setDensity(r), m = this.point_correctors[f.id],
					1 == r ? void 0 !== m && this.removePointCorrector(f.id, m) : void 0 !== m && m.setDensity(m.getDensity() * (1 - r))) : (l = this.seg_correctors[f.id], void 0 !== l && this.removeSegCorrector(f.id, l))
			} else
				l = this.seg_correctors[f.id], void 0 !== l && this.removeSegCorrector(f.id, l)
		} else
			l = this.seg_correctors[f.id], void 0 !== l && this.removeSegCorrector(f.id, l), m = this.point_correctors[f.id], void 0 !== m && this.removePointCorrector(f.id, m)
};
skim.engine.utilsFunctors = {};
skim.engine.utilsFunctors.getLimit = function (a) {
	if (a.limit)
		return a.limit;
	if (a.ring)
		return a.ring.getReactor().rMin - a.ring.getReactor().thickMax;
	a = [];
	for (var b = 0, c = skim.engine.vars.primitives, d = Object.keys(c), e = d.length, f = 0; f < e; ++f) {
		var g = c[d[f]];
		g instanceof skim.engine.RingDef && (a.push(g.getReactor().rMin), b = g.getReactor().thickMax)
	}
	return 0 < a.length ? Math.min.apply(Math, a) - b : -1
};
skim.engine.linkFunctors = {};
skim.engine.linkFunctors.ids = 0;
skim.engine.linkFunctors.VirtualLinkFunctor = function () {
	this.id = skim.engine.linkFunctors.ids++;
	skim.engine.vars.relations[this.id] = this;
	this.is_engine_managed = !0
};
skim.engine.linkFunctors.VirtualLinkFunctor.prototype.getLinkMaster = function () {
	skim.utils.assert(!1, "Error : VirtualLinkFunctor.getLinkMaster is pure abstract function, should be re-implemented in subclass");
	return null
};
skim.engine.linkFunctors.VirtualLinkFunctor.prototype.destroy = function () {
	skim.utils.assert(!1, "Error : VirtualLinkFunctor.destroy is pure abstract function, should be re-implemented in subclass")
};
skim.engine.linkFunctors.VirtualLinkFunctor.prototype.isGrouped = function () {
	skim.utils.assert(!1, "Error : VirtualLinkFunctor.isGrouped is pure abstract function, should be re-implemented in subclass");
	return !1
};
skim.engine.linkFunctors.VirtualLinkFunctor.prototype.getGroup = function (a, b) {
	skim.utils.assert(!1, "Error : VirtualLinkFunctor.getGroup is pure abstract function, should be re-implemented in subclass")
};
skim.engine.linkFunctors.VirtualLinkFunctor.prototype.destroyVirtualLinkFunctor = function () {
	delete skim.engine.vars.relations[this.id]
};
skim.engine.linkFunctors.VirtualLinkFunctor.prototype.isEngineManaged = function () {
	return this.is_engine_managed
};
skim.engine.linkFunctors.VirtualLinkFunctor.prototype.setEngineManaged = function (a) {
	(this.is_engine_managed = a) ? skim.engine.vars.relations[this.id] = this : delete skim.engine.vars.relations[this.id]
};
skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey = {};
skim.engine.linkFunctors.VirtualLinkFunctor.prototype.getJSON = function (a, b, c, d) {
	skim.utils.assert(!1, "Error : VirtualLinkFunctor.getJSON is pure abstract function, should be re-implemented in subclass");
	return {}

};
skim.engine.linkFunctors.VertexVirtualLinkFunctor = function () {
	skim.engine.linkFunctors.VirtualLinkFunctor.call(this)
};
skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype = Object.create(skim.engine.linkFunctors.VirtualLinkFunctor.prototype);
skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype.constructor = skim.engine.linkFunctors.VertexVirtualLinkFunctor;
skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype.propagateChange = function (a, b) {
	skim.utils.assert(!1, "Error : propagateChange is pure virtual function, should be reimplemented in subclasses")
};
skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype.onDestroy = function (a) {
	skim.utils.assert(!1, "Error : propagateChange is pure virtual function, should be reimplemented in subclasses")
};
skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor = function () {
	skim.engine.linkFunctors.VirtualLinkFunctor.call(this)
};
skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.prototype = Object.create(skim.engine.linkFunctors.VirtualLinkFunctor.prototype);
skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.prototype.constructor = skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor;
skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.prototype.propagateChange = function (a, b) {
	skim.utils.assert(!1, "Error : propagateChange is pure virtual function, should be reimplemented in subclasses")
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis = function (a, b, c) {
	skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.call(this);
	skim.utils.assert(a instanceof skim.engine.TriangleDef && (null === b || b instanceof skim.engine.TriangleDef), "Error : TriPlaneSymmetryAxis can only operate on TriangleDef");
	skim.utils.assert(void 0 !== b, "Error : TriPlaneSymmetryAxis does need 2 triangles, or at least a null pointer to be clean");
	this.a = c;
	this.otherAxis = {
		x : "x",
		y : "y",
		z : "z"
	};
	delete this.otherAxis[this.a];
	this.tridef0 =
		a;
	if (null !== b)
		this.tridef1 = b, skim.utils.assert(null !== this.getVSymAxisFunctor(a.v[0]) && null !== this.getVSymAxisFunctor(b.v[0]), "Error : creating a symmetry relationship between 2 triangles of which vertices have no relationship"), skim.utils.assert(null !== this.getVSymAxisFunctor(a.v[1]) && null !== this.getVSymAxisFunctor(b.v[1]), "Error : creating a symmetry relationship between 2 triangles of which vertices have no relationship"), skim.utils.assert(null !== this.getVSymAxisFunctor(a.v[2]) && null !== this.getVSymAxisFunctor(b.v[2]),
			"Error : creating a symmetry relationship between 2 triangles of which vertices have no relationship");
	else {
		b = this.getVSymAxisFunctor(a.v[0]);
		null === b && (b = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.v[0], null, this.a));
		c = this.getVSymAxisFunctor(a.v[1]);
		null === c && (c = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.v[1], null, this.a));
		var d = this.getVSymAxisFunctor(a.v[2]);
		null === d && (d = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.v[2], null, this.a));
		b = [b.getSym(a.v[0]), c.getSym(a.v[1]), d.getSym(a.v[2])];
		a = new skim.engine.TriangleDef(b, a.materials, a.getVolType());
		a.commit();
		this.tridef1 = a
	}
	a = this.tridef0.getLinkFunctorByClass(skim.engine.linkFunctors.TriPlaneSymmetryAxis);
	for (b = 0; b < a.length; ++b)
		skim.utils.assert(a[b].getAxis() != this.a, "Error : cannot insert 2 links functors of the exact same type (" + this.a + ")");
	a = this.tridef1.getLinkFunctorByClass(skim.engine.linkFunctors.TriPlaneSymmetryAxis);
	for (b = 0; b < a.length; ++b)
		skim.utils.assert(a[b].getAxis() != this.a, "Error : cannot insert 2 links functors of the exact same type (" +
			this.a + ")");
	this.tridef0.insertLinkFunctor(this, -1);
	this.tridef1.insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype = Object.create(skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.constructor = skim.engine.linkFunctors.TriPlaneSymmetryAxis;
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getAxis = function () {
	return this.a
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getVSymAxisFunctor = function (a) {
	a = a.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis);
	for (var b = 0; b < a.length; ++b)
		if (a[b].getAxis() == this.a)
			return a[b];
	return null
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getSym = function (a) {
	skim.utils.assert(this.tridef0 === a || this.tridef1 === a, "Error : impossible to get sym of an unknown triangle");
	return a === this.tridef0 ? this.tridef1 : this.tridef0
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getTriDef0 = function () {
	return this.tridef0
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getTriDef1 = function () {
	return this.tridef1
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getLinkMaster = function () {
	return this.getTridef0()
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.isGrouped = function () {
	var a = this.getVSymAxisFunctor(this.tridef0.v[0]).isGrouped(),
	b = this.getVSymAxisFunctor(this.tridef0.v[1]).isGrouped(),
	c = this.getVSymAxisFunctor(this.tridef0.v[2]).isGrouped();
	return a && b && c
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getGroup = function (a, b) {
	void 0 === a[this.id] && (a[this.id] = !0, this.isGrouped() && (b[this.tridef0.id] = this.tridef0, b[this.tridef1.id] = this.tridef1, this.tridef0.getGroup(a, b), this.tridef1.getGroup(a, b)))
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.propagateChange = function (a, b) {
	for (var c = a === this.tridef0 ? this.tridef1 : this.tridef0, d = Object.keys(this.otherAxis), e = 0; e < d.length; ++e);
	skim.Material.areEqualsArrays(a.getMaterials(), c.getMaterials()) && a.getVolType() === c.getVolType() || (c.setMaterials(a.getMaterials()), c.setVolType(a.getVolType()), void 0 === b[c.id] && (b[c.id] = c, b.order.push(c)))
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.destroy = function () {
	this.tridef0.removeLinkFunctor(this);
	this.tridef1.removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.onDestroy = function (a) {
	skim.utils.assert(a === this.tridef0 || a === this.tridef1, "Error : onDestroy called on an unknown SegmentDef");
	a = a === this.tridef0 ? this.tridef1 : this.tridef0;
	this.destroy();
	void 0 !== skim.engine.vars.primitives[a.id] && a.destroy()
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.buildFromJSON = function (a, b, c) {
	b = skim.engine.TriangleDef.JSONKey;
	return new skim.engine.linkFunctors.TriPlaneSymmetryAxis(c[b][a.t0], c[b][a.t1], a.a)
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.JSONKey = "tpsa";
skim.utils.assert(void 0 === skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.TriPlaneSymmetryAxis.JSONKey], "Error : token" + skim.engine.linkFunctors.TriPlaneSymmetryAxis.JSONKey + " already register (by another primitive?)");
skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.TriPlaneSymmetryAxis.JSONKey] = skim.engine.linkFunctors.TriPlaneSymmetryAxis.buildFromJSON;
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getJSONKey = function () {
	return skim.engine.linkFunctors.TriPlaneSymmetryAxis.JSONKey
};
skim.engine.linkFunctors.TriPlaneSymmetryAxis.prototype.getJSON = function (a, b, c, d) {
	return {
		t0 : d[this.tridef0.id],
		t1 : d[this.tridef1.id],
		a : this.a
	}
};
skim.engine.linkFunctors.CSgroupedAngles = function (a) {
	skim.engine.linkFunctors.VertexVirtualLinkFunctor.call(this);
	this.vdefs = [];
	this.minAngle = a
};
skim.engine.linkFunctors.CSgroupedAngles.prototype = Object.create(skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.CSgroupedAngles.prototype.constructor = skim.engine.linkFunctors.CSgroupedAngles;
skim.engine.linkFunctors.CSgroupedAngles.prototype.addControlSets = function (a) {
	skim.utils.assert(4 === a.length, "CSMinAngles: Control sets have 4 vertices only");
	this.vdefs = this.vdefs.concat(a);
	for (var b = 0; b < a.length; ++b)
		a[b].insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.CSgroupedAngles.prototype.propagateChange = function (a, b) {};
skim.engine.linkFunctors.CSgroupedAngles.prototype.getGroup = function (a, b) {
	if (void 0 === a[this.id]) {
		a[this.id] = !0;
		for (var c = 0, d = []; c < this.vdefs.length; c += 4)
			d.push(skim.geometry.GetXAngleFromPoint(this.vdefs[c].getPos()));
		for (var e = Object.keys(b), f = 0; f < e.length; f++) {
			for (var g = b[e[f]], c = 0, h = -1, k = -1; c < this.vdefs.length; c++)
				this.vdefs[c].id === g.id && (h = Math.floor(c / 4), k = c);
			if (-1 !== h && -1 !== k)
				for (g = c = 0; c < d.length; c++)
					c !== h && (g = d[c] - d[h], Math.abs(g) < this.minAngle && (g = 4 * c + k - 4 * h, b[this.vdefs[g].id] = this.vdefs[g],
							this.vdefs[g].getGroup(a, b)))
		}
	}
};
skim.engine.linkFunctors.CSgroupedAngles.prototype.destroy = function () {
	for (var a = 0; a < this.vdefs.length; ++a)
		this.vdefs[a].removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.CSgroupedAngles.prototype.onDestroy = function (a) {
	for (var b = 0, c = -1; b < this.vdefs.length; b++)
		this.vdefs[b].id === a.id && (c = 4 * Math.floor(b / 4));
	if (-1 !== c) {
		for (b = c; b < c + 4; b++)
			this.vdefs[b].removeLinkFunctor(this), void 0 !== skim.engine.vars.vertices[this.vdefs[b].id] && this.vdefs[b].destroy();
		this.vdefs.splice(c, 4)
	}
	0 === this.vdefs.length && this.destroy()
};
skim.engine.linkFunctors.PlaneSymmetry = function () {
	skim.engine.linkFunctors.VirtualLinkFunctor.call(this)
};
skim.engine.linkFunctors.PlaneSymmetry.prototype = Object.create(skim.engine.linkFunctors.VirtualLinkFunctor.prototype);
skim.engine.linkFunctors.PlaneSymmetry.prototype.constructor = skim.engine.linkFunctors.PlaneSymmetry;
skim.engine.linkFunctors.RadialSymmetry = function () {
	skim.engine.linkFunctors.VirtualLinkFunctor.call(this)
};
skim.engine.linkFunctors.RadialSymmetry.prototype = Object.create(skim.engine.linkFunctors.VirtualLinkFunctor.prototype);
skim.engine.linkFunctors.RadialSymmetry.prototype.constructor = skim.engine.linkFunctors.RadialSymmetry;
skim.engine.linkFunctors.VPlaneSymmetry = function (a, b) {
	skim.engine.linkFunctors.VertexVirtualLinkFunctor.call(this);
	this.vdef0 = a;
	this.vdef1 = b;
	this.vdef0.insertLinkFunctor(this, -1);
	this.vdef1.insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.VPlaneSymmetry.prototype = Object.create(skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.VPlaneSymmetry.prototype.constructor = skim.engine.linkFunctors.VertexVirtualLinkFunctor;
skim.engine.linkFunctors.VPlaneSymmetry.prototype.getVDef0 = function () {
	return this.vdef0
};
skim.engine.linkFunctors.VPlaneSymmetry.prototype.getVDef1 = function () {
	return this.vdef1
};
skim.engine.linkFunctors.VPlaneSymmetry.prototype.getLinkMaster = function () {
	return this.getVDef0()
};
skim.engine.linkFunctors.VPlaneSymmetry.prototype.getSym = function (a) {
	skim.utils.assert(this.vdef0 === a || this.vdef1 === a, "Error : impossible to get sym of an unknown vdef");
	return a === this.vdef0 ? this.vdef1 : this.vdef0
};
skim.engine.linkFunctors.VPlaneSymmetry.prototype.getGroup = function (a, b) {
	void 0 === a[this.id] && (a[this.id] = !0, this.isGrouped() && (b[this.vdef0.id] = this.vdef0, b[this.vdef1.id] = this.vdef1, this.vdef0.getGroup(a, b), this.vdef1.getGroup(a, b)))
};
skim.engine.linkFunctors.VPlaneSymmetry.prototype.onDestroy = function (a) {
	a = a === this.vdef0 ? this.vdef1 : this.vdef0;
	this.destroy();
	void 0 !== skim.engine.vars.vertices[a.id] && a.destroy()
};
skim.engine.linkFunctors.VPlaneSymmetry.prototype.destroy = function () {
	for (var a = 0; a < this.vdefs.length; ++a)
		this.vdef0.removeLinkFunctor(this), this.vdef1.removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.VPlaneSymmetryAxis = function (a, b, c) {
	skim.utils.assert(void 0 !== b, "Error : SymmetryX does need 2 vertices, or at least a null pointer to be clean");
	skim.utils.assert(null === b || skim.utils.isApproxEqual(a.getPos()[c], -b.getPos()[c], skim.engine.functorPrecision), "Error : SymmetryAxis does need 2 sym vertices, or at least a null pointer to be clean");
	this.a = c;
	this.otherAxis = {
		x : "x",
		y : "y",
		z : "z"
	};
	delete this.otherAxis[this.a];
	c = null;
	null !== b ? c = b : (c = a.getPos().clone(), c[this.a] = -c[this.a],
			c = new skim.engine.VertexDef(c, a.getThickness(), a.getMaterial().clone(), a.getVolType()), c.commit());
	b = a.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis);
	for (var d = 0; d < b.length; ++d)
		skim.utils.assert(b[d].getAxis() != this.a, "Error : cannot add a second VPlaneSymmetryAxis relation in the same axis (" + this.a + ")");
	skim.engine.linkFunctors.VPlaneSymmetry.call(this, a, c)
};
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype = Object.create(skim.engine.linkFunctors.VPlaneSymmetry.prototype);
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype.constructor = skim.engine.linkFunctors.VPlaneSymmetryAxis;
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype.getAxis = function () {
	return this.a
};
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype.swapVertex = function (a, b) {
	for (var c = b.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis), d = 0; d < c.length; ++d)
		c[d].getAxis() == this.a && skim.utils.assert(!1, "Cannot swap vertex in a VPlaneSymmetry if the vertex already has a link of this type");
	a === this.vdef0 ? (this.vdef0.removeLinkFunctor(this), this.vdef0 = b) : (skim.utils.assert(a === this.vdef1, "Error : cannot swap an inexisting vertex..."), this.vdef1.removeLinkFunctor(this), this.vdef1 =
			b);
	b.insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype.isGrouped = function () {
	return skim.utils.isApproxEqual(this.vdef0.getPos()[this.a], 0, this.vdef0.getThickness() * skim.engine.functorPrecision)
};
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype.propagateChange = function (a, b) {
	for (var c = a === this.vdef0 ? this.vdef1 : this.vdef0, d = Object.keys(this.otherAxis), e = 0, f = !1; e < d.length; ++e)
		var g = this.otherAxis[d[e]], f = f || !skim.utils.isApproxEqual(c.getPos()[g], a.getPos()[g], skim.engine.functorPrecision);
	d = a.getPos().clone();
	d[this.a] = -d[this.a];
	skim.utils.isApproxEqual(c.getPos()[this.a], d[this.a], skim.engine.functorPrecision) && skim.utils.isApproxEqual(c.getThickness(), a.getThickness(), skim.engine.functorPrecision) &&
	!f && a.getMaterial().equals(c.getMaterial()) && a.getVolType() === c.getVolType() || (!c.setVertex(d.x, d.y, d.z, a.getThickness(), a.getMaterial(), a.getVolType()) || void 0 !== b[c.id]) || (b[c.id] = c, b.order.push(c))
};
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype.destroy = function () {
	this.vdef0.removeLinkFunctor(this);
	this.vdef1.removeLinkFunctor(this);
	for (var a = this.vdef0.getOwnersSegments(), b = Object.keys(a), c = 0; c < b.length; ++c)
		for (var d = a[b[c]].getLinkFunctorByClass(skim.engine.linkFunctors.SegPlaneSymmetryAxis), e = 0; e < d.length; ++e)
			d[e].a == this.a && d[e].destroy();
	a = this.vdef0.getOwnersTriangles();
	b = Object.keys(a);
	for (c = 0; c < b.length; ++c)
		for (d = a[b[c]].getLinkFunctorByClass(skim.engine.linkFunctors.TriPlaneSymmetryAxis),
			e = 0; e < d.length; ++e)
			d[e].a == this.a && d[e].destroy();
	0 === this.vdef0[this.a] && skim.engine.mergeVertexDef(this.vdef0, this.vdef1);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.VPlaneSymmetryAxis.buildFromJSON = function (a, b, c) {
	return new skim.engine.linkFunctors.VPlaneSymmetryAxis(b[a.v0], b[a.v1], a.a)
};
skim.engine.linkFunctors.VPlaneSymmetryAxis.JSONKey = "vpsa";
skim.utils.assert(void 0 === skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.VPlaneSymmetryAxis.JSONKey], "Error : token" + skim.engine.linkFunctors.VPlaneSymmetryAxis.JSONKey + " already register (by another primitive?)");
skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.VPlaneSymmetryAxis.JSONKey] = skim.engine.linkFunctors.VPlaneSymmetryAxis.buildFromJSON;
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype.getJSONKey = function () {
	return skim.engine.linkFunctors.VPlaneSymmetryAxis.JSONKey
};
skim.engine.linkFunctors.VPlaneSymmetryAxis.prototype.getJSON = function (a, b, c, d) {
	return {
		v0 : c[this.vdef0.id],
		v1 : c[this.vdef1.id],
		a : this.a
	}
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis = function (a, b, c) {
	skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.call(this);
	skim.utils.assert(a instanceof skim.engine.SegmentDef && (null === b || b instanceof skim.engine.SegmentDef), "Error : SegPlaneSymmetryAxis can only operate on SegmentDef");
	skim.utils.assert(void 0 !== b, "Error : SegPlaneSymmetryAxis does need 2 segments, or at least a null pointer to be clean");
	this.a = c;
	this.otherAxis = {
		x : "x",
		y : "y",
		z : "z"
	};
	delete this.otherAxis[this.a];
	this.segdef0 =
		a;
	null !== b ? (this.segdef1 = b, skim.utils.assert(null !== this.getVSymAxisFunctor(a.v[0]) && null !== this.getVSymAxisFunctor(b.v[0]), "Error : creating a symmetry relationship between 2 segments of which vertices have no relationship"), skim.utils.assert(null !== this.getVSymAxisFunctor(a.v[1]) && null !== this.getVSymAxisFunctor(b.v[1]), "Error : creating a symmetry relationship between 2 segments of which vertices have no relationship")) : (b = this.getVSymAxisFunctor(a.v[0]), null === b && (b = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.v[0],
					null, this.a)), c = this.getVSymAxisFunctor(a.v[1]), null === c && (c = new skim.engine.linkFunctors.VPlaneSymmetryAxis(a.v[1], null, this.a)), b = [b.getSym(a.v[0]), c.getSym(a.v[1])], c = null, null !== a.materials && (c = [a.materials[0].clone(), a.materials[1].clone()]), a = new skim.engine.SegmentDef(b, c, a.getVolType()), a.commit(), this.segdef1 = a);
	a = this.segdef0.getLinkFunctorByClass(skim.engine.linkFunctors.SegPlaneSymmetryAxis);
	for (b = 0; b < a.length; ++b)
		skim.utils.assert(a[b].getAxis() != this.a, "Error : cannot insert 2 links functors of the exact same type (" +
			this.a + ")");
	a = this.segdef1.getLinkFunctorByClass(skim.engine.linkFunctors.SegPlaneSymmetryAxis);
	for (b = 0; b < a.length; ++b)
		skim.utils.assert(a[b].getAxis() != this.a, "Error : cannot insert 2 links functors of the exact same type (" + this.a + ")");
	this.segdef0.insertLinkFunctor(this, -1);
	this.segdef1.insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype = Object.create(skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.constructor = skim.engine.linkFunctors.SegPlaneSymmetryAxis;
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getAxis = function () {
	return this.a
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getVSymAxisFunctor = function (a) {
	a = a.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis);
	for (var b = 0; b < a.length; ++b)
		if (a[b].getAxis() == this.a)
			return a[b];
	return null
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getSym = function (a) {
	skim.utils.assert(this.segdef0 === a || this.segdef1 === a, "Error : impossible to get sym of an unknown segment");
	return a === this.segdef0 ? this.segdef1 : this.segdef0
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getSegDef0 = function () {
	return this.segdef0
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getSegDef1 = function () {
	return this.segdef1
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getLinkMaster = function () {
	return this.getSegDef0()
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.isGrouped = function () {
	var a = this.getVSymAxisFunctor(this.segdef0.v[0]).isGrouped(),
	b = this.getVSymAxisFunctor(this.segdef0.v[1]).isGrouped();
	return a && b
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getGroup = function (a, b) {
	void 0 === a[this.id] && (a[this.id] = !0, this.isGrouped() && (b[this.segdef0.id] = this.segdef0, b[this.segdef1.id] = this.segdef1, this.segdef0.getGroup(a, b), this.segdef1.getGroup(a, b)))
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.propagateChange = function (a, b) {
	for (var c = a === this.segdef0 ? this.segdef1 : this.segdef0, d = Object.keys(this.otherAxis), e = 0; e < d.length; ++e);
	skim.Material.areEqualsArrays(a.getMaterials(), c.getMaterials()) && a.getVolType() === c.getVolType() || (c.setMaterials(a.getMaterials()), c.setVolType(a.getVolType()), void 0 === b[c.id] && (b[c.id] = c, b.order.push(c)))
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.destroy = function () {
	this.segdef0.removeLinkFunctor(this);
	this.segdef1.removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.onDestroy = function (a) {
	skim.utils.assert(a === this.segdef0 || a === this.segdef1, "Error : onDestroy called on an unknown SegmentDef");
	a = a === this.segdef0 ? this.segdef1 : this.segdef0;
	this.destroy();
	void 0 !== skim.engine.vars.primitives[a.id] && a.destroy()
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.buildFromJSON = function (a, b, c) {
	b = skim.engine.SegmentDef.JSONKey;
	return new skim.engine.linkFunctors.SegPlaneSymmetryAxis(c[b][a.s0], c[b][a.s1], a.a)
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.JSONKey = "spsa";
skim.utils.assert(void 0 === skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.SegPlaneSymmetryAxis.JSONKey], "Error : token" + skim.engine.linkFunctors.SegPlaneSymmetryAxis.JSONKey + " already register (by another primitive?)");
skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.SegPlaneSymmetryAxis.JSONKey] = skim.engine.linkFunctors.SegPlaneSymmetryAxis.buildFromJSON;
skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey.spsa = skim.engine.linkFunctors.SegPlaneSymmetryAxis.buildFromJSON;
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getJSONKey = function () {
	return skim.engine.linkFunctors.SegPlaneSymmetryAxis.JSONKey
};
skim.engine.linkFunctors.SegPlaneSymmetryAxis.prototype.getJSON = function (a, b, c, d) {
	return {
		s0 : d[this.segdef0.id],
		s1 : d[this.segdef1.id],
		a : this.a
	}
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis = function (a, b, c) {
	skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.call(this);
	skim.utils.assert(a instanceof skim.engine.MeshDef && (null === b || b instanceof skim.engine.MeshDef), "Error : MeshPlaneSymmetryAxis can only operate on MeshDef");
	skim.utils.assert(void 0 !== b, "Error : MeshPlaneSymmetryAxis does need 2 meshe, or at least a null pointer to be clean");
	this.a = c;
	this.otherAxis = {
		x : "x",
		y : "y",
		z : "z"
	};
	delete this.otherAxis[this.a];
	this.meshdef0 = a;
	null !==
	b ? this.meshdef1 = b : (skim.utils.assert(0 === a.v.length, "Error : MeshPlaneSymmetryAxis has not been coded for MeshDef with skim vertices"), b = null, null !== a.materials && (b = [a.materials[0].clone()]), skim.utils.assert(!1, "TODO : implement the next line correctly"), a = new skim.engine.MeshDef([], a.abmesh.clone(), b, a.getVolType()), a.commit(), this.meshdef1 = a);
	a = this.meshdef0.getLinkFunctorByClass(skim.engine.linkFunctors.MeshPlaneSymmetryAxis);
	for (b = 0; b < a.length; ++b)
		skim.utils.assert(a[b].getAxis() != this.a, "Error : cannot insert 2 links functors of the exact same type (" +
			this.a + ")");
	a = this.meshdef1.getLinkFunctorByClass(skim.engine.linkFunctors.MeshPlaneSymmetryAxis);
	for (b = 0; b < a.length; ++b)
		skim.utils.assert(a[b].getAxis() != this.a, "Error : cannot insert 2 links functors of the exact same type (" + this.a + ")");
	this.meshdef0.insertLinkFunctor(this, -1);
	this.meshdef1.insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype = Object.create(skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.constructor = skim.engine.linkFunctors.MeshPlaneSymmetryAxis;
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.getAxis = function () {
	return this.a
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.getSym = function (a) {
	skim.utils.assert(this.meshdef0 === a || this.meshdef1 === a, "Error : impossible to get sym of an unknown mesh");
	return a === this.meshdef0 ? this.meshdef1 : this.meshdef0
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.getMeshDef0 = function () {
	return this.meshdef0
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.getMeshDef1 = function () {
	return this.meshdef1
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.getLinkMaster = function () {
	return this.getMeshDef0()
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.isGrouped = function () {
	return !1
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.getGroup = function (a, b) {
	void 0 === a[this.id] && (a[this.id] = !0, this.isGrouped() && (b[this.meshdef0.id] = this.meshdef0, b[this.meshdef1.id] = this.meshdef1, this.meshdef0.getGroup(a, b), this.meshdef1.getGroup(a, b)))
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.propagateChange = function (a, b) {
	for (var c = a === this.meshdef0 ? this.meshdef1 : this.meshdef0, d = Object.keys(this.otherAxis), e = 0; e < d.length; ++e);
	skim.Material.areEqualsArrays(a.getMaterials(), c.getMaterials()) && a.getVolType() === c.getVolType() || (c.setMaterials(a.getMaterials()), c.setVolType(a.getVolType()), void 0 === b[c.id] && (b[c.id] = c, b.order.push(c)))
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.destroy = function () {
	this.meshdef0.removeLinkFunctor(this);
	this.meshdef1.removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.onDestroy = function (a) {
	skim.utils.assert(a === this.meshdef0 || a === this.meshdef1, "Error : onDestroy called on an unknown MeshDef");
	a = a === this.meshdef0 ? this.meshdef1 : this.meshdef0;
	this.destroy();
	void 0 !== skim.engine.vars.primitives[a.id] && a.destroy()
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.buildFromJSON = function (a, b, c) {
	b = skim.engine.MeshDef.JSONKey;
	return new skim.engine.linkFunctors.MeshPlaneSymmetryAxis(c[b][a.s0], c[b][a.s1], a.a)
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.JSONKey = "meshpsa";
skim.utils.assert(void 0 === skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.MeshPlaneSymmetryAxis.JSONKey], "Error : token" + skim.engine.linkFunctors.MeshPlaneSymmetryAxis.JSONKey + " already register (by another primitive?)");
skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.MeshPlaneSymmetryAxis.JSONKey] = skim.engine.linkFunctors.MeshPlaneSymmetryAxis.buildFromJSON;
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.getJSONKey = function () {
	return skim.engine.linkFunctors.MeshPlaneSymmetryAxis.JSONKey
};
skim.engine.linkFunctors.MeshPlaneSymmetryAxis.prototype.getJSON = function (a, b, c, d) {
	return {
		m0 : d[this.meshdef0.id],
		m1 : d[this.meshdef1.id],
		a : this.a
	}
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis = function (a, b, c) {
	skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.call(this);
	skim.utils.assert(a instanceof skim.engine.RingDef && (null === b || b instanceof skim.engine.RingDef), "Error : RingPlaneSymmetryAxis can only operate on RingDef");
	skim.utils.assert(void 0 !== b, "Error : RingPlaneSymmetryAxis does need 2 rings, or at least a null pointer to be clean");
	this.a = c;
	this.otherAxis = {
		x : "x",
		y : "y",
		z : "z"
	};
	delete this.otherAxis[this.a];
	this.ringdef0 = a;
	if (null !==
		b)
		for (this.ringdef1 = b, skim.utils.assert(this.ringdef1.v.length == this.ringdef0.v.length, "Error : the 2 rings to be symmetrics do not have the same number of vertices... ca commence mal."), b = 0; b < this.ringdef0.v.length; ++b)
			skim.utils.assert(void 0 !== this.getVSymAxisFunctor(this.ringdef0.v[b])[this.getAxis()] && void 0 !== this.getVSymAxisFunctor(this.ringdef1.v[b])[this.getAxis()], "Error : creating a symmetry relationship between 2 rings of which some vertices have no relationship");
	else {
		c = [];
		for (b = 0; b <
			this.ringdef0.v.length; ++b)
			c.push(this.getVSymAxisFunctor(this.ringdef0.v[b])), void 0 === c[c.length - 1][this.a] && (c[c.length - 1][this.a] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(this.ringdef0.v[b], null, this.a));
		for (b = 0; b < this.ringdef0.v.length; ++b)
			for (var d = this.ringdef0.v[b], e = c[b], f = e[this.a].getSym(d), g = this.getVSymAxisFunctor(f), h = Object.keys(e), k = 0; k < h.length; ++k)
				if (h[k] != this.a) {
					var l = e[h[k]].getSym(d);
					if (void 0 !== l.getOwnersRings()[this.ringdef0.id]) {
						var l = this.getVSymAxisFunctor(l)[this.a].getSym(l),
						m = this.getVSymAxisFunctor(l);
						void 0 === m[h[k]] && void 0 === g[h[k]] ? m[h[k]] = new skim.engine.linkFunctors.VPlaneSymmetryAxis(l, f, h[k]) : skim.utils.assert(g[h[k]].getSym(f) === l && m[h[k]].getSym(l) === f, "Error : symmetric scheme is invalid")
					}
				}
		d = [];
		for (b = 0; b < this.ringdef0.v.length; b += 4)
			d.push(c[b + 3][this.a].getSym(this.ringdef0.v[b + 3])), d.push(c[b + 2][this.a].getSym(this.ringdef0.v[b + 2])), d.push(c[b + 1][this.a].getSym(this.ringdef0.v[b + 1])), d.push(c[b][this.a].getSym(this.ringdef0.v[b]));
		a = new skim.engine.RingDef(d,
				a.getVolType());
		a.commit();
		this.ringdef1 = a
	}
	a = this.ringdef0.getLinkFunctorByClass(skim.engine.linkFunctors.RingPlaneSymmetryAxis);
	for (b = 0; b < a.length; ++b)
		skim.utils.assert(a[b].getAxis() != this.a, "Error : cannot insert 2 links functors of the exact same type (" + this.a + ")");
	a = this.ringdef1.getLinkFunctorByClass(skim.engine.linkFunctors.RingPlaneSymmetryAxis);
	for (b = 0; b < a.length; ++b)
		skim.utils.assert(a[b].getAxis() != this.a, "Error : cannot insert 2 links functors of the exact same type (" + this.a + ")");
	this.ringdef0.insertLinkFunctor(this,
		-1);
	this.ringdef1.insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype = Object.create(skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.constructor = skim.engine.linkFunctors.RingPlaneSymmetryAxis;
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getAxis = function () {
	return this.a
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getVSymAxisFunctor = function (a) {
	a = a.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis);
	for (var b = {}, c = 0; c < a.length; ++c)
		b[a[c].getAxis()] = a[c];
	return b
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getSym = function (a) {
	skim.utils.assert(this.ringdef0 === a || this.ringdef1 === a, "Error : impossible to get sym of an unknown ring");
	return a === this.ringdef0 ? this.ringdef1 : this.ringdef0
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getRingDef0 = function () {
	return this.ringdef0
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getRingDef1 = function () {
	return this.ringdef1
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getLinkMaster = function () {
	return this.getRingDef0()
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.isGrouped = function () {
	return !1
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getGroup = function (a, b) {
	a[this.id] = !0
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.destroy = function () {
	this.ringdef0.removeLinkFunctor(this);
	this.ringdef1.removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.propagateChange = function (a, b) {
	for (var c = a === this.ringdef0 ? this.ringdef1 : this.ringdef0, d = Object.keys(this.otherAxis), e = 0; e < d.length; ++e);
	skim.Material.areEqualsArrays(a.getMaterials(), c.getMaterials()) && a.getVolType() === c.getVolType() || (c.setMaterials(a.getMaterials()), c.setVolType(a.getVolType()), void 0 === b[c.id] && (b[c.id] = c, b.order.push(c)))
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.onDestroy = function (a) {
	skim.utils.assert(a === this.ringdef0 || a === this.ringdef1, "Error : onDestroy called on an unknown RingDef");
	a = a === this.ringdef0 ? this.ringdef1 : this.ringdef0;
	this.destroy();
	void 0 !== skim.engine.vars.primitives[a.id] && a.destroy()
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.buildFromJSON = function (a, b, c) {
	b = skim.engine.RingDef.JSONKey;
	return new skim.engine.linkFunctors.RingPlaneSymmetryAxis(c[b][a.r0], c[b][a.r1], a.a)
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.JSONKey = "rpsa";
skim.utils.assert(void 0 === skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.RingPlaneSymmetryAxis.JSONKey], "Error : token" + skim.engine.linkFunctors.RingPlaneSymmetryAxis.JSONKey + " already register (by another primitive?)");
skim.engine.linkFunctors.VirtualLinkFunctor.RegisterJSONKey[skim.engine.linkFunctors.RingPlaneSymmetryAxis.JSONKey] = skim.engine.linkFunctors.RingPlaneSymmetryAxis.buildFromJSON;
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getJSONKey = function () {
	return skim.engine.linkFunctors.RingPlaneSymmetryAxis.JSONKey
};
skim.engine.linkFunctors.RingPlaneSymmetryAxis.prototype.getJSON = function (a, b, c, d) {
	return {
		r0 : d[this.ringdef0.id],
		r1 : d[this.ringdef1.id],
		a : this.a
	}
};
skim.engine.linkFunctors.VRadialSymmetry = function (a, b, c, d, e, f) {
	skim.engine.linkFunctors.RadialSymmetry.call(this);
	skim.utils.assert(a.length == b.length, "Error : the array of vdefs and array of thicknesses must have the same length");
	skim.utils.assert(f.length == a.length - 1, "Error : vdefs.length-1 should be angles.length");
	this.vdefs = a;
	this.scale = b;
	this.scale_radius = c;
	this.dir = d.normalize();
	this.origin = e;
	this.angles = f;
	b = 0;
	c = a[0];
	for (skim.utils.assert(void 0 !== c, "Error : vdefs must contain at least 2 vertices"); null ===
		c && b < a.length; )
		b++, c = a[b];
	skim.utils.assert(null !== c, "Error : vdefs should contain at least 1 non null vertex");
	a = this.computeOrthoDir(c);
	for (c = 0; c < this.vdefs.length; ++c)
		c != b && (d = this.scale[c] / this.scale[b], e = new THREE.Matrix4, e.identity(), f = new THREE.Matrix4, f.makeRotationAxis(this.dir, this.getAngleFromItoJ(b, c)), e.multiply(f), f.makeTranslation(this.scale_radius * a.x, this.scale_radius * a.y, this.scale_radius * a.z), e.multiply(f), f.makeScale(d, d, d), e.multiply(f), f.makeTranslation(-this.scale_radius * a.x,
				-this.scale_radius * a.y, -this.scale_radius * a.z), e.multiply(f), f = this.vdefs[b].getPos().clone(), f.sub(this.origin), f.applyMatrix4(e), f.add(this.origin), null !== this.vdefs[c] ? skim.utils.assert((new THREE.Vector3).subVectors(f, this.vdefs[c].getPos()).length() < skim.engine.functorPrecision, "ERROR : vertices given have bad positions.") : (this.vdefs[c] = new skim.engine.VertexDef(f, this.vdefs[b].getThickness() * d, this.vdefs[b].getMaterial().clone(), this.vdefs[b].getVolType()), this.vdefs[c].commit()));
	for (c = 0; c <
		this.vdefs.length; ++c)
		this.vdefs[c].insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.VRadialSymmetry.prototype = Object.create(skim.engine.linkFunctors.RadialSymmetry.prototype);
skim.engine.linkFunctors.VRadialSymmetry.prototype.constructor = skim.engine.linkFunctors.VRadialSymmetry;
skim.engine.linkFunctors.VRadialSymmetry.prototype.getAngleFromItoJ = function (a, b) {
	var c = 0,
	d = 0,
	e = 0,
	f = 1;
	b >= a ? (d = a, e = b) : (d = b, e = a, f = -1);
	for (; d < e; ++d)
		c += this.angles[d];
	return f * c
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.computeOrthoDir = function (a) {
	var b = new THREE.Vector3;
	a = (new THREE.Vector3).subVectors(a.getPos(), this.origin);
	var c = this.dir.dot(a);
	b.subVectors(a, this.dir.clone().multiplyScalar(c));
	b.normalize();
	return b
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getVDefs = function () {
	return this.vdefs
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getLinkMaster = function () {
	return this.vdefs[0]
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getGroup = function (a, b) {
	void 0 === a[this.id] && (a[this.id] = !0, skim.utils.assert(!this.isGrouped(), "Error : VRadialSymmetry is not supposed to be groupable, else this code does not work"))
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getScale = function () {
	return this.scale
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getVertScale = function (a) {
	for (var b = 0, c = -1; b < this.vdefs.length; b++)
		this.vdefs[b].id === a.id && (c = b);
	return -1 !== c ? this.scale[c] : 1
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getScaleRadius = function () {
	return this.scale_radius
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getDir = function () {
	return this.dir
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getOrigin = function () {
	return this.origin
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.getAngles = function () {
	return this.angles
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.isGrouped = function () {
	return !1
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.propagateChange = function (a, b) {
	for (var c = -1, d = 0; d < this.vdefs.length; ++d)
		if (this.vdefs[d] == a) {
			c = d;
			break
		}
	var e = this.computeOrthoDir(a);
	a.getPos().clone();
	for (var f = [], g = [], d = 0; d < this.vdefs.length; ++d)
		if (d != c) {
			var h = this.vdefs[d],
			h = this.scale[d] / this.scale[c],
			k = new THREE.Matrix4;
			k.identity();
			var l = new THREE.Matrix4;
			l.makeRotationAxis(this.dir, this.getAngleFromItoJ(c, d));
			k.multiply(l);
			l.makeTranslation(this.scale_radius * e.x, this.scale_radius * e.y, this.scale_radius *
				e.z);
			k.multiply(l);
			l.makeScale(h, h, h);
			k.multiply(l);
			l.makeTranslation(-this.scale_radius * e.x, -this.scale_radius * e.y, -this.scale_radius * e.z);
			k.multiply(l);
			f[d] = a.getPos().clone();
			f[d].sub(this.origin);
			f[d].applyMatrix4(k);
			f[d].add(this.origin);
			g[d] = this.vdefs[c].getThickness() * h
		} else
			f[d] = null, g[d] = null;
	for (d = 0; d < this.vdefs.length; ++d)
		d != c && (h = this.vdefs[d], h.setVertex(f[d].x, f[d].y, f[d].z, g[d], h.getMaterial(), h.getVolType()) && void 0 === b[this.vdefs[d].id] && (b[this.vdefs[d].id] = this.vdefs[d], b.order.push(this.vdefs[d])))
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.destroy = function () {
	for (var a = 0; a < this.vdefs.length; ++a)
		this.vdefs[a].removeLinkFunctor(this);
	for (var b = this.vdefs[0].getOwnersSegments(), c = Object.keys(b), a = 0; a < c.length; ++a) {
		var d = b[c[a]].getLinkFunctorByClass(skim.engine.linkFunctors.SegRadialSymmetry);
		skim.utils.assert(1 >= d.length, "Error : VRadialSymmetry : this code is not made to work with multiple RadialSymmetries, assumption is there is only 1 radial sym in the scene");
		for (var e = 0; e < d.length; ++e)
			d[e].destroy()
	}
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.VRadialSymmetry.prototype.onDestroy = function (a) {
	a = a === this.vdef0 ? this.vdef1 : this.vdef0;
	this.destroy();
	for (var b = 0; b < this.vdefs.length; ++b)
		this.vdefs[b] != a && void 0 !== skim.engine.vars.vertices[this.vdefs[b].id] && this.vdefs[b].destroy()
};
skim.engine.linkFunctors.SegRadialSymmetry = function (a, b, c, d, e, f) {
	skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.call(this);
	this.segdefs = a;
	this.scale = b;
	this.scale_radius = c;
	this.dir = d.normalize();
	this.origin = e;
	this.angles = f;
	c = 0;
	var g = a[0];
	for (skim.utils.assert(void 0 !== g, "Error : segdefs must contain at least 2 segments"); null === g && c < a.length; )
		c++, g = a[c];
	skim.utils.assert(null !== g, "Error : segdefs should contain at least 1 non null vertex");
	a = [];
	for (var h = [], k = g.v[0].getLinkFunctorByClass(skim.engine.linkFunctors.VRadialSymmetry),
		l = 0 === k.length ? null : k[0], k = g.v[1].getLinkFunctorByClass(skim.engine.linkFunctors.VRadialSymmetry), m = 0 === k.length ? null : k[0], n = 0; n < this.segdefs.length; ++n)
		null !== this.segdefs[n] ? (a.push(this.segdefs[n].v[0]), h.push(this.segdefs[n].v[1]), k = this.segdefs[n].v[0].getLinkFunctorByClass(skim.engine.linkFunctors.VRadialSymmetry), skim.utils.assert(null === l && 0 === k.length || k[0] === l, "Error : inconstistant radial symmetry on vertices of the segment to symmetrize"), k = this.segdefs[n].v[1].getLinkFunctorByClass(skim.engine.linkFunctors.VRadialSymmetry),
			skim.utils.assert(null === m && 0 === k.length || k[0] === m, "Error : inconstistant radial symmetry on vertices of the segment to symmetrize")) : (a.push(null), h.push(null));
	null === l && (skim.utils.assert(null !== b, "Error : should not be null if we fall in this case"), l = new skim.engine.linkFunctors.VRadialSymmetry(a, b.slice(0, b.length), this.scale_radius, d.clone(), e.clone(), f.slice(0, f.length)));
	null === m && (skim.utils.assert(null !== b, "Error : should not be null if we fall in this case"), m = new skim.engine.linkFunctors.VRadialSymmetry(h,
				b.slice(0, b.length), this.scale_radius, d.clone(), e.clone(), f.slice(0, f.length)));
	for (n = 0; n < this.segdefs.length; ++n)
		n != c && null === this.segdefs[n] && (this.segdefs[n] = new skim.engine.SegmentDef([l.vdefs[n], m.vdefs[n]], null, g.getVolType()), this.segdefs[n].commit());
	for (n = 0; n < this.segdefs.length; ++n)
		skim.utils.assert(0 === this.segdefs[n].getLinkFunctorByClass(skim.engine.linkFunctors.SegRadialSymmetry).length, "Error : the segdefs i already has a radial symmetry :-("), this.segdefs[n].insertLinkFunctor(this,
			-1)
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype = Object.create(skim.engine.linkFunctors.PrimitiveVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.SegRadialSymmetry.prototype.constructor = skim.engine.linkFunctors.SegRadialSymmetry;
skim.engine.linkFunctors.SegRadialSymmetry.prototype.getSegDefs = function () {
	return this.segdefs
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.getLinkMaster = function () {
	return this.segdefs[0]
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.getScale = function () {
	return this.scale
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.getScaleRadius = function () {
	return this.scale_radius
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.getDir = function () {
	return this.dir
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.getOrigin = function () {
	return this.origin
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.getAngles = function () {
	return this.angles
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.isGrouped = function () {
	return !1
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.getGroup = function (a, b) {
	void 0 === a[this.id] && (a[this.id] = !0, skim.utils.assert(!this.isGrouped(), "SegPlaneSymmetryAxis getGroup : not implemented completely : assumption is that elements are not grouped"))
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.destroy = function () {
	for (var a = 0; a < this.segdefs.length; ++a)
		this.segdefs[a].removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.SegRadialSymmetry.prototype.onDestroy = function (a) {
	for (var b = -1, c = 0; c < this.segdefs.length; ++c)
		if (this.segdefs[c] == a) {
			b = c;
			break
		}
	skim.utils.assert(-1 != b, "Error : SegRadialSymmetry.onDestroy called on an unknown SegmentDef");
	this.destroy();
	for (c = 0; c < this.segdefs.length; ++c)
		void 0 !== skim.engine.vars.primitives[this.segdefs[c].id] && this.segdefs[c].destroy()
};
skim.engine.linkFunctors.VRadialCoplanarity = function (a) {
	skim.engine.linkFunctors.VirtualLinkFunctor.call(this);
	this.vdefs = a;
	skim.utils.assert(void 0 !== a[0] && void 0 !== a[1] && void 0 !== a[2] && void 0 !== a[3], "Error : VCoplanarity can only operate on VertexDef");
	skim.utils.assert(4 === a.length, "Error : VRadialCoplanarity functor currently work only with sets of 4 vertices");
	for (a = 0; 4 > a; ++a)
		this.vdefs[a].insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.VRadialCoplanarity.prototype = Object.create(skim.engine.linkFunctors.VirtualLinkFunctor.prototype);
skim.engine.linkFunctors.VRadialCoplanarity.prototype.constructor = skim.engine.linkFunctors.VRadialCoplanarity;
skim.engine.linkFunctors.VRadialCoplanarity.prototype.getVDefs = function () {
	return this.vdefs
};
skim.engine.linkFunctors.VRadialCoplanarity.prototype.propagateChange = function () {
	var a = new THREE.Vector3;
	return function (b, c) {
		for (var d = -1, e = 0; 4 > e; e++)
			b.id === this.vdefs[e].id && (d = e);
		var f = [];
		f.push(0 === d ? this.vdefs[3] : this.vdefs[d - 1]);
		f.push(3 === d ? this.vdefs[0] : this.vdefs[d + 1]);
		f.push(1 >= d ? this.vdefs[d + 2] : this.vdefs[d - 2]);
		for (e = 0; 3 > e; e++) {
			var d = skim.geometry.GetXAngleFromPoint(b.getPos()),
			g = skim.geometry.GetXAngleFromPoint(f[e].getPos()),
			d = d - g;
			Math.abs(d) > skim.engine.functorPrecision && (skim.geometry.RotateVectAroundN(f[e].getPos(),
					skim.geometry.vectZ, d, a), f[e].setVertex(a.x, a.y, a.z, f[e].getThickness(), f[e].getMaterial(), f[e].getVolType()) && void 0 === c[f[e].id] && (c[f[e].id] = f[e], c.order.push(f[e])))
		}
	}
}
();
skim.engine.linkFunctors.VRadialCoplanarity.prototype.destroy = function () {
	for (var a = 0; 4 > a; ++a)
		this.vdefs[a].removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.VRadialCoplanarity.prototype.onDestroy = function (a) {
	this.destroy();
	for (a = 0; 4 > a; ++a)
		void 0 !== skim.engine.vars.vertices[this.vdefs[a].id] && this.vdefs[a].destroy()
};
skim.engine.linkFunctors.VRadialCoplanarity.prototype.getGroup = function (a, b) {
	a[this.id] = !0
};
skim.engine.linkFunctors.VPairHeight = function (a) {
	skim.engine.linkFunctors.VertexVirtualLinkFunctor.call(this);
	this.vdefs = a;
	skim.utils.assert(void 0 !== a[0] && void 0 !== a[1], "Error : VPairHeight can only operate on VertexDef");
	for (a = 0; 2 > a; ++a)
		this.vdefs[a].insertLinkFunctor(this, 0)
};
skim.engine.linkFunctors.VPairHeight.prototype = Object.create(skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.VPairHeight.prototype.constructor = skim.engine.linkFunctors.VPairHeight;
skim.engine.linkFunctors.VPairHeight.prototype.getVDefs = function () {
	return this.vdefs
};
skim.engine.linkFunctors.VPairHeight.prototype.propagateChange = function (a, b) {
	for (var c = 0; 2 > c; c++)
		if (a.id !== this.vdefs[c].id) {
			var d = this.vdefs[c].getPos(),
			e = a.getPos().z;
			!skim.utils.isApproxEqual(d.z, e, skim.engine.functorPrecision) && (this.vdefs[c].setVertex(d.x, d.y, e, this.vdefs[c].getThickness(), this.vdefs[c].getMaterial(), this.vdefs[c].getVolType()) && void 0 === b[this.vdefs[c].id]) && (b[this.vdefs[c].id] = this.vdefs[c], b.order.push(this.vdefs[c]))
		}
};
skim.engine.linkFunctors.VPairHeight.prototype.destroy = function () {
	for (var a = 0; 2 > a; ++a)
		this.vdefs[a].removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.VPairHeight.prototype.onDestroy = function (a) {
	this.destroy();
	for (a = 0; 2 > a; ++a)
		void 0 !== skim.engine.vars.vertices[this.vdefs[a].id] && this.vdefs[a].destroy()
};
skim.engine.linkFunctors.VPairHeight.prototype.getGroup = function (a, b) {
	a[this.id] = !0
};
skim.engine.linkFunctors.VPairRadial = function (a) {
	skim.engine.linkFunctors.VertexVirtualLinkFunctor.call(this);
	this.vdefs = a;
	skim.utils.assert(void 0 !== a[0] && void 0 !== a[1], "Error : VPairRadial can only operate on VertexDef");
	for (a = 0; 2 > a; ++a)
		this.vdefs[a].insertLinkFunctor(this, 0)
};
skim.engine.linkFunctors.VPairRadial.prototype = Object.create(skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.VPairRadial.prototype.constructor = skim.engine.linkFunctors.VPairRadial;
skim.engine.linkFunctors.VPairRadial.prototype.getVDefs = function () {
	return this.vdefs
};
skim.engine.linkFunctors.VPairRadial.prototype.propagateChange = function (a, b) {
	for (var c = 0; 2 > c; c++)
		if (a.id !== this.vdefs[c].id) {
			var d = this.vdefs[c].getPos(),
			e = a.getPos();
			!skim.utils.isApproxEqual(d.x * d.x + d.y * d.y, e.x * e.x + e.y * e.y, skim.engine.functorPrecision * skim.engine.functorPrecision) && (this.vdefs[c].setVertex(e.x, e.y, d.z, this.vdefs[c].getThickness(), this.vdefs[c].getMaterial(), this.vdefs[c].getVolType()) && void 0 === b[this.vdefs[c].id]) && (b[this.vdefs[c].id] = this.vdefs[c], b.order.push(this.vdefs[c]))
		}
};
skim.engine.linkFunctors.VPairRadial.prototype.destroy = function () {
	for (var a = 0; 2 > a; ++a)
		this.vdefs[a].removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.VPairRadial.prototype.onDestroy = function (a) {
	this.destroy();
	for (a = 0; 2 > a; ++a)
		void 0 !== skim.engine.vars.vertices[this.vdefs[a].id] && this.vdefs[a].destroy()
};
skim.engine.linkFunctors.VPairRadial.prototype.getGroup = function (a, b) {
	a[this.id] = !0
};
skim.engine.linkFunctors.CSMinAngles = function (a) {
	skim.engine.linkFunctors.VertexVirtualLinkFunctor.call(this);
	this.vdefs = [];
	this.minAngle = a
};
skim.engine.linkFunctors.CSMinAngles.prototype = Object.create(skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.CSMinAngles.prototype.constructor = skim.engine.linkFunctors.CSMinAngles;
skim.engine.linkFunctors.CSMinAngles.prototype.addControlSets = function (a) {
	skim.utils.assert(4 === a.length, "CSMinAngles: Control sets have 4 vertices only");
	this.vdefs = this.vdefs.concat(a);
	for (var b = 0; b < a.length; ++b)
		a[b].insertLinkFunctor(this, -1)
};
skim.engine.linkFunctors.CSMinAngles.prototype.getVDefs = function () {
	return this.vdefs
};
skim.engine.linkFunctors.CSMinAngles.prototype.validAdjustAttrCall = function (a) {
	var b = 0 < this.vdefs.length;
	skim.utils.assert(b, "Error: CSMinAngles has no vertices list.");
	for (var c = 0, d = !1; c < this.vdefs.length; ++c)
		if (a.id === this.vdefs[c].id) {
			d = !0;
			break
		}
	skim.utils.assert(d, "Error: CSMinAngles has been given a vertex outside of its list.");
	return b && d
};
skim.engine.linkFunctors.CSMinAngles.prototype.equalsControlSets = function (a, b) {
	for (var c = this.vdefs[4 * a].getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis), d = Object.keys(c), e = 0; e < d.length; e++)
		if ("x" === c[d[e]].getAxis() || "y" === c[d[e]].getAxis())
			if (c[d[e]].getVDef0().id == this.vdefs[4 * b].id || c[d[e]].getVDef1().id == this.vdefs[4 * b].id)
				return !0;
	return !1
};
skim.engine.linkFunctors.CSMinAngles.prototype.propagateChange = function (a, b) {
	skim.utils.assert(this.validAdjustAttrCall(a), "Error : Unproper use of CSMinAngles propagateChange.");
	for (var c = 0, d = []; c < this.vdefs.length; c++)
		0 === c % 4 && d.push({
			CS : [this.vdefs[c], this.vdefs[c + 1], this.vdefs[c + 2], this.vdefs[c + 3]],
			angle : skim.geometry.GetXAngleFromPoint(this.vdefs[c].getPos()),
			idx : c / 4
		});
	d.sort(function (a, b) {
		return a.angle - b.angle
	});
	for (var c = 0, e = -1; c < d.length; c++)
		for (var f = 0; 4 > f; f++)
			d[c].CS[f].id === a.id && (e = c);
	for (f = c = 0; c < d.length; c++)
		if (c !== e && !this.equalsControlSets(d[c].idx, d[e].idx) && (f = d[c].angle - d[e].angle, Math.abs(f) < this.minAngle)) {
			var g = this.testTheta(d, c, e);
			skim.utils.assert(Math.abs(d[c].angle - g) >= this.minAngle, "CSMinAngles - New Angle is not stable");
			if (null !== g)
				for (f = 0; 4 > f; f++) {
					var h = d[e].CS[f],
					k = skim.geometry.computeRadialDist(h.getPos()),
					l = h.getPos().z,
					k = skim.geometry.ZRadial2cart({
							r : k,
							z : l,
							t : g
						});
					h.setVertex(k.x, k.y, k.z, h.getThickness(), h.getMaterial(), h.getVolType()) && void 0 === b[h.id] && (b[h.id] =
							h, b.order.push(h))
				}
		}
};
skim.engine.linkFunctors.CSMinAngles.prototype.testTheta = function (a, b, c) {
	for (var d = a[b].angle - this.minAngle, e = 1, f = 0; e < a.length; e++)
		if (f = skim.ringUtils.cleanIndex(b - e, a.length), f !== c && !this.equalsControlSets(a[f].idx, a[c].idx)) {
			var g = 0 > b - e ? a[f].angle - 2 * Math.PI : a[f].angle,
			f = d - g;
			if (Math.abs(f) < this.minAngle)
				d = g - this.minAngle;
			else
				break
		}
	if (e >= a.length)
		return null;
	for (var h = a[b].angle + this.minAngle, e = 1; e < a.length; e++)
		if (f = skim.ringUtils.cleanIndex(b + e, a.length), f !== c && !this.equalsControlSets(a[f].idx, a[c].idx))
			if (g =
					b + e >= a.length ? a[f].angle + 2 * Math.PI : a[f].angle, f = h - g, Math.abs(f) < this.minAngle)
				h = g + this.minAngle;
			else
				break;
	if (e >= a.length)
		return null;
	if (d !== h)
		return f = (h + d) / 2 - a[c].angle, 0 < f ? d - 0.1 * this.minAngle : h + 0.1 * this.minAngle;
	console.warn("Too many constraints on the ring!");
	return null
};
skim.engine.linkFunctors.CSMinAngles.prototype.destroy = function () {
	for (var a = 0; a < this.vdefs.length; ++a)
		this.vdefs[a].removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.CSMinAngles.prototype.onDestroy = function (a) {
	for (var b = 0, c = -1; b < this.vdefs.length; b++)
		this.vdefs[b].id === a.id && (c = 4 * Math.floor(b / 4));
	if (-1 !== c) {
		for (b = c; b < c + 4; b++)
			this.vdefs[b].removeLinkFunctor(this), void 0 !== skim.engine.vars.vertices[this.vdefs[b].id] && this.vdefs[b].destroy();
		this.vdefs.splice(c, 4)
	}
	0 === this.vdefs.length && this.destroy()
};
skim.engine.linkFunctors.CSMinAngles.prototype.getGroup = function (a, b) {
	a[this.id] = !0
};
skim.engine.linkFunctors.VPairMinDist = function (a, b, c) {
	skim.engine.linkFunctors.VertexVirtualLinkFunctor.call(this);
	skim.utils.assert(2 == a.length, "Error : VPairMinDist functor does only accept 2 vertices. No more, no less.");
	this.vdefs = a;
	this.minLimit = b;
	this.maxLimit = c;
	this.tmpVect = new THREE.Vector3;
	for (a = 0; a < this.vdefs.length; ++a)
		this.vdefs[a].insertLinkFunctor(this, 0)
};
skim.engine.linkFunctors.VPairMinDist.prototype = Object.create(skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.VPairMinDist.prototype.constructor = skim.engine.linkFunctors.VPairMinDist;
skim.engine.linkFunctors.VPairMinDist.prototype.getVDefs = function () {
	return this.vdefs
};
skim.engine.linkFunctors.VPairMinDist.prototype.propagateChange = function (a, b) {
	skim.utils.assert(this.vdefs[0] == a || this.vdefs[1] == a, "Error : cannot adjust position of a vertex that does not belong to the pair...");
	skim.utils.assert(!a.hasZSym(), "vPairMinDist functor does not work with z symmetry activated");
	var c = this.vdefs[0] === a ? this.vdefs[1] : this.vdefs[0],
	d = Math.max(this.minLimit, this.vdefs[1].getThickness() + this.vdefs[0].getThickness());
	this.tmpVect.subVectors(c.getPos(), a.getPos());
	var e = this.tmpVect.lengthSq();
	if (e < d * d && Math.abs(Math.sqrt(e) - d) > skim.engine.functorPrecision) {
		var f = this.tmpVect.clone().normalize(),
		d = d - Math.sqrt(e);
		skim.utils.assert(0 < d, "distance to add can't be negative!");
		this.tmpVect.addVectors(this.tmpVect, f.multiplyScalar(d));
		this.tmpVect.addVectors(this.tmpVect, a.getPos());
		(f = c.setVertex(this.tmpVect.x, this.tmpVect.y, this.tmpVect.z, c.getThickness(), c.getMaterial(), c.getVolType())) && void 0 === b[c.id] && (b[c.id] = c, b.order.push(c))
	} else
		e > this.maxLimit * this.maxLimit && Math.abs(Math.sqrt(e) -
			this.maxLimit) > skim.engine.functorPrecision && (f = this.tmpVect.clone().normalize(), d = Math.sqrt(e) - this.maxLimit, skim.utils.assert(0 < d, "distance to add can't be negative!"), this.tmpVect.subVectors(this.tmpVect, f.multiplyScalar(d)), this.tmpVect.addVectors(this.tmpVect, a.getPos()), (f = c.setVertex(this.tmpVect.x, this.tmpVect.y, this.tmpVect.z, c.getThickness(), c.getMaterial(), c.getVolType())) && void 0 === b[c.id] && (b[c.id] = c, b.order.push(c)))
};
skim.engine.linkFunctors.VPairMinDist.prototype.destroy = function () {
	for (var a = 0; 2 > a; ++a)
		this.vdefs[a].removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.VPairMinDist.prototype.onDestroy = function (a) {
	this.destroy();
	for (a = 0; 2 > a; ++a)
		void 0 !== skim.engine.vars.vertices[this.vdefs[a].id] && this.vdefs[a].destroy()
};
skim.engine.linkFunctors.VPairMinDist.prototype.getGroup = function (a, b) {
	a[this.id] = !0
};
skim.engine.linkFunctors.VPairThickness = function (a) {
	skim.engine.linkFunctors.VertexVirtualLinkFunctor.call(this);
	this.vdefs = a;
	skim.utils.assert(0 !== a.length, "Error : VPairThickness can only operate on a list of VertDef");
	for (a = 0; a < this.vdefs.length; ++a)
		this.vdefs[a].insertLinkFunctor(this, 0)
};
skim.engine.linkFunctors.VPairThickness.prototype = Object.create(skim.engine.linkFunctors.VertexVirtualLinkFunctor.prototype);
skim.engine.linkFunctors.VPairThickness.prototype.constructor = skim.engine.linkFunctors.VPairThickness;
skim.engine.linkFunctors.VPairThickness.prototype.getVDefs = function () {
	return this.vdefs
};
skim.engine.linkFunctors.VPairThickness.prototype.propagateChange = function (a, b) {
	for (var c = 0; c < this.vdefs.length; c++)
		if (a.id !== this.vdefs[c].id) {
			var d = this.vdefs[c].getThickness(),
			e = a.getThickness();
			!skim.utils.isApproxEqual(d, e, skim.engine.functorPrecision) && (this.vdefs[c].setVertex(this.vdefs[c].getPos().x, this.vdefs[c].getPos().y, this.vdefs[c].getPos().z, e, this.vdefs[c].getMaterial(), this.vdefs[c].getVolType()) && void 0 === b[this.vdefs[c].id]) && (b[this.vdefs[c].id] = this.vdefs[c], b.order.push(this.vdefs[c]))
		}
};
skim.engine.linkFunctors.VPairThickness.prototype.destroy = function () {
	for (var a = 0; a < this.vdefs.length; ++a)
		this.vdefs[a].removeLinkFunctor(this);
	this.destroyVirtualLinkFunctor()
};
skim.engine.linkFunctors.VPairThickness.prototype.onDestroy = function (a) {
	this.destroy();
	for (a = 0; a < this.vdefs.length; ++a)
		void 0 !== skim.engine.vars.vertices[this.vdefs[a].id] && this.vdefs[a].destroy()
};
skim.engine.linkFunctors.VPairThickness.prototype.getGroup = function (a, b) {
	a[this.id] = !0
};
skim.engine.adjustAttrFunctors = {};
skim.engine.adjustAttrFunctors.Global = function () {
	this.active = !0
};
skim.engine.adjustAttrFunctors.Global.prototype.setActive = function (a) {
	this.active = a
};
skim.engine.adjustAttrFunctors.Global.prototype.isActive = function () {
	return this.active
};
skim.engine.adjustAttrFunctors.Global.prototype.adjustAttr = function (a, b, c) {
	skim.utils.assert(!1, "Error : adjustAttrFunctors.Global.adjustAttr is pure abstract function, should be re-implemented in subclass")
};
skim.engine.adjustAttrFunctors.Global.prototype.checkAttr = function (a, b, c) {
	skim.utils.assert(!1, "Error : adjustAttrFunctors.Global.checkAttr is pure abstract function, should be re-implemented in subclass");
	return !1
};
skim.engine.adjustAttrFunctors.Global.prototype.onDestroy = function (a) {
	a.removeAdjustAttrFunctor(this)
};
skim.engine.adjustAttrFunctors.Magnet = function () {
	skim.engine.adjustAttrFunctors.Global.call(this)
};
skim.engine.adjustAttrFunctors.Magnet.prototype.onDestroy = function () {
	skim.utils.assert(!1, "Error : Magnet.destroy is pure abstract function, should be re-implemented in subclass")
};
skim.engine.adjustAttrFunctors.Magnet.prototype = Object.create(skim.engine.adjustAttrFunctors.Global.prototype);
skim.engine.adjustAttrFunctors.Magnet.prototype.constructor = skim.engine.adjustAttrFunctors.Magnet;
skim.engine.adjustAttrFunctors.VMagnetAxis = function (a, b) {
	skim.engine.adjustAttrFunctors.Magnet.call(this);
	this.axis = b;
	this.ratio = a
};
skim.engine.adjustAttrFunctors.VMagnetAxis.prototype = Object.create(skim.engine.adjustAttrFunctors.Magnet.prototype);
skim.engine.adjustAttrFunctors.VMagnetAxis.prototype.constructor = skim.engine.adjustAttrFunctors.VMagnetAxis;
skim.engine.adjustAttrFunctors.VMagnetAxis.prototype.adjustAttr = function (a, b, c) {
	for (var d = 0; d < this.axis.length; ++d)
		Math.abs(a[this.axis[d]]) < b.t * this.ratio && Math.abs(a[this.axis[d]]) > skim.engine.functorPrecision && (c.hasOwnersRings() ? console.error("Rings control sets should not have magnets functors as it conflict with CSMinAngles link functors") : a[this.axis[d]] = 0)
};
skim.engine.adjustAttrFunctors.VMagnetAxis.prototype.checkAttr = function (a, b, c) {
	for (c = 0; c < this.axis.length; ++c)
		if (Math.abs(a[this.axis[c]]) < b.t * this.ratio && Math.abs(a[this.axis[c]]) > skim.engine.functorPrecision)
			return !1;
	return !0
};
skim.engine.adjustAttrFunctors.VMagnetRing = function (a, b, c) {
	skim.engine.adjustAttrFunctors.Magnet.call(this);
	this.ring = c || null;
	this.radius = b || null;
	this.ratio = a;
	this.extractor = new skim.ringUtils.RExtractor
};
skim.engine.adjustAttrFunctors.VMagnetRing.prototype = Object.create(skim.engine.adjustAttrFunctors.Magnet.prototype);
skim.engine.adjustAttrFunctors.VMagnetRing.prototype.constructor = skim.engine.adjustAttrFunctors.VMagnetRing;
skim.engine.adjustAttrFunctors.VMagnetRing.prototype.adjustAttr = function (a, b, c) {
	this.extractor = new skim.ringUtils.RExtractor;
	var d = this.extractor.extract(a),
	e = this.radius,
	f = c.getLinkFunctorByClass(skim.engine.linkFunctors.VRadialSymmetry);
	skim.utils.assert(1 >= f.length, "Can only manage one radial symmetry right now");
	c = 0 < f.length ? f[0].getVertScale(c) : 1;
	Math.abs(d - e) < b.t * this.ratio && (Math.abs(d - e) > skim.engine.functorPrecision && 1 === c) && (d = skim.geometry.GetXAngleFromPoint(a), b = e * Math.cos(d), b = skim.utils.isApproxEqual(b,
				0, skim.engine.functorPrecision) ? 0 : b, e *= Math.sin(d), e = skim.utils.isApproxEqual(e, 0, skim.engine.functorPrecision) ? 0 : e, a.set(b, e, a.z))
};
skim.engine.adjustAttrFunctors.VMagnetRing.prototype.checkAttr = function (a, b, c) {
	a = this.extractor.extract(a);
	var d = this.radius,
	e = c.getLinkFunctorByClass(skim.engine.linkFunctors.VRadialSymmetry);
	skim.utils.assert(1 >= e.length, "Can only manage one radial symmetry right now");
	c = 0 < e.length ? e[0].getVertScale(c) : 1;
	return !(Math.abs(a - d) < b.t * this.ratio && Math.abs(a - d) > skim.engine.functorPrecision && 1 === c)
};
skim.engine.adjustAttrFunctors.VMagnetRing.prototype.setRing = function (a) {
	this.ring = a
};
skim.engine.adjustAttrFunctors.VMagnetRing.prototype.setRadius = function (a) {
	this.radius = a
};
skim.engine.adjustAttrFunctors.Param = function (a) {
	skim.engine.adjustAttrFunctors.Global.call(this);
	this.extractor = a;
	this.active = !1;
	this.backupActive = !0
};
skim.engine.adjustAttrFunctors.Param.prototype.onDestroy = function () {
	skim.utils.assert(!1, "Error : Param.destroy is pure abstract function, should be re-implemented in subclass")
};
skim.engine.adjustAttrFunctors.Param.prototype = Object.create(skim.engine.adjustAttrFunctors.Global.prototype);
skim.engine.adjustAttrFunctors.Param.prototype.constructor = skim.engine.adjustAttrFunctors.Param;
skim.engine.adjustAttrFunctors.Param.prototype.setActive = function (a) {
	this.backupActive = this.active = a
};
skim.engine.adjustAttrFunctors.RsqLimit = function (a) {
	skim.engine.adjustAttrFunctors.Param.call(this, new skim.ringUtils.RSqExtractor);
	this.limit = this.ring = null
};
skim.engine.adjustAttrFunctors.RsqLimit.prototype = Object.create(skim.engine.adjustAttrFunctors.Param.prototype);
skim.engine.adjustAttrFunctors.RsqLimit.prototype.constructor = skim.engine.adjustAttrFunctors.RsqLimit;
skim.engine.adjustAttrFunctors.RsqLimit.prototype.setRing = function (a) {
	this.ring = a;
	this.active = this.backupActive
};
skim.engine.adjustAttrFunctors.RsqLimit.prototype.setLimit = function (a) {
	this.limit = a;
	this.active = this.backupActive
};
skim.engine.adjustAttrFunctors.RsqLimit.prototype.adjustAttr = function (a, b, c) {
	c = this.extractor.extract(a);
	b = skim.engine.utilsFunctors.getLimit(this) + b.t;
	if (c <= b * b && Math.abs(Math.sqrt(c) - b) > skim.engine.functorPrecision) {
		c = b + skim.engine.functorPrecision;
		var d = skim.geometry.GetXAngleFromPoint(a);
		b = c * Math.cos(d);
		b = skim.utils.isApproxEqual(b, 0, skim.engine.functorPrecision) ? 0 : b;
		c *= Math.sin(d);
		c = skim.utils.isApproxEqual(c, 0, skim.engine.functorPrecision) ? 0 : c;
		a.set(b, c, a.z);
		skim.instances.modeler.pageInterface.rsqFunctorWorked()
	}
};
skim.engine.adjustAttrFunctors.RsqLimit.prototype.checkAttr = function (a, b, c) {
	a = this.extractor.extract(a);
	c = skim.engine.utilsFunctors.getLimit(this);
	skim.utils.assert(-1 !== c, "no ring, nor limit value for RsqBound were found");
	b = c + b.t;
	return !(a < b * b && Math.abs(Math.sqrt(a) - b) > skim.engine.functorPrecision)
};
skim.engine.adjustAttrFunctors.VFixedPos = function () {
	skim.engine.adjustAttrFunctors.Global.call(this)
};
skim.engine.adjustAttrFunctors.VFixedPos.prototype = Object.create(skim.engine.adjustAttrFunctors.Global.prototype);
skim.engine.adjustAttrFunctors.VFixedPos.prototype.constructor = skim.engine.adjustAttrFunctors.VFixedPos;
skim.engine.adjustAttrFunctors.VFixedPos.prototype.adjustAttr = function (a, b, c) {
	skim.utils.assert(c.adjust_pos_functors[c.adjust_pos_functors.length - 1] === this, "Last declared functor should be this one");
	b = c.getPos();
	a.set(b.x, b.y, b.z)
};
skim.engine.adjustAttrFunctors.VFixedPos.prototype.checkAttr = function (a, b, c) {
	return a.equals(c.getPos())
};
skim.engine.adjustAttrFunctors.VFixedTanRadial = function (a, b) {
	skim.engine.adjustAttrFunctors.Global.call(this);
	this.radius = a;
	this.outside = b
};
skim.engine.adjustAttrFunctors.VFixedTanRadial.prototype = Object.create(skim.engine.adjustAttrFunctors.Global.prototype);
skim.engine.adjustAttrFunctors.VFixedTanRadial.prototype.constructor = skim.engine.adjustAttrFunctors.VFixedTanRadial;
skim.engine.adjustAttrFunctors.VFixedTanRadial.prototype.setRadial = function (a) {
	this.radius = a
};
skim.engine.adjustAttrFunctors.VFixedTanRadial.prototype.adjustAttr = function (a, b, c) {
	c = this.radius + (this.outside ? 1 : -1) * b.t;
	if (!skim.utils.isApproxEqual(a.x * a.x + a.y * a.y, c * c, skim.engine.functorPrecision)) {
		var d = skim.geometry.GetXAngleFromPoint(a);
		b = c * Math.cos(d);
		b = skim.utils.isApproxEqual(b, 0, skim.engine.functorPrecision) ? 0 : b;
		c *= Math.sin(d);
		c = skim.utils.isApproxEqual(c, 0, skim.engine.functorPrecision) ? 0 : c;
		a.set(b, c, a.z)
	}
};
skim.engine.adjustAttrFunctors.VFixedTanRadial.prototype.checkAttr = function (a, b, c) {
	var d = this.outside ? 1 : -1;
	return skim.utils.isApproxEqual(skim.geometry.computeRadialDist(a), skim.geometry.computeRadialDist(c.getPos()) + d * b.t, skim.engine.functorPrecision)
};
skim.engine.adjustAttrFunctors.SpherePosLimit = function (a) {
	skim.engine.adjustAttrFunctors.Global.call(this);
	this.limitSq = a * a
};
skim.engine.adjustAttrFunctors.SpherePosLimit.prototype = Object.create(skim.engine.adjustAttrFunctors.Global.prototype);
skim.engine.adjustAttrFunctors.SpherePosLimit.prototype.constructor = skim.engine.adjustAttrFunctors.SpherePosLimit;
skim.engine.adjustAttrFunctors.SpherePosLimit.prototype.setLimit = function (a) {
	this.limitSq = a * a
};
skim.engine.adjustAttrFunctors.SpherePosLimit.prototype.adjustAttr = function (a, b, c) {
	b = a.x * a.x + a.y * a.y + a.z * a.z;
	b > this.limitSq && (b = skim.geometry.increaseVectorLength(a, new THREE.Vector3,  - (Math.sqrt(b) - Math.sqrt(this.limitSq) - skim.engine.functorPrecision)), a.set(b.x, b.y, b.z))
};
skim.engine.adjustAttrFunctors.SpherePosLimit.prototype.checkAttr = function (a, b, c) {
	return a.x * a.x + a.y * a.y + a.z * a.z <= this.limitSq
};
skim.engine.adjustAttrFunctors.VFixedThick = function () {
	skim.engine.adjustAttrFunctors.Global.call(this)
};
skim.engine.adjustAttrFunctors.VFixedThick.prototype = Object.create(skim.engine.adjustAttrFunctors.Global.prototype);
skim.engine.adjustAttrFunctors.VFixedThick.prototype.constructor = skim.engine.adjustAttrFunctors.VFixedThick;
skim.engine.adjustAttrFunctors.VFixedThick.prototype.adjustAttr = function (a, b, c) {
	skim.utils.assert(c.adjust_thick_functors[c.adjust_thick_functors.length - 1] === this, "Last declared functor should this one");
	b.t = c.getThickness()
};
skim.engine.adjustAttrFunctors.VFixedThick.prototype.checkAttr = function (a, b, c) {
	return b.t == c.getThickness()
};
skim.engine.adjustAttrFunctors.Relative = function () {
	this.active = !0
};
skim.engine.adjustAttrFunctors.Relative.prototype.adjustAttr = function (a, b, c) {
	skim.utils.assert(!1, "Error : adjustAttrFunctors.adjustAttr is pure abstract function, should be re-implemented in subclass")
};
skim.engine.adjustAttrFunctors.Relative.prototype.setActive = function (a) {
	this.active = a
};
skim.engine.adjustAttrFunctors.Relative.prototype.isActive = function () {
	return !0
};
skim.engine.adjustAttrFunctors.Relative.prototype.destroy = function () {
	for (var a = 0; a < this.vertices.length; ++a)
		this.vertices[a].removeAdjustAttrFunctor(this)
};
skim.engine.adjustAttrFunctors.Relative.prototype.onDestroy = function (a) {
	this.destroy()
};
skim.engine.adjustAttrFunctors.VSetConvexInPlane = function (a, b) {
	skim.engine.adjustAttrFunctors.Relative.call(this);
	this.vertices = a;
	this.projector = b;
	skim.utils.assert(4 == a.length, "Error : for now the VSetConvexInPlane functor does only accept 4 vertices no more no less. Can be extended to n >= 4 later.");
	for (var c = 0; 4 > c; ++c)
		this.vertices[c].insertAdjustAttrFunctor(this, -1)
};
skim.engine.adjustAttrFunctors.VSetConvexInPlane.prototype = Object.create(skim.engine.adjustAttrFunctors.Relative.prototype);
skim.engine.adjustAttrFunctors.VSetConvexInPlane.prototype.constructor = skim.engine.adjustAttrFunctors.VSetConvexInPlane;
skim.engine.adjustAttrFunctors.VSetConvexInPlane.prototype.adjustAttr = function (a, b, c) {
	skim.utils.assert(this.vertices[0] == c || this.vertices[1] == c || this.vertices[2] == c || this.vertices[3] == c, "Error : cannot adjust position of a vertex that does not belong to the set...");
	b = [];
	for (var d = 0, e; d < this.vertices.length; d++)
		this.vertices[d].id === c.id ? (e = d, b.push(this.projector.project(a))) : b.push(this.projector.project(this.vertices[d].getPos()));
	if (!skim.geometry.IsConvex(b[0], b[1], b[2], b[3]))
		if (b.push(this.projector.project(c.getPos())),
			b[4].equals(b[e]))
			console.error("actually, we shouldn't be here at all"), skim.utils.assert(skim.geometry.IsConvex(this.projector.project(this.vertices[0]), this.projector.project(this.vertices[1]), this.projector.project(this.vertices[2]), this.projector.project(this.vertices[3])), "Trying to fix an already broken position");
		else {
			var f = [];
			f.push(skim.geometry.GetIntersectionLineAndLine(b[4], b[e], b[(e + 1) % 4], b[(e + 2) % 4]));
			f.push(skim.geometry.GetIntersectionLineAndLine(b[4], b[e], b[(e + 2) % 4], b[(e + 3) % 4]));
			f.push(skim.geometry.GetIntersectionLineAndLine(b[4], b[e], b[(e + 1) % 4], b[(e + 3) % 4]));
			for (d = 0; d < f.length; d++)
				f[d] = null === f[d] ? c.getPos().clone() : f[d];
			skim.utils.assert(!(null === f[0] && null === f[1] && null === f[2]), "Parallel lines impossible situation detected");
			var g = new THREE.Vector3,
			h = null,
			k = new THREE.Vector3;
			k.subVectors(b[e], b[4]);
			d = 0;
			e = skim.geometry.Max;
			for (var l = 0; d < f.length; d++)
				0 < g.subVectors(f[d], b[4]).dot(k) && (l = g.subVectors(b[4], f[d]).lengthSq(), e > l && (e = l, h = f[d]));
			skim.utils.assert(null !== h, "No intersections in front of the convex stuff");
			if (null === h) {
				d = 0;
				for (e = skim.geometry.Max; d < f.length; d++)
					l = g.subVectors(b[4], f[d]).lengthSq(), e > l && (e = l, h = f[d]);
				skim.utils.assert(!1, "Dirty fix in convex functor has been applied. It smells like an old Livarot yet again.")
			}
			h = g.clone().subVectors(h, b[4]);
			d = Math.min(100 * skim.engine.functorPrecision, h.length());
			f = h.clone().normalize();
			skim.utils.assert(skim.utils.isApproxEqual(f.lengthSq(), 1, skim.engine.functorPrecision), "unit vector is so wrong my grandma is rolling in her grave");
			h = g.clone().subVectors(h,
					f.multiplyScalar(d));
			h = g.clone().addVectors(h, b[4]);
			b = skim.geometry.GetXAngleFromPoint(a);
			a.set(h.x * Math.cos(b), h.x * Math.sin(b), h.y);
			b = [];
			for (d = 0; d < this.vertices.length; d++)
				this.vertices[d].id === c.id ? b.push(this.projector.project(a)) : b.push(this.projector.project(this.vertices[d].getPos()));
			skim.geometry.IsConvex(b[0], b[1], b[2], b[3]) || console.error("We did not fix the convexity")
		}
};
skim.engine.adjustAttrFunctors.VSetConvexInPlane.prototype.checkAttr = function (a, b, c) {
	skim.utils.assert(this.vertices[0] == c || this.vertices[1] == c || this.vertices[2] == c || this.vertices[3] == c, "Error : cannot adjust position of a vertex that does not belong to the set...");
	b = [];
	for (var d = 0; d < this.vertices.length; d++)
		this.vertices[d].id === c.id ? b.push(this.projector.project(a)) : b.push(this.projector.project(this.vertices[d].getPos()));
	return skim.geometry.IsConvex(b[0], b[1], b[2], b[3])
};
skim.engine.adjustAttrFunctors.VListTrigoOrientedInPlane = function (a, b) {
	skim.engine.adjustAttrFunctors.Relative.call(this);
	skim.utils.assert(4 == a.length, "Error : for now the VListTrigoOrientedInPlane functor does only accept 4 vertices no more no less. Can be extended to n >= 4 later.");
	this.vertices = a;
	this.projector = b;
	for (var c = 0; 4 > c; ++c)
		this.vertices[c].insertAdjustAttrFunctor(this, -1)
};
skim.engine.adjustAttrFunctors.VListTrigoOrientedInPlane.prototype = Object.create(skim.engine.adjustAttrFunctors.Relative.prototype);
skim.engine.adjustAttrFunctors.VListTrigoOrientedInPlane.prototype.constructor = skim.engine.adjustAttrFunctors.VListTrigoOrientedInPlane;
skim.engine.adjustAttrFunctors.VListTrigoOrientedInPlane.prototype.adjustAttr = function (a, b, c) {
	skim.utils.assert(this.vertices[0] == c || this.vertices[1] == c || this.vertices[2] == c || this.vertices[3] == c, "Error : cannot adjust position of a vertex that does not belong to the set...");
	b = [];
	for (var d = 0, e; d < this.vertices.length; d++)
		this.vertices[d].id === c.id ? (e = d, b.push(this.projector.project(a))) : b.push(this.projector.project(this.vertices[d].getPos()));
	if (!skim.geometry.IsTrigoOriented(b[0], b[1], b[2], b[3]))
		if (b.push(this.projector.project(c.getPos())),
			b[4].equals(b[e]))
			console.error("actually, we shouldn't be here at all"), skim.utils.assert(skim.geometry.IsTrigoOriented(this.projector.project(this.vertices[0]), this.projector.project(this.vertices[1]), this.projector.project(this.vertices[2]), this.projector.project(this.vertices[3])), "Trying to fix an already broken position");
		else {
			var f = skim.geometry.GetIntersectionLineAndLine(b[4], b[e], b[(e + 1) % 4], b[(e + 2) % 4]),
			g = skim.geometry.GetIntersectionLineAndLine(b[4], b[e], b[(e + 2) % 4], b[(e + 3) % 4]),
			f = null === f ?
				c.getPos().clone() : f,
			g = null === g ? c.getPos().clone() : g;
			skim.utils.assert(!(null === f && null === g), "Parallel lines impossible situation detected");
			var d = new THREE.Vector3,
			h = new THREE.Vector3;
			h.subVectors(b[e], b[4]);
			e = 0 < d.subVectors(f, b[4]).dot(h) ? 1 : -1;
			var h = 0 < d.subVectors(g, b[4]).dot(h) ? 1 : -1,
			k = null;
			if (0 < e && 0 < h)
				var k = d.subVectors(b[4], f).lengthSq(), l = d.subVectors(b[4], g).lengthSq(), k = k < l ? f : g;
			else
				0 < e && 0 >= h ? k = f : 0 < h && 0 >= e ? k = g : (k = d.subVectors(b[4], f).lengthSq(), l = d.subVectors(b[4], g).lengthSq(), k = k < l ? f : g, skim.utils.assert(!1,
							"Dirty fix in trigo functor has been applied. It smells like an old Livarot."));
			skim.utils.assert(0 < e || 0 < h, "Can't have negative intersection for both points!");
			f = d.clone().subVectors(k, b[4]);
			g = Math.min(100 * skim.engine.functorPrecision, f.length());
			e = f.clone().normalize();
			e.setX(skim.utils.isApproxEqual(e.x, 0, skim.engine.functorPrecision) ? 0 : e.x);
			e.setY(skim.utils.isApproxEqual(e.y, 0, skim.engine.functorPrecision) ? 0 : e.y);
			e.setZ(skim.utils.isApproxEqual(e.z, 0, skim.engine.functorPrecision) ? 0 : e.z);
			f = d.clone().subVectors(f,
					e.multiplyScalar(g));
			k = d.clone().addVectors(f, b[4]);
			b = skim.geometry.GetXAngleFromPoint(a);
			a.set(k.x * Math.cos(b), k.x * Math.sin(b), k.y);
			b = [];
			for (d = 0; d < this.vertices.length; d++)
				this.vertices[d].id === c.id ? b.push(this.projector.project(a)) : b.push(this.projector.project(this.vertices[d].getPos()));
			skim.geometry.IsTrigoOriented(b[0], b[1], b[2], b[3]) || console.error("We did not fix the trigo orientation")
		}
};
skim.engine.adjustAttrFunctors.VListTrigoOrientedInPlane.prototype.checkAttr = function (a, b, c) {
	skim.utils.assert(this.vertices[0] == c || this.vertices[1] == c || this.vertices[2] == c || this.vertices[3] == c, "Error : cannot adjust position of a vertex that does not belong to the set...");
	b = [];
	for (var d = 0; d < this.vertices.length; d++)
		this.vertices[d].id === c.id ? b.push(this.projector.project(a)) : b.push(this.projector.project(this.vertices[d].getPos()));
	return skim.geometry.IsTrigoOriented(b[0], b[1], b[2], b[3])
};
skim.engine.adjustAttrFunctors.VDistantVertices = function (a) {
	skim.engine.adjustAttrFunctors.Relative.call(this);
	this.vertices = a;
	this.tmpVector = new THREE.Vector3;
	skim.utils.assert(4 === a.length, "Error : VDistantVertices only work on control sets or 4 vertices");
	for (var b = 0; b < a.length; ++b)
		this.vertices[b].insertAdjustAttrFunctor(this, -1)
};
skim.engine.adjustAttrFunctors.VDistantVertices.prototype = Object.create(skim.engine.adjustAttrFunctors.Relative.prototype);
skim.engine.adjustAttrFunctors.VDistantVertices.prototype.constructor = skim.engine.adjustAttrFunctors.VDistantVertices;
skim.engine.adjustAttrFunctors.VDistantVertices.prototype.validAdjustAttrCall = function (a, b) {
	if (4 !== this.vertices.length)
		return !1;
	for (var c = 0; c < this.vertices.length; ++c)
		if (this.vertices[c].id === b.id)
			return !0;
	return !1
};
skim.engine.adjustAttrFunctors.VDistantVertices.prototype.adjustAttr = function (a, b, c) {
	skim.utils.assert(this.validAdjustAttrCall(a, c), "Error : Unproper use of VDistantVertices adjustAttr");
	for (var d = 0, e = -1, f = -1; d < this.vertices.length; d++)
		this.vertices[d].getThickness() > e && (e = this.vertices[d].getThickness()), c.id === this.vertices[d].id && (f = d);
	e = Math.max(b.t, e);
	d = 0;
	c = [];
	for (b = e / 20; d < this.vertices.length; d++)
		c.push(this.getBox(d, b));
	var g = 1 == f || 2 === f ? 1 : -1,
	d = 2 == f || 3 === f ? 1 : -1,
	h = -1,
	h = 0 < g ? Math.min(c[0].bottom.r,
			c[3].bottom.r) : Math.max(c[1].top.r, c[2].top.r);
	b = -1;
	b = 0 < d ? Math.min(c[0].bottom.z, c[1].bottom.z) : Math.max(c[2].top.z, c[3].top.z);
	c = skim.geometry.computeRadialDist(a);
	var k = a.z,
	g = 0 < g * (c - h) ? h : c,
	d = 0 < d * (k - b) ? b : k;
	skim.utils.isApproxEqual(g, c, skim.engine.functorPrecision) && skim.utils.isApproxEqual(d, k, skim.engine.functorPrecision) || (b = skim.geometry.GetXAngleFromPoint(a), d = skim.geometry.ZRadial2cart({
				r : g,
				z : d,
				t : b
			}), a.set(d.x, d.y, d.z), skim.utils.assert(this.testFpos(e / 20, f, a), "Err: VDistantVertices - Corrected fpos is invalid!"))
};
skim.engine.adjustAttrFunctors.VDistantVertices.prototype.testFpos = function (a, b, c) {
	for (var d = 0, e = new THREE.Vector3, f = 0; 4 > d; d++)
		if (f = e.subVectors(this.vertices[d].getPos(), c).length(), b !== d && f < 2 * a && !skim.utils.isApproxEqual(f, 2 * a, skim.engine.functorPrecision))
			return !1;
	return !0
};
skim.engine.adjustAttrFunctors.VDistantVertices.prototype.getBox = function (a, b) {
	var c = 0 === a || 3 === a ? -1 : 1,
	d = 0 === a || 1 === a ? -1 : 1,
	c = skim.geometry.computeRadialDist(this.vertices[a].getPos()) + c * b,
	d = this.vertices[a].getPos().z + d * b;
	return {
		center : {
			r : c,
			z : d
		},
		bottom : {
			r : c - b,
			z : d - b
		},
		top : {
			r : c + b,
			z : d + b
		},
		halfSize : b
	}
};
skim.engine.adjustAttrFunctors.VDistantVertices.prototype.checkAttr = function (a, b, c) {
	skim.utils.assert(this.validAdjustAttrCall(a, c), "Error : Unproper use of VDistantVertices adjustAttr");
	for (var d = 0, e = -1, f = -1; d < this.vertices.length; d++)
		this.vertices[d].getThickness() > e && (e = this.vertices[d].getThickness()), c.id === this.vertices[d].id && (f = d);
	e = Math.max(b, e);
	d = 0;
	b = [];
	for (e /= 20; d < this.vertices.length; d++)
		b.push(this.getBox(d, e));
	d = 1 == f || 2 === f ? 1 : -1;
	e = 2 == f || 3 === f ? 1 : -1;
	f = -1;
	f = 0 < d ? Math.min(b[0].bottom.r, b[3].bottom.r) :
		Math.max(b[1].top.r, b[2].top.r);
	c = -1;
	c = 0 < e ? Math.min(b[0].bottom.z, b[1].bottom.z) : Math.max(b[2].top.z, b[3].top.z);
	b = skim.geometry.computeRadialDist(a);
	a = a.z;
	e = 0 < e * (a - c) ? c : a;
	return skim.utils.isApproxEqual(0 < d * (b - f) ? f : b, b, skim.engine.functorPrecision) && skim.utils.isApproxEqual(e, a, skim.engine.functorPrecision) ? !0 : !1
};
skim.engine.adjustAttrFunctors.Limit = function () {
	skim.engine.adjustAttrFunctors.Global.call(this)
};
skim.engine.adjustAttrFunctors.Limit.prototype = Object.create(skim.engine.adjustAttrFunctors.Global.prototype);
skim.engine.adjustAttrFunctors.Limit.prototype.constructor = skim.engine.adjustAttrFunctors.Limit;
skim.engine.adjustAttrFunctors.VLimitMin = function (a) {
	skim.engine.adjustAttrFunctors.Limit.call(this);
	this.limit = a
};
skim.engine.adjustAttrFunctors.VLimitMin.prototype = Object.create(skim.engine.adjustAttrFunctors.Limit.prototype);
skim.engine.adjustAttrFunctors.VLimitMin.prototype.constructor = skim.engine.adjustAttrFunctors.VLimitMin;
skim.engine.adjustAttrFunctors.VLimitMin.prototype.adjustAttr = function (a, b, c) {
	b.t < this.limit && (b.t = this.limit)
};
skim.engine.adjustAttrFunctors.VLimitMin.prototype.checkAttr = function (a, b, c) {
	return b.t >= this.limit
};
skim.engine.adjustAttrFunctors.VLimitMax = function (a) {
	skim.engine.adjustAttrFunctors.Limit.call(this);
	this.limit = a
};
skim.engine.adjustAttrFunctors.VLimitMax.prototype = Object.create(skim.engine.adjustAttrFunctors.Limit.prototype);
skim.engine.adjustAttrFunctors.VLimitMax.prototype.constructor = skim.engine.adjustAttrFunctors.VLimitMax;
skim.engine.adjustAttrFunctors.VLimitMax.prototype.adjustAttr = function (a, b, c) {
	b.t > this.limit && (b.t = this.limit)
};
skim.engine.adjustAttrFunctors.VLimitMax.prototype.checkAttr = function (a, b, c) {
	return b.t <= this.limit
};
skim.engine.TopoPosition = function (a) {
	this.x = void 0 !== a.x ? a.x : 0;
	this.y = void 0 !== a.y ? a.y : 0;
	this.z = void 0 !== a.z ? a.z : 0
};
skim.engine.TopoPosition.prototype.clone = function () {
	return new skim.engine.TopoPosition({
		x : this.x,
		y : this.y,
		z : this.z
	})
};
skim.engine.TopoPosition.prototype.getKey = function () {
	return this.x.toString() + this.y.toString() + this.z.toString()
};
skim.engine.verticesIds = 0;
skim.engine.VertexDef = function (a, b, c, d) {
	this.id = skim.engine.verticesIds++;
	this.pos = a.clone();
	this.thickness = b;
	this.material = c.clone();
	this.reactor = this.name = null;
	this.owners = {
		segments : {},
		rings : {},
		triangles : {}

	};
	this.volType = d;
	this.adjust_functors = [];
	this.link_functors = []
};
skim.engine.VertexDef.prototype.getPos = function () {
	return this.pos
};
skim.engine.VertexDef.prototype.setPos = function (a, b, c) {
	this.pos.set(a, b, c);
	this.updateReactorAttr({
		pos : new THREE.Vector3(this.pos.x, this.pos.y, this.pos.z)
	});
	this.notifyOwners()
};
skim.engine.VertexDef.prototype.getThickness = function () {
	return this.thickness
};
skim.engine.VertexDef.prototype.setThickness = function (a) {
	this.thickness = a;
	this.updateReactorAttr({
		thickness : this.thickness
	});
	this.notifyOwners()
};
skim.engine.VertexDef.prototype.getMaterial = function () {
	return this.material
};
skim.engine.VertexDef.prototype.setMaterial = function (a) {
	skim.utils.assert(void 0 !== a, "Error : cannot set undefined material");
	this.material = a;
	this.updateReactorAttr({
		material : this.material
	});
	this.notifyOwners()
};
skim.engine.VertexDef.prototype.getVolType = function () {
	return this.volType
};
skim.engine.VertexDef.prototype.setVolType = function (a) {
	this.volType = a;
	this.updateReactorAttr({
		volType : this.volType
	})
};
skim.engine.VertexDef.prototype.getName = function () {
	return this.name
};
skim.engine.VertexDef.prototype.setName = function (a) {
	this.name = a
};
skim.engine.VertexDef.prototype.getOwnersSegments = function () {
	return this.owners.segments
};
skim.engine.VertexDef.prototype.getOwnersRings = function () {
	return this.owners.rings
};
skim.engine.VertexDef.prototype.getOwnersTriangles = function () {
	return this.owners.triangles
};
skim.engine.VertexDef.prototype.getOwners = function () {
	var a = {},
	b = this.getOwnersSegments(),
	c = this.getOwnersRings(),
	d = this.getOwnersTriangles(),
	e;
	for (e in b)
		a[e] = b[e];
	for (e in c)
		a[e] = c[e];
	for (e in d)
		a[e] = d[e];
	return a
};
skim.engine.VertexDef.prototype.hasOwnersSegments = function () {
	return !skim.utils.isEmptyObject(this.owners.segments)
};
skim.engine.VertexDef.prototype.hasOwnersRings = function () {
	return !skim.utils.isEmptyObject(this.owners.rings)
};
skim.engine.VertexDef.prototype.hasOwnersTriangles = function () {
	return !skim.utils.isEmptyObject(this.owners.triangles)
};
skim.engine.VertexDef.prototype.hasOwners = function () {
	return this.hasOwnersSegments() || this.hasOwnersRings() || this.hasOwnersTriangles()
};
skim.engine.VertexDef.prototype.addOwner = function (a) {
	a instanceof skim.engine.SegmentDef ? this.owners.segments[a.id] = a : a instanceof skim.engine.RingDef ? this.owners.rings[a.id] = a : a instanceof skim.engine.TriangleDef && (this.owners.triangles[a.id] = a)
};
skim.engine.VertexDef.prototype.removeOwner = function (a) {
	a instanceof skim.engine.SegmentDef ? delete this.owners.segments[a.id] : a instanceof skim.engine.RingDef ? delete this.owners.rings[a.id] : a instanceof skim.engine.TriangleDef && delete this.owners.triangles[a.id]
};
skim.engine.VertexDef.prototype.notifyOwners = function () {
	for (var a = this.getOwners(), b = Object.keys(a), c = 0; c < b.length; ++c)
		a[b[c]].vertexChanged(this)
};
skim.engine.VertexDef.prototype.insertFunctor = function (a, b, c) {
	void 0 !== c && (0 > c || c >= a.length) ? a.push(b) : a.splice(c, 0, b)
};
skim.engine.VertexDef.prototype.removeFunctor = function (a, b) {
	for (var c = 0; c < a.length; ++c)
		if (b === a[c]) {
			for (; c < a.length - 1; ++c)
				a[c] = a[c + 1];
			a.length -= 1;
			break
		}
};
skim.engine.VertexDef.prototype.getFunctorByClass = function (a, b) {
	for (var c = [], d = 0; d < a.length; ++d)
		a[d]instanceof b && c.push(a[d]);
	return c
};
skim.engine.VertexDef.prototype.hasFunctorClass = function (a) {
	for (var b = 0; b < this.adjust_functors.length; ++b)
		if (this.adjust_functors[b]instanceof a)
			return !0;
	for (b = 0; b < this.link_functors.length; ++b)
		if (this.link_functors[b]instanceof a)
			return !0;
	return !1
};
skim.engine.VertexDef.prototype.insertAdjustAttrFunctor = function (a, b) {
	var c = this.adjust_functors.length;
	1 < c && skim.utils.assert(!(this.adjust_functors[c - 1]instanceof skim.engine.adjustAttrFunctors.VFixedPos), "Don't add functor after a fixed one!");
	this.insertFunctor(this.adjust_functors, a, b)
};
skim.engine.VertexDef.prototype.getAdjustAttrFunctorByClass = function (a) {
	return this.getFunctorByClass(this.adjust_functors, a)
};
skim.engine.VertexDef.prototype.removeAdjustAttrFunctor = function (a) {
	this.removeFunctor(this.adjust_functors, a)
};
skim.engine.VertexDef.prototype.insertLinkFunctor = function (a, b) {
	this.insertFunctor(this.link_functors, a, b)
};
skim.engine.VertexDef.prototype.removeLinkFunctor = function (a) {
	this.removeFunctor(this.link_functors, a)
};
skim.engine.VertexDef.prototype.getLinkFunctorByClass = function (a) {
	return this.getFunctorByClass(this.link_functors, a)
};
skim.engine.VertexDef.prototype.hasZSym = function () {
	var a = this.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis);
	if (0 < a.length)
		for (var b = 0; b < a.length; b++)
			if ("z" === a[b].a)
				return !0;
	return !1
};
skim.engine.VertexDef.prototype.getAxisSym = function (a) {
	var b = this.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis);
	if (0 < b.length)
		for (var c = 0; c < b.length; c++)
			if (b[c].a === a)
				return b[c];
	return null
};
skim.engine.VertexDef.prototype.propagateLinkFunctors = function () {
	var a = {};
	a[this.id] = this;
	a.order = [this];
	var b = new skim.utils.Security(skim.utils.maxSec / 2);
	for (b.init(skim.utils.maxSec / 2, "Vdef: propagation is too long"); b.valid() && 0 < a.order.length; b.inc()) {
		for (var c = {
				order : []
			}, d = 0; d < a.order.length; ++d)
			for (var e = a.order[d], f = 0; f < e.link_functors.length; ++f)
				e.link_functors[f].propagateChange(e, c);
		a = c
	}
	return b.hasBroken
};
skim.engine.VertexDef.prototype.adjustFromAttrFunctors = function (a, b) {
	this.loopOnFunctorList(a, b);
	this.checkFunctorList(a, b);
	var c = new THREE.Vector3(a.x, a.y, a.z),
	d = b.t;
	this.loopOnFunctorList(a, b);
	this.checkFunctorList(a, b);
	skim.utils.isApproxEqual(a.x, c.x, skim.engine.functorPrecision) && skim.utils.isApproxEqual(a.y, c.y, skim.engine.functorPrecision) && skim.utils.isApproxEqual(a.z, c.z, skim.engine.functorPrecision) && skim.utils.isApproxEqual(b.t, d, skim.engine.functorPrecision) || (a.set(this.pos.x, this.pos.y,
			this.pos.z), b.t = this.thickness)
};
skim.engine.VertexDef.prototype.loopOnFunctorList = function (a, b) {
	for (var c = 0; c < this.adjust_functors.length; ++c)
		this.adjust_functors[c].isActive() && this.adjust_functors[c].adjustAttr(a, b, this)
};
skim.engine.VertexDef.prototype.checkFunctorList = function (a, b) {
	for (var c = 0; c < this.adjust_functors.length; ++c)
		if (this.adjust_functors[c].isActive() && !this.adjust_functors[c].checkAttr(a, b, this))
			return !1;
	return !0
};
skim.engine.VertexDef.prototype.setVertexAndPropagate = function (a, b, c, d, e, f) {
	var g = !1;
	skim.utils.isApproxEqual(a, this.pos.x, skim.engine.functorPrecision) && skim.utils.isApproxEqual(b, this.pos.y, skim.engine.functorPrecision) && skim.utils.isApproxEqual(c, this.pos.z, skim.engine.functorPrecision) && skim.utils.isApproxEqual(d, this.thickness, skim.engine.functorPrecision) && e.equals(this.material) && f === this.volType || (a = new THREE.Vector3(a, b, c), d = {
			t : d
		}, this.adjustFromAttrFunctors(a, d), skim.utils.isApproxEqual(a.x,
			this.pos.x, skim.engine.functorPrecision) && skim.utils.isApproxEqual(a.y, this.pos.y, skim.engine.functorPrecision) && skim.utils.isApproxEqual(a.z, this.pos.z, skim.engine.functorPrecision) && skim.utils.isApproxEqual(d.t, this.thickness, skim.engine.functorPrecision) && e.equals(this.material) && f === this.volType || (this.pos.set(a.x, a.y, a.z), this.thickness = d.t, this.material.copy(e), this.volType = f, this.updateReactorAttr({
				pos : new THREE.Vector3(this.pos.x, this.pos.y, this.pos.z)
			}), this.updateReactorAttr({
				thickness : this.thickness
			}),
			this.updateReactorAttr({
				volType : this.volType
			}), this.updateReactorAttr({
				material : this.material
			}), g = this.propagateLinkFunctors(), this.notifyOwners()));
	return g
};
skim.engine.VertexDef.prototype.setMaterialAndPropagate = function (a) {
	var b = this.getPos();
	this.setVertexAndPropagate(b.x, b.y, b.z, this.getThickness(), a, this.getVolType())
};
skim.engine.VertexDef.prototype.setVertex = function (a, b, c, d, e, f) {
	var g = !1;
	skim.utils.isApproxEqual(a, this.pos.x, skim.engine.functorPrecision) && skim.utils.isApproxEqual(b, this.pos.y, skim.engine.functorPrecision) && skim.utils.isApproxEqual(c, this.pos.z, skim.engine.functorPrecision) && skim.utils.isApproxEqual(d, this.thickness, skim.engine.functorPrecision) && e.equals(this.material) && f === this.volType || (a = new THREE.Vector3(a, b, c), d = {
			t : d
		}, this.adjustFromAttrFunctors(a, d), g = !0, skim.utils.isApproxEqual(a.x, this.pos.x,
			skim.engine.functorPrecision) && skim.utils.isApproxEqual(a.y, this.pos.y, skim.engine.functorPrecision) && skim.utils.isApproxEqual(a.z, this.pos.z, skim.engine.functorPrecision) && skim.utils.isApproxEqual(d.t, this.thickness, skim.engine.functorPrecision) && e.equals(this.material) && f === this.volType || (this.pos.set(a.x, a.y, a.z), this.thickness = d.t, this.material.copy(e), this.volType = f, this.updateReactorAttr({
				pos : new THREE.Vector3(this.pos.x, this.pos.y, this.pos.z)
			}), this.updateReactorAttr({
				thickness : this.thickness
			}),
			this.updateReactorAttr({
				volType : this.volType
			}), this.updateReactorAttr({
				material : this.material
			}), this.notifyOwners()));
	return g
};
skim.engine.VertexDef.prototype.commit = function () {
	skim.engine.vars.vertices[this.id] = this;
	for (var a = Object.keys(skim.engine.adjust_functors), b = 0; b < a.length; ++b)
		this.insertAdjustAttrFunctor(skim.engine.adjust_functors[a[b]], -1);
	var a = new THREE.Vector3(this.pos.x, this.pos.y, this.pos.z),
	b = {
		t : this.thickness
	},
	c = new skim.utils.Security(25);
	for (c.init(25, "Vdef: finding initial position is too long"); c.valid() && !this.checkFunctorList(a, b); c.inc())
		this.loopOnFunctorList(a, b);
	skim.utils.assert(this.checkFunctorList(a,
			b), "can't find a valid position for vertex " + this.id);
	this.setVertexAndPropagate(a.x, a.y, a.z, b.t, this.getMaterial(), this.getVolType())
};
skim.engine.VertexDef.prototype.destroy = function () {
	for (var a = this.getOwners(), b = Object.keys(a), c = 0; c < b.length; ++c) {
		var d = a[b[c]];
		d.canLiveWithout(this) ? d.removeVertex(this) : d.destroy()
	}
	for (delete skim.engine.vars.vertices[this.id]; 0 !== this.adjust_functors.length; )
		this.adjust_functors[0].onDestroy(this);
	for (; 0 !== this.link_functors.length; )
		this.link_functors[0].onDestroy(this)
};
skim.engine.VertexDef.prototype.getSyms = function (a, b) {
	if (void 0 === a[this.id]) {
		a[this.id] = !0;
		b[this.id.toString()] = this;
		for (var c = this.getLinkFunctorByClass(skim.engine.linkFunctors.VPlaneSymmetryAxis), d = 0; d < c.length; ++d) {
			var e = c[d].getSym(this);
			b[e.id] = e;
			e.getSyms(a, b)
		}
	}
};
skim.engine.VertexDef.prototype.getGroup = function (a, b) {
	b[this.id] = this;
	for (var c = 0; c < this.link_functors.length; ++c)
		this.link_functors[c].getGroup(a, b)
};
skim.engine.VertexDef.prototype.getMaster = function () {
	var a = {};
	this.getGroup({}, a);
	var b = Object.keys(a);
	if (0 !== b.length) {
		skim.utils.assert(0 !== b.length, "Election with no candidates is foolish.");
		for (var c = b[0], d = a[c], e = 1; e < b.length; ++e)
			c = d > a[b[e]].id ? b[e] : c;
		return a[c]
	}
	return this
};
skim.engine.VertexDef.prototype.updateReactorAttr = function (a) {
	this.hasReactor() && this.reactor.set(a)
};
skim.engine.VertexDef.prototype.hasReactor = function () {
	return null !== this.reactor
};
skim.engine.VertexDef.prototype.createReactor = function () {
	this.reactor = new skim.skel.VertexReactor({
			id : this.id,
			pos : this.pos.clone(),
			thickness : this.thickness,
			material : this.material.clone(),
			volType : this.getVolType()
		})
};
skim.engine.VertexDef.prototype.getReactor = function () {
	this.hasReactor() || this.createReactor();
	return this.reactor
};
skim.engine.VertexDef.buildFromJSON = function (a) {
	var b = new skim.engine.VertexDef(new THREE.Vector3(a.x, a.y, a.z), a.t, void 0 !== a.m ? skim.Material.buildFromJSON(a.m) : skim.instances.defaultMaterial.clone(), a.vt);
	void 0 !== a.n && b.setName(a.n.slice(0, a.n.length));
	b.commit();
	return b
};
skim.engine.VertexDef.prototype.getJSON = function (a) {
	var b = null;
	if (void 0 !== a && null !== a && 0 < a)
		var c = Math.pow(10, a), b = function () {
			var a = 0;
			return function (b) {
				a = Math.round(b);
				return a + Math.round((b - a) * c) / c
			}
		}
	();
	else
		b = function (a) {
			return a
		};
	a = {
		x : b(this.pos.x),
		y : b(this.pos.y),
		z : b(this.pos.z),
		t : b(this.thickness),
		vt : this.volType,
		m : this.material.getJSON()
	};
	null !== this.name && (a.n = this.name.slice(0, this.name.length));
	return a
};
skim.engine.primsIds = 0;
skim.engine.PrimitiveDef = function (a, b, c) {
	this.id = skim.engine.primsIds++;
	this.v = a;
	this.materials = b;
	this.volType = c;
	this.name = this.reactor = this.name = null;
	for (b = 0; b < a.length; b++)
		a[b].addOwner(this);
	this.link_functors = []
};
skim.engine.PrimitiveDef.prototype.isParametric = function () {
	skim.utils.assert(!1, "Not implemented : isParametric");
	return !1
};
skim.engine.PrimitiveDef.prototype.isImplicit = function () {
	skim.utils.assert(!1, "Not implemented : isImplicit");
	return !0
};
skim.engine.PrimitiveDef.prototype.getVolType = function () {
	return this.volType
};
skim.engine.PrimitiveDef.prototype.setVolType = function (a) {
	this.volType = a
};
skim.engine.PrimitiveDef.prototype.getMaterials = function () {
	return this.materials
};
skim.engine.PrimitiveDef.prototype.setMaterials = function (a) {
	this.materials = a;
	null !== this.materials && null !== a && skim.utils.assert(this.materials.length === a.length, "Error : setting " + a.length + " materials on a primitive with " + this.materials.length + " materials")
};
skim.engine.PrimitiveDef.prototype.setMaterialAt = function (a, b) {
	skim.utils.assert(a < this.materials.length, "Error : material index out of bound");
	this.materials[a] = b
};
skim.engine.PrimitiveDef.prototype.getName = function () {
	return this.name
};
skim.engine.PrimitiveDef.prototype.setName = function (a) {
	this.name = a
};
skim.engine.PrimitiveDef.prototype.commit = function () {
	skim.engine.vars.primitives[this.id] = this
};
skim.engine.PrimitiveDef.prototype.vertexChanged = function (a) {};
skim.engine.PrimitiveDef.prototype.insertFunctor = function (a, b, c) {
	if (void 0 !== c && (0 > c || c >= a.length))
		a.push(b);
	else {
		a.push(b);
		for (var d = a.length - 1; d > c; ++d)
			a[d] = a[d - 1];
		a[c] = b
	}
};
skim.engine.PrimitiveDef.prototype.removeFunctor = function (a, b) {
	for (var c = 0; c < a.length; ++c)
		if (b === a[c]) {
			for (; c < a.length - 1; ++c)
				a[c] = a[c + 1];
			a.length -= 1;
			break
		}
};
skim.engine.PrimitiveDef.prototype.getFunctorByClass = function (a, b) {
	for (var c = [], d = 0; d < a.length; ++d)
		a[d]instanceof b && c.push(a[d]);
	return c
};
skim.engine.PrimitiveDef.prototype.insertLinkFunctor = function (a, b) {
	this.insertFunctor(this.link_functors, a, b)
};
skim.engine.PrimitiveDef.prototype.removeLinkFunctor = function (a) {
	this.removeFunctor(this.link_functors, a)
};
skim.engine.PrimitiveDef.prototype.getLinkFunctorByClass = function (a) {
	return this.getFunctorByClass(this.link_functors, a)
};
skim.engine.PrimitiveDef.prototype.setPrimitiveAndPropagate = function (a, b) {
	skim.Material.areEqualsArrays(a, this.materials) && b === this.volType || (this.setMaterials(a), this.volType = b, this.updateReactorAttr({
			volType : this.volType
		}), this.updateReactorAttr({
			materials : this.materials
		}), this.propagateLinkFunctors())
};
skim.engine.PrimitiveDef.prototype.propagateLinkFunctors = function () {
	var a = {};
	a[this.id] = this;
	a.order = [this];
	var b = new skim.utils.Security(skim.utils.maxSec / 2);
	for (b.init(skim.utils.maxSec / 2, "Pdef: propagation is too long"); b.valid() && 0 < a.order.length; b.inc()) {
		for (var c = {
				order : []
			}, d = 0; d < a.order.length; ++d)
			for (var e = a.order[d], f = 0; f < e.link_functors.length; ++f)
				e.link_functors[f].propagateChange(e, c);
		a = c
	}
	return b.hasBroken
};
skim.engine.PrimitiveDef.prototype.getGroup = function (a, b) {
	for (var c = 0; c < this.link_functors.length; ++c)
		this.link_functors[c].getGroup(a, b)
};
skim.engine.PrimitiveDef.prototype.getMaster = function () {
	var a = {};
	this.getGroup({}, a);
	var b = Object.keys(a);
	if (0 !== b.length) {
		skim.utils.assert(0 !== b.length, "Election with no candidate is foolish.");
		for (var c = b[0], d = a[c], e = 1; e < b.length; ++e)
			c = d > a[b[e]].id ? b[e] : c;
		return a[c]
	}
	return this
};
skim.engine.PrimitiveDef.prototype.hasVertDef = function (a) {
	if (a instanceof skim.engine.VertexDef)
		for (var b = 0; b < this.v.length; b++) {
			if (this.v[b] == a)
				return !0
		}
	else
		for (b = 0; b < this.v.length; b++)
			if (this.v[b].id == a)
				return !0;
	return !1
};
skim.engine.PrimitiveDef.prototype.destroy = function () {
	delete skim.engine.vars.primitives[this.id];
	for (var a = 0; a < this.v.length; a++)
		this.v[a].removeOwner(this);
	for (; 0 !== this.link_functors.length; )
		this.link_functors[0].onDestroy(this)
};
skim.engine.PrimitiveDef.prototype.hasReactor = function () {
	return null !== this.reactor
};
skim.engine.PrimitiveDef.prototype.getReactor = function () {
	return this.reactor
};
skim.engine.PrimitiveDef.prototype.updateReactor = function () {
	if (this.hasReactor()) {
		this.getMaterials();
		this.reactor.getMaterials();
		if (null !== this.getMaterials() && this.reactor.getMaterials())
			for (var a = this.reactor.getMaterials(), b = 0; b < a.length && a[b].equals(this.getMaterials()[b]); ++b);
		this.reactor.setMaterials(this.getMaterials());
		this.getVolType() !== this.reactor.getVolType() && this.reactor.setVolType(this.getVolType());
		console.warning("This function should be overwritten in primitives, cause special cases can occur");
		for (b = 0; b < this.v.length; b++)
			this.reactor.swapVertex(b, this.v[b].getMaster().getReactor())
	} else
		this.createReactor()
};
skim.engine.PrimitiveDef.prototype.updateReactorAttr = function (a) {
	this.hasReactor() && this.reactor.set(a)
};
skim.engine.PrimitiveDef.prototype.createReactor = function () {
	skim.utils.assert(!1, "Error : createReactor must not be called if the function has not be overwritten in a child primitive")
};
skim.engine.PrimitiveDef.prototype.destroyReactor = function () {
	this.hasReactor() && (void 0 !== skim.instances.skel.prims[this.id] ? skim.instances.skel.removePrim(this.getReactor()) : this.reactor.destroy(), this.reactor = null)
};
skim.engine.PrimitiveDef.prototype.swapVertex = function (a, b) {
	for (var c = 0; c < this.v.length; c++)
		if (this.v[c].id == a.id) {
			console.log("SWAP " + this.v[c].id + " with " + b.id + " in prim " + this.id);
			this.v[c] = b;
			b.addOwner(this);
			a.removeOwner(this);
			break
		}
	this.updateReactor()
};
skim.engine.PrimitiveDef.prototype.canLiveWithout = function (a) {
	skim.utils.assert(!1, "Error : canLiveWithout must not be called if the function has not be overwritten in a child primitive");
	return !0
};
skim.engine.PrimitiveDef.prototype.removeVertex = function (a) {};
skim.engine.PrimitiveDef.prototype.getSyms = function (a, b) {
	skim.utils.assert(!1, "Error : getSyms must not be called if the function has not be overwritten in a child primitive")
};
skim.engine.PrimitiveDef.buildFromJSON = function (a, b) {
	skim.utils.assert(!1, "Error : buildFromJSON must not be called if the function has not be overwritten in a child primitive");
	return new skim.engine.PrimitiveDef([], null, skim.VolType.Mech)
};
skim.engine.PrimitiveDef.prototype.getJSON = function (a, b, c) {
	skim.utils.assert(!1, "Error : getJSON must not be called if the function has not be overwritten in a child primitive");
	return {}

};
skim.engine.PrimitiveDef.prototype.getJSONKey = function () {
	skim.utils.assert(!1, "Error: getJSONKey must not be called if the function has not be overwritten in a child primitive");
	return ""
};
skim.engine.PrimitiveDef.RegisterJSONKey = {};
skim.engine.SegmentDef = function (a, b, c) {
	skim.engine.PrimitiveDef.call(this, a, b, c)
};
skim.engine.SegmentDef.prototype = Object.create(skim.engine.PrimitiveDef.prototype);
skim.engine.SegmentDef.prototype.constructor = skim.engine.SegmentDef;
skim.engine.SegmentDef.prototype.isParametric = function () {
	return !1
};
skim.engine.SegmentDef.prototype.isImplicit = function () {
	return !0
};
skim.engine.PrimitiveDef.prototype.updateReactor = function () {
	if (this.hasReactor()) {
		this.getMaterials();
		this.reactor.getMaterials();
		if (null !== this.getMaterials() && this.reactor.getMaterials())
			for (var a = this.reactor.getMaterials(), b = 0; b < a.length && a[b].equals(this.getMaterials()[b]); ++b);
		this.reactor.setMaterials(this.getMaterials());
		this.getVolType() !== this.reactor.getVolType() && this.reactor.setVolType(this.getVolType());
		a = this.v[0].getMaster().getReactor();
		b = this.v[1].getMaster().getReactor();
		if (a !==
			b)
			for (b = 0; b < this.v.length; b++)
				this.reactor.swapVertex(b, this.v[b].getMaster().getReactor());
		else
			this.destroyReactor();
		this.hasReactor() && (this.reactor.computeHelpVariables(), 0 === this.reactor.length && this.destroyReactor())
	} else
		this.createReactor()
};
skim.engine.SegmentDef.prototype.createReactor = function () {
	var a = this.v[0].getMaster().getReactor(),
	b = this.v[1].getMaster().getReactor();
	a !== b ? this.reactor = new skim.skel.SegmentReactor({
			id : this.id,
			v0 : a,
			v1 : b,
			materials : this.materials,
			volType : this.getVolType()
		}) : this.destroyReactor();
	this.hasReactor() && (this.reactor.computeHelpVariables(), 0 === this.reactor.length && this.destroyReactor())
};
skim.engine.SegmentDef.prototype.canLiveWithout = function (a) {
	skim.utils.assert(this.v[0] === a || this.v[1] === a, "Error : removeVertex must OF COURSE be called ");
	return !1
};
skim.engine.SegmentDef.prototype.getSyms = function (a, b) {
	if (void 0 === a[this.id]) {
		a[this.id] = !0;
		b[this.id.toString()] = this;
		for (var c = this.getLinkFunctorByClass(skim.engine.linkFunctors.SegPlaneSymmetryAxis), d = 0; d < c.length; ++d) {
			var e = c[d].getSym(this);
			b[e.id] = e;
			e.getSyms(a, b)
		}
	}
};
skim.engine.SegmentDef.buildFromJSON = function (a, b) {
	var c = [b[a.v0], b[a.v1]],
	d = null;
	if (void 0 !== a.m)
		for (var d = [], e = 0; e < a.m.length; ++e)
			d.push(skim.Material.buildFromJSON(a.m[e]));
	c = new skim.engine.SegmentDef(c, d, a.vt);
	void 0 !== a.n && c.setName(a.n.slice(0, a.n.length));
	c.commit();
	return c
};
skim.engine.SegmentDef.JSONKey = "segments";
skim.utils.assert(void 0 === skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.SegmentDef.JSONKey], "Error : token" + skim.engine.SegmentDef.JSONKey + " already register (by another primitive?)");
skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.SegmentDef.JSONKey] = skim.engine.SegmentDef.buildFromJSON;
skim.engine.PrimitiveDef.RegisterJSONKey.seg = skim.engine.SegmentDef.buildFromJSON;
skim.engine.SegmentDef.prototype.getJSONKey = function () {
	return skim.engine.SegmentDef.JSONKey
};
skim.engine.SegmentDef.prototype.getJSON = function (a, b, c) {
	a = {
		v0 : b[this.v[0].id],
		v1 : b[this.v[1].id],
		vt : this.getVolType()
	};
	if (null !== this.materials)
		for (a.m = [], b = 0; b < this.materials.length; ++b)
			a.m.push(this.materials[b].getJSON());
	null !== this.name && (a.n = this.name.slice(0, this.name.length));
	return a
};
skim.engine.RingDef = function (a, b) {
	skim.engine.PrimitiveDef.call(this, [], null, b);
	this.rz_projector = new skim.ringUtils.RZProjector;
	this.wait_removal = {};
	this.reactor_up_to_date = !1;
	this.limitControlSetsAngle = this.pairedThickness = this.pairedRadial = this.pairedHeight = !0;
	this.mindDistLimit = 10;
	this.maxDistLimit = 300;
	this.minMaxDistActivated = !1;
	this.angleLimitFunctor = new skim.engine.linkFunctors.CSMinAngles(Math.PI / 1400);
	this.angleLimitFunctor.setEngineManaged(!1);
	this.addConstraints(a)
};
skim.engine.RingDef.prototype = Object.create(skim.engine.PrimitiveDef.prototype);
skim.engine.RingDef.prototype.constructor = skim.engine.RingDef;
skim.engine.RingDef.prototype.isParametric = function () {
	return !1
};
skim.engine.RingDef.prototype.isImplicit = function () {
	return !0
};
skim.engine.RingDef.prototype.vertexChanged = function (a) {
	this.reactor_up_to_date = !1
};
skim.engine.RingDef.prototype.createReactor = function () {
	skim.utils.assert(!this.hasReactor(), "Error : the reactor should not exist at this point.");
	for (var a = {}, b = [], c = 0, d = this.v.length; c < d; c++) {
		var e = this.v[c].getMaster(),
		e = skim.ringUtils.getSetIdxFromId(this, e.id);
		if (void 0 === a[e]) {
			for (var f = 0; 4 > f; f++)
				b.push(this.v[e + f].getReactor());
			a[e] = !0
		}
	}
	console.log(b);
	this.reactor = new skim.skel.RingReactor({
			id : this.id,
			v : b,
			materials : this.materials,
			volType : this.getVolType()
		});
	this.reactor_up_to_date = !0
};
skim.engine.RingDef.prototype.updateReactor = function () {
	skim.utils.assert(0 === Object.keys(this.wait_removal).length, "Error : Cannot updateREactor while ringDef is awaiting verteices removal");
	this.hasReactor() && this.reactor_up_to_date || (this.destroyReactor(), this.createReactor())
};
skim.engine.RingDef.prototype.safeRemoveFunctor = function (a, b) {
	var c = a.getLinkFunctorByClass(b);
	skim.utils.assert(b === skim.engine.linkFunctors.VPairHeight || b === skim.engine.linkFunctors.VPairRadial || b === skim.engine.linkFunctors.VPairThickness, "Use this function only for VPairHeight & VPairRadial & VPairThickness");
	skim.utils.assert(1 >= c.length, "should not have more than one element for this functor");
	1 === c.length && c[0].destroy()
};
skim.engine.RingDef.prototype.addConstraints = function (a) {
	skim.utils.assert(0 === a.length % 4, "Error : constraints are made of sets of 4 vertices.");
	for (var b = 0; b < a.length; b++)
		a[b].addOwner(this);
	for (var c = a.length / 4, b = 0; b < c; ++b) {
		for (var d = 4 * b, e = 0; 4 > e; ++e)
			this.v.push(a[d + e]);
		e = a.slice(d, d + 4);
		(new skim.engine.linkFunctors.VRadialCoplanarity(e)).setEngineManaged(!1);
		new skim.engine.adjustAttrFunctors.VDistantVertices(e);
		new skim.engine.adjustAttrFunctors.VListTrigoOrientedInPlane(e, this.rz_projector);
		new skim.engine.adjustAttrFunctors.VSetConvexInPlane(e,
			this.rz_projector);
		skim.utils.assert(0 === a[d].getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.VMagnetRing).length, "Control sets should not have a radial magnet functor");
		this.pairedHeight && ((new skim.engine.linkFunctors.VPairHeight([a[d], a[d + 1]])).setEngineManaged(!1), (new skim.engine.linkFunctors.VPairHeight([a[d + 2], a[d + 3]])).setEngineManaged(!1));
		this.pairedRadial && ((new skim.engine.linkFunctors.VPairRadial([a[d], a[d + 3]])).setEngineManaged(!1), (new skim.engine.linkFunctors.VPairRadial([a[d +
							1], a[d + 2]])).setEngineManaged(!1));
		this.pairedThickness && (new skim.engine.linkFunctors.VPairThickness(e)).setEngineManaged(!1);
		this.limitControlSetsAngle && this.angleLimitFunctor.addControlSets(e)
	}
	this.reactor_up_to_date = !1;
	this.checkVertices()
};
skim.engine.RingDef.prototype.checkVertices = function () {
	for (var a = 0, b = !1; a < this.v.length; a += 4) {
		var c = this.rz_projector.project(this.v[a].getPos()),
		d = this.rz_projector.project(this.v[a + 1].getPos()),
		e = this.rz_projector.project(this.v[a + 2].getPos()),
		f = this.rz_projector.project(this.v[a + 3].getPos());
		if (!(c.x > d.x && 0 < c.x && c.y > f.y && d.y > e.y && f.x > e.x && 0 < f.x))
			break;
		b = !0
	}
	skim.utils.assert(b, "control set definition does not respect the convention")
};
skim.engine.RingDef.prototype.canLiveWithout = function (a) {
	skim.utils.assert(skim.ringUtils.hasVert(this, a.id), "Error : please do not call canLiveWithout(vdef) on a primitive which does not contain vdef...");
	return 4 < this.v.length ? !0 : !1
};
skim.engine.RingDef.prototype.rmConstraintAndOrganize = function (a) {
	a = skim.ringUtils.getSetIdxFromId(this, a.id);
	for (var b = 0; 4 > b; ++b)
		this.v[a + b] = this.v[this.v.length - 4 + b];
	this.v.length -= 4;
	this.reactor_up_to_date = !1
};
skim.engine.RingDef.prototype.removeVertex = function (a) {
	for (var b = !1, c = Object.keys(this.wait_removal), d = 0; d < c.length; ++d)
		for (var e = this.wait_removal[c[d]], f = 0; f < e.length; ++f)
			e[f] == a && (b = !0, e[f] = e[e.length - 1], 1 == e.length ? (delete this.wait_removal[c[d]], this.rmConstraintAndOrganize(a)) : e.length -= 1);
	if (!b) {
		b = skim.ringUtils.getSetIdxFromId(this, a.id);
		skim.utils.assert(-1 != b, "Error : could not get the index of the ring constraint");
		skim.utils.assert(void 0 === this.wait_removal[a.id], "Error : obviously the choice of hash key does not guarantee unicity...");
		c = [];
		for (d = 0; 4 > d; ++d)
			this.v[b + d] != a && c.push(this.v[b + d]);
		this.wait_removal[a.id] = c
	}
	a.removeOwner(this);
	this.reactor_up_to_date = !1
};
skim.engine.RingDef.prototype.removeConstraint = function (a) {
	skim.utils.assert(4 < this.v.length, "Error : do not call removeConstraint on the last constraint. Delete the primitive instead calling canLiveWithout to know.");
	a = skim.ringUtils.getSetIdxFromId(this, a);
	this.v[a].getLinkFunctorByClass(skim.engine.linkFunctors.VRadialCoplanarity)[0].destroy();
	this.v[a].getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.VSetConvexInPlane)[0].destroy();
	this.v[a].getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.VListTrigoOrientedInPlane)[0].destroy();
	this.desactivateMinMaxDist(a);
	this.safeRemoveFunctor(this.v[a], skim.engine.linkFunctors.VPairHeight);
	this.safeRemoveFunctor(this.v[a + 2], skim.engine.linkFunctors.VPairHeight);
	this.safeRemoveFunctor(this.v[a], skim.engine.linkFunctors.VPairRadial);
	this.safeRemoveFunctor(this.v[a + 2], skim.engine.linkFunctors.VPairRadial);
	this.safeRemoveFunctor(this.v[a], skim.engine.linkFunctors.VPairThickness);
	this.safeRemoveFunctor(this.v[a], skim.engine.linkFunctors.CSgroupedAngles);
	for (var b = a; b < a + 4; b++)
		this.removeVertex(this.v[b]);
	this.reactor_up_to_date = !1
};
skim.engine.RingDef.prototype.fixControlSets = function () {
	for (var a = new skim.engine.adjustAttrFunctors.VFixedPos, b = new skim.engine.adjustAttrFunctors.VFixedThick, c = 0; c < this.v.length; c++)
		skim.utils.assert(0 === this.v[c].getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.VFixedPos).length, "Trying to add a fixed pos functor on something already fixed"), this.v[c].insertAdjustAttrFunctor(a, -1), skim.utils.assert(0 === this.v[c].getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.VFixedThick).length, "Trying to add a fixed thick functor on something already fixed"),
		this.v[c].insertAdjustAttrFunctor(b, -1)
};
skim.engine.RingDef.prototype.setPairedHeight = function (a) {
	this.pairedHeight = a
};
skim.engine.RingDef.prototype.setPairedRadial = function (a) {
	this.pairedRadial = a
};
skim.engine.RingDef.prototype.activateMinMaxDist = function () {
	for (var a = this.v.length / 4, b = 0; b < a; ++b)
		for (var c = 4 * b, d = 0, e = 3; 4 > d; d++, e = d - 1)
			(new skim.engine.linkFunctors.VPairMinDist([this.v[c + d], this.v[c + e]], this.mindDistLimit, this.maxDistLimit)).setEngineManaged(!1);
	this.minMaxDistActivated = !0
};
skim.engine.RingDef.prototype.desactivateMinMaxDist = function (a) {
	if (this.minMaxDistActivated)
		for (var b = 0; 4 > b; b++)
			this.v[a + b].getLinkFunctorByClass(skim.engine.linkFunctors.VPairMinDist)[0].destroy()
};
skim.engine.RingDef.prototype.getSyms = function (a, b) {
	if (void 0 === a[this.id]) {
		a[this.id] = !0;
		b[this.id.toString()] = this;
		for (var c = this.getLinkFunctorByClass(skim.engine.linkFunctors.RingPlaneSymmetryAxis), d = 0; d < c.length; ++d) {
			var e = c[d].getSym(this);
			b[e.id] = e;
			e.getSyms(a, b)
		}
	}
};
skim.engine.RingDef.buildFromJSON = function (a, b) {
	var c = [];
	if (void 0 !== a.v)
		for (var d = 0; d < a.v.length; ++d)
			c.push(b[a.v[d]]);
	if (void 0 !== a.m)
		for (var e = [], d = 0; d < a.m.length; ++d)
			e.push(skim.Material.buildFromJSON(a.m[d]));
	c = new skim.engine.RingDef(c, a.vt);
	void 0 !== a.n && c.setName(a.n.slice(0, a.n.length));
	c.commit();
	return c
};
skim.engine.RingDef.JSONKey = "rings";
skim.utils.assert(void 0 === skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.RingDef.JSONKey], "Error : token" + skim.engine.RingDef.JSONKey + " already register (by another primitive?)");
skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.RingDef.JSONKey] = skim.engine.RingDef.buildFromJSON;
skim.engine.RingDef.prototype.getJSONKey = function () {
	return skim.engine.RingDef.JSONKey
};
skim.engine.RingDef.prototype.getJSON = function (a, b, c) {
	a = {
		v : [],
		vt : this.getVolType()
	};
	for (c = 0; c < this.v.length; ++c)
		a.v.push(b[this.v[c].id]);
	if (null !== this.materials)
		for (a.m = [], c = 0; c < this.materials.length; ++c)
			a.m.push(this.materials[c].getJSON());
	null !== this.name && (a.n = this.name.slice(0, this.name.length));
	return a
};
skim.engine.MeshDef = function (a, b, c, d) {
	skim.engine.PrimitiveDef.call(this, a, c, d);
	skim.utils.assert(3 * Math.floor(b.vertices.length / 3) === b.vertices.length, "Error : vertices array must be divisible by 3 for x y z coordinates");
	skim.utils.assert(3 * Math.floor(b.faces.length / 3) === b.faces.length, "Error : faces array must be divisible by 3 for a b c vertices");
	this.abmesh = new skim.utils.ArrayBufferMesh(10);
	this.abmesh.set(new Float32Array(b.vertices), new Float32Array(b.normals), new Int32Array(b.faces), null,
		null, null, Math.floor(b.vertices.length / 3), Math.floor(b.faces.length / 3))
};
skim.engine.MeshDef.prototype = Object.create(skim.engine.PrimitiveDef.prototype);
skim.engine.MeshDef.prototype.constructor = skim.engine.MeshDef;
skim.engine.MeshDef.prototype.isParametric = function () {
	return !0
};
skim.engine.MeshDef.prototype.isImplicit = function () {
	return !1
};
skim.engine.MeshDef.prototype.getMesh = function () {
	return this.abmesh
};
skim.engine.MeshDef.prototype.updateReactor = function () {
	if (this.hasReactor()) {
		this.reactor.setMesh(this.abmesh);
		this.getMaterials();
		this.reactor.getMaterials();
		if (null !== this.getMaterials() && this.reactor.getMaterials())
			for (var a = this.reactor.getMaterials(), b = 0; b < a.length && a[b].equals(this.getMaterials()[b]); ++b);
		this.reactor.setMaterials(this.getMaterials());
		this.getVolType() !== this.reactor.getVolType() && this.reactor.setVolType(this.getVolType())
	} else
		this.createReactor()
};
skim.engine.MeshDef.prototype.createReactor = function () {
	this.reactor = new skim.skel.MeshReactor({
			mesh : this.abmesh,
			id : this.id,
			materials : this.materials,
			volType : this.getVolType()
		})
};
skim.engine.MeshDef.prototype.canLiveWithout = function (a) {
	return !0
};
skim.engine.MeshDef.prototype.getSyms = function (a, b) {
	if (void 0 === a[this.id]) {
		a[this.id] = !0;
		b[this.id.toString()] = this;
		for (var c = this.getLinkFunctorByClass(skim.engine.linkFunctors.MeshPlaneSymmetryAxis), d = 0; d < c.length; ++d) {
			var e = c[d].getSym(this);
			b[e.id] = e;
			e.getSyms(a, b)
		}
	}
};
skim.engine.MeshDef.buildFromJSON = function (a, b) {
	var c = null;
	if (void 0 !== a.m)
		for (var c = [], d = 0; d < a.m.length; ++d)
			c.push(skim.Material.buildFromJSON(a.m[d]));
	d = null;
	void 0 !== a.mesh && null !== a.mesh ? d = skim.utils.ArrayBufferMesh.buildFromJSON(a.mesh) : skim.utils.assert(!1, "Error : cannot load MeshDef from JSON, jsaon_data.mesh is undefined or null");
	c = new skim.engine.MeshDef([], d, c, a.vt);
	void 0 !== a.n && c.setName(a.n.slice(0, a.n.length));
	c.commit();
	return c
};
skim.engine.MeshDef.JSONKey = "meshes";
skim.utils.assert(void 0 === skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.MeshDef.JSONKey], "Error : token" + skim.engine.MeshDef.JSONKey + " already register (by another primitive?)");
skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.MeshDef.JSONKey] = skim.engine.MeshDef.buildFromJSON;
skim.engine.PrimitiveDef.RegisterJSONKey.mesh = skim.engine.MeshDef.buildFromJSON;
skim.engine.MeshDef.prototype.getJSONKey = function () {
	return skim.engine.MeshDef.JSONKey
};
skim.engine.MeshDef.prototype.getJSON = function (a, b, c) {
	a = {
		mesh : this.abmesh.getJSON(c),
		vt : this.getVolType()
	};
	if (null !== this.materials)
		for (a.m = [], b = 0; b < this.materials.length; ++b)
			a.m.push(this.materials[b].getJSON());
	null !== this.name && (a.n = this.name.slice(0, this.name.length));
	return a
};
skim.engine.TextRingDef = function (a, b) {
	skim.engine.RingDef.call(this, a, skim.VolType.Mech);
	this.imageData = b
};
skim.engine.TextRingDef.prototype = Object.create(skim.engine.RingDef.prototype);
skim.engine.TextRingDef.prototype.constructor = skim.engine.TextRingDef;
skim.engine.TextRingDef.prototype.isParametric = function () {
	return !1
};
skim.engine.TextRingDef.prototype.isImplicit = function () {
	return !0
};
skim.engine.TextRingDef.prototype.createReactor = function () {
	skim.utils.assert(!this.hasReactor(), "Error : the reactor should not exist at this point.");
	for (var a = {}, b = [], c = 0, d = this.v.length; c < d; c++)
		void 0 === a[this.v[c].getMaster().id] && (b.push(this.v[c].getMaster().getReactor()), a[this.v[c].getMaster().id] = !0);
	this.reactor = new skim.skel.TextRingReactor({
			id : this.id,
			v : b,
			imageData : this.imageData,
			volType : this.getVolType()
		});
	this.reactor_up_to_date = !0
};
skim.engine.TextRingDef.buildFromJSON = function (a, b) {
	skim.utils.assert(!1, "TODO");
	return new skim.engine.TextRingDef([], {})
};
skim.engine.TextRingDef.JSONKey = "txtring";
skim.utils.assert(void 0 === skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.TextRingDef.JSONKey], "Error : token" + skim.engine.TextRingDef.JSONKey + " already register (by another primitive?)");
skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.TextRingDef.JSONKey] = skim.engine.TextRingDef.buildFromJSON;
skim.engine.TextRingDef.prototype.getJSONKey = function () {
	return skim.engine.TextRingDef.JSONKey
};
skim.engine.TextRingDef.prototype.getJSON = function (a, b, c) {
	skim.utils.assert(!1, "Error : cannot save text ring");
	a = {};
	null !== this.name && (a.n = this.name.slice(0, this.name.length));
	return a
};
skim.engine.TextDef = function (a, b) {
	skim.engine.PrimitiveDef.call(this, a, null, skim.VolType.Mech);
	this.imageData = b
};
skim.engine.TextDef.prototype = Object.create(skim.engine.PrimitiveDef.prototype);
skim.engine.TextDef.prototype.constructor = skim.engine.TextDef;
skim.engine.TextDef.prototype.isParametric = function () {
	return !1
};
skim.engine.TextDef.prototype.isImplicit = function () {
	return !0
};
skim.engine.TextDef.prototype.createReactor = function () {
	skim.utils.assert(!this.hasReactor(), "Error : the reactor should not exist at this point.");
	for (var a = {}, b = [], c = 0, d = this.v.length; c < d; c++)
		void 0 === a[this.v[c].getMaster().id] && (b.push(this.v[c].getMaster().getReactor()), a[this.v[c].getMaster().id] = !0);
	this.reactor = new skim.skel.TextReactor({
			id : this.id,
			v : b,
			imageData : this.imageData,
			volType : this.getVolType()
		});
	this.reactor_up_to_date = !0
};
skim.engine.TextDef.buildFromJSON = function (a, b) {
	skim.utils.assert(!1, "TODO");
	return new skim.skim.engine.TextDef([], {})
};
skim.engine.TextDef.JSONKey = "text";
skim.utils.assert(void 0 === skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.TextDef.JSONKey], "Error : token" + skim.engine.TextDef.JSONKey + " already register (by another primitive?)");
skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.TextDef.JSONKey] = skim.engine.TextDef.buildFromJSON;
skim.engine.TextDef.prototype.getJSONKey = function () {
	return skim.engine.TextDef.JSONKey
};
skim.engine.TextDef.prototype.getJSON = function (a, b) {
	skim.utils.assert(!1, "Error : cannot save text");
	var c = {};
	null !== this.name && (c.n = this.name.slice(0, this.name.length));
	return c
};
skim.engine.TriEdge = {
	E_NONE : -1,
	E_P0P1 : 0,
	E_P1P2 : 1,
	E_P2P0 : 2
};
skim.engine.TriangleDef = function (a, b, c) {
	skim.engine.PrimitiveDef.call(this, a, b, c)
};
skim.engine.TriangleDef.prototype = Object.create(skim.engine.PrimitiveDef.prototype);
skim.engine.TriangleDef.prototype.constructor = skim.engine.TriangleDef;
skim.engine.TriangleDef.prototype.isParametric = function () {
	return !1
};
skim.engine.TriangleDef.prototype.isImplicit = function () {
	return !0
};
skim.engine.TriangleDef.prototype.createReactor = function () {
	skim.utils.assert(!this.hasReactor(), "Error : the reactor should not exist at this point.");
	for (var a = {}, b = [], c = 0, d = this.v.length; c < d; c++)
		void 0 === a[this.v[c].getMaster().id] && (b.push(this.v[c].getMaster().getReactor()), a[this.v[c].getMaster().id] = !0);
	this.reactor = new skim.skel.TriangleReactor({
			id : this.id,
			v : b,
			materials : this.materials,
			volType : this.getVolType()
		})
};
skim.engine.TriangleDef.prototype.canLiveWithout = function (a) {
	skim.utils.assert(this.v[0] === a || this.v[1] === a || this.v[2] === a, "Error : removeVertex must OF COURSE be called ");
	return !1
};
skim.engine.TriangleDef.prototype.getSyms = function (a, b) {
	if (void 0 === a[this.id]) {
		a[this.id] = !0;
		b[this.id.toString()] = this;
		for (var c = this.getLinkFunctorByClass(skim.engine.linkFunctors.TriPlaneSymmetryAxis), d = 0; d < c.length; ++d) {
			var e = c[d].getSym(this);
			b[e.id] = e;
			e.getSyms(a, b)
		}
	}
};
skim.engine.TriangleDef.buildFromJSON = function (a, b) {
	var c = [b[a.v0], b[a.v1], b[a.v2]],
	d = null;
	if (void 0 !== a.m)
		for (var d = [], e = 0; e < a.m.length; ++e)
			d.push(skim.Material.buildFromJSON(a.m[e]));
	c = new skim.engine.TriangleDef(c, d, a.vt);
	void 0 !== a.n && c.setName(a.n.slice(0, a.n.length));
	c.commit();
	return c
};
skim.engine.TriangleDef.JSONKey = "triangles";
skim.utils.assert(void 0 === skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.TriangleDef.JSONKey], "Error : token" + skim.engine.TriangleDef.JSONKey + " already register (by another primitive?)");
skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.TriangleDef.JSONKey] = skim.engine.TriangleDef.buildFromJSON;
skim.engine.TriangleDef.prototype.getJSONKey = function () {
	return skim.engine.TriangleDef.JSONKey
};
skim.engine.TriangleDef.prototype.getJSON = function (a, b, c) {
	a = {
		v0 : b[this.v[0].id],
		v1 : b[this.v[1].id],
		v2 : b[this.v[2].id],
		vt : this.getVolType()
	};
	if (null !== this.materials)
		for (a.m = [], b = 0; b < this.materials.length; ++b)
			a.m.push(this.materials[b].getJSON());
	null !== this.name && (a.n = this.name.slice(0, this.name.length));
	return a
};
skim.engine.HeightMapRingDef = function (a, b, c, d, e, f, g, h, k) {
	skim.engine.PrimitiveDef.call(this, [], null, skim.VolType.Mech);
	this.rlength = a;
	this.zlength = b;
	this.round = c;
	this.bump = d;
	this.radius = e;
	this.lambda = f;
	this.uniform_zlength = g;
	this.image = h;
	this.color_image_data = k
};
skim.engine.HeightMapRingDef.prototype = Object.create(skim.engine.PrimitiveDef.prototype);
skim.engine.HeightMapRingDef.prototype.constructor = skim.engine.HeightMapRingDef;
skim.engine.HeightMapRingDef.prototype.isParametric = function () {
	return !0
};
skim.engine.HeightMapRingDef.prototype.isImplicit = function () {
	return !1
};
skim.engine.HeightMapRingDef.prototype.getRLength = function () {
	return this.rlength
};
skim.engine.HeightMapRingDef.prototype.getZLength = function () {
	return this.zlength
};
skim.engine.HeightMapRingDef.prototype.getRound = function () {
	return this.round
};
skim.engine.HeightMapRingDef.prototype.getBump = function () {
	return this.bump
};
skim.engine.HeightMapRingDef.prototype.getRadius = function () {
	return this.radius
};
skim.engine.HeightMapRingDef.prototype.getLambda = function () {
	return this.lambda
};
skim.engine.HeightMapRingDef.prototype.isUniformZLength = function () {
	return this.uniform_zlength
};
skim.engine.HeightMapRingDef.prototype.getImage = function () {
	return this.image
};
skim.engine.HeightMapRingDef.prototype.getColorImageData = function () {
	return this.color_image_data
};
skim.engine.HeightMapRingDef.prototype.updateReactor = function () {
	this.hasReactor() && this.destroyReactor();
	this.createReactor()
};
skim.engine.HeightMapRingDef.prototype.createReactor = function () {
	this.reactor = new skim.skel.HeightMapRingReactor({
			id : this.id,
			rlength : this.rlength,
			zlength : this.zlength,
			round : this.round,
			bump : this.bump,
			radius : this.radius,
			lambda : this.lambda,
			uniform_zlength : this.uniform_zlength,
			image : this.image,
			color_image_data : this.color_image_data,
			volType : this.getVolType()
		})
};
skim.engine.HeightMapRingDef.prototype.canLiveWithout = function (a) {
	return !0
};
skim.engine.HeightMapRingDef.buildFromJSON = function (a, b) {
	skim.utils.assert(!1, "TODO : impossible to load a HeightMapRing from JSON, functin not implemented")
};
skim.engine.HeightMapRingDef.JSONKey = "hmring";
skim.utils.assert(void 0 === skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.HeightMapRingDef.JSONKey], "Error : token" + skim.engine.HeightMapRingDef.JSONKey + " already register (by another primitive?)");
skim.engine.PrimitiveDef.RegisterJSONKey[skim.engine.HeightMapRingDef.JSONKey] = skim.engine.RingDef.buildFromJSON;
skim.engine.HeightMapRingDef.prototype.getJSON = function (a, b, c) {
	skim.utils.assert(!1, "TODO : change img parameter to be an imagedata to store it");
	a = {};
	null !== this.name && (a.n = this.name.slice(0, this.name.length));
	return a
};
skim.Convergence = {};
skim.Convergence.last_mov_pt = new THREE.Vector3;
skim.Convergence.grad = new THREE.Vector3;
skim.Convergence.eval_res = {
	v : 0,
	g : new THREE.Vector3(0, 0, 0)
};
skim.Convergence.vec = new THREE.Vector3;
skim.Convergence.safeNewton3D = function (a, b, c, d, e, f, g) {
	g.copy(b);
	for (var h = 1, k = 0, l = !1; 2 != k && h <= e && !l; ) {
		this.last_mov_pt.copy(g);
		a.value(g, skim.blobtree.EvalTags.ValueGrad, this.eval_res);
		this.grad.copy(this.eval_res.g);
		if (0 !== this.grad.x || 0 !== this.grad.y || 0 !== this.grad.z) {
			var m = this.grad.lengthSq(),
			n = (c - this.eval_res.v) / m;
			n < d && n > -d ? (n = 0 < n ? d / Math.sqrt(m) : -d / Math.sqrt(m), k++) : k = 0;
			this.grad.multiplyScalar(n);
			g.add(this.grad);
			if (this.vec.subVectors(g, b).lengthSq() > f * f) {
				g.copy(b);
				return
			}
		} else
			l = !0;
		++h
	}
	l &&
	g.copy(b)
};
skim.Convergence.safeNewton1D = function (a, b, c, d, e, f, g, h, k, l) {
	skim.utils.assert(0 !== c.x || 0 !== c.y || 0 !== c.z, "Error : search direction is null");
	skim.utils.assert(0 < h, "Error: epsilon <= 0, convergence will nuke your face or loop");
	skim.utils.assert(f >= d && f <= e, "Error : starting absc is not in boundaries");
	for (var m = new THREE.Vector3, n = 0, p = n = 0; e - d > h && p < k; ) {
		a.value(m.copy(c).multiplyScalar(f).add(b), skim.blobtree.EvalTags.ValueGrad, this.eval_res);
		this.eval_res.v > g ? d = f : e = f;
		n = this.eval_res.g.dot(c);
		if (0 !==
			n) {
			if (n = (g - this.eval_res.v) / n, f += n, f >= e || f <= d)
				f = 0.5 * (e + d)
		} else
			f = 0.5 * (e + d);
		++p
	}
	l.p_absc = 0.5 * (e + d);
	l.p.copy(c).multiplyScalar(f).add(b);
	void 0 !== l.g && (0 === p && a.value(l.p, skim.blobtree.EvalTags.ValueGrad, this.eval_res), l.g.copy(this.eval_res.g))
};
skim.Convergence.dichotomie1D = function (a, b, c, d, e, f, g, h) {
	var k = (new THREE.Vector3).copy(b),
	l = new THREE.Vector3;
	d /= 2;
	var m = -d,
	n = m;
	b.sub(l.copy(c).multiplyScalar(d));
	for (var p = 0; d > f && p < g; )
		p++, k.copy(b), n = m, d /= 2, a.value(b, skim.blobtree.EvalTags.Value, this.eval_res), this.eval_res.v < e ? (b.add(l.copy(c).multiplyScalar(d)), m += d) : (b.sub(l.copy(c).multiplyScalar(d)), m -= d);
	h.p.copy(b.add(k).divideScalar(2));
	h.p_absc = (n + m) / 2;
	h.p.copy(b);
	h.p_absc = m;
	h.g && (a.value(h.p, skim.blobtree.EvalTags.Grad, this.eval_res), h.g.copy(this.eval_res.g))
};
skim.utils.createDataTexture = function (a, b, c) {
	return new THREE.DataTexture(a, b, b, THREE.RGBAFormat, THREE.FloatType, new THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter, 0)
};
skim.utils.statesToGlsl = function (a) {
	for (var b = "", c = a.length, d = 0; d < c; d++)
		b += "#define " + a[d] + " " + (d / c).toFixed(15) + "\n";
	return b += "#define EPSILON_STATE " + (1 / (c + 1)).toFixed(15) + "\n"
};
THREE.Face3.prototype.set = function (a, b, c) {
	this.a = a;
	this.b = b;
	this.c = c
};
THREE.ShaderMaterial.prototype.updateMultiresolutionSize = function (a, b) {
	this.attributes.multiresSize.value[0].set(-a, b);
	this.attributes.multiresSize.value[1].set(a, b);
	this.attributes.multiresSize.value[2].set(-a, -b);
	this.attributes.multiresSize.value[3].set(a, -b);
	this.attributes.multiresSize.needsUpdate = !0
};
THREE.ShaderMaterial.prototype.setTexture = function (a) {
	var b = this.uniforms.uTexture;
	b && (b.value = a, b.needsUpdate = !0)
};
THREE.ShaderMaterial.prototype.setColor = function (a) {
	var b = this.uniforms.uColor;
	b && b.value.setHex(a)
};
var BasicMaterial = function (a, b) {
	b = b || {};
	b.color = b.color || 65535;
	this.color = new THREE.Color(b.color);
	this.computeFragmentShader = function (b) {
		return "#define " + b + "\n" + a.basic.frag
	};
	var c = {
		uColor : {
			type : "c",
			value : this.color
		},
		uMaxDistance : {
			type : "f",
			value : 0
		},
		uMultiresScale : {
			type : "v2",
			value : new THREE.Vector2(1, 1)
		}
	};
	THREE.ShaderMaterial.call(this, {
		uniforms : c,
		vertexShader : a.basic.vert,
		fragmentShader : this.computeFragmentShader(b.renderOutput),
		side : THREE.DoubleSide,
		depthTest : !1,
		writeDepth : !1
	})
};
BasicMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
BasicMaterial.prototype.changeRenderOutput = function (a) {
	this.fragmentShader = this.computeFragmentShader(a);
	this.needsUpdate = !0
};
var PointCloudMaterial = function (a, b) {
	var c = {
		uSize : {
			type : "f",
			value : b.size
		},
		uTexture : {
			type : "t",
			value : b.texture
		},
		uColor : {
			type : "c",
			value : new THREE.Color(b.color || 0)
		},
		uScale : {
			type : "f",
			value : 40
		}
	};
	THREE.ShaderMaterial.call(this, {
		uniforms : c,
		attributes : {
			gradient : {
				type : "v3",
				value : b.gradients
			}
		},
		vertexShader : a.pointCloud.vert,
		fragmentShader : a.pointCloud.frag
	})
};
PointCloudMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
PointCloudMaterial.prototype.setSize = function (a) {
	this.uniforms.uSize.value = a
};
var EnvironmentMapMaterial = function (a, b, c) {
	c = c || {};
	c.color = c.color || 10066329;
	var d = c.mergeColorWith ? "#define MERGE_WITH_" + c.mergeColorWith + "_COLOR\n" : "";
	this.color = new THREE.Color(c.color);
	THREE.ShaderMaterial.call(this, {
		uniforms : {
			uTexture : {
				type : "t",
				value : b
			},
			uColor : {
				type : "c",
				value : this.color
			}
		},
		vertexShader : a.envMap.vert,
		fragmentShader : d + a.envMap.frag,
		vertexColors : THREE.FaceColors
	})
};
EnvironmentMapMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
var EnvironmentMapDarkenMaterial = function (a, b) {
	THREE.ShaderMaterial.call(this, {
		uniforms : {
			uTexture : {
				type : "t",
				value : b
			}
		},
		vertexShader : a.envMap.vert,
		fragmentShader : a.envMapDarken.frag,
		vertexColors : THREE.FaceColors
	})
};
EnvironmentMapDarkenMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
var SaveEnvMapNormalsMaterial = function () {
	skim.utils.assert(void 0 !== skim.shaders.envMap && void 0 !== skim.shaders.envMap.vert && void 0 !== skim.shaders.saveEnvMapNormals && void 0 !== skim.shaders.saveEnvMapNormals.frag, "Error : shaders skim.shaders.envMap.vert and skim.shaders.saveEnvMapNormals.frag must be loaded");
	THREE.ShaderMaterial.call(this, {
		uniforms : {},
		vertexShader : skim.shaders.envMap.vert,
		fragmentShader : skim.shaders.saveEnvMapNormals.frag,
		vertexColors : THREE.FaceColors
	})
};
SaveEnvMapNormalsMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
var CopyMaterial = function (a, b) {
	this.computeFragmentShader = function (b) {
		return "#define UTEXTURE uTexture" + b + "\n" + a.copy.frag
	};
	THREE.ShaderMaterial.call(this, {
		uniforms : {
			uTexture1 : {
				type : "t",
				value : b.texture1
			},
			uTexture2 : {
				type : "t",
				value : b.texture2
			}
		},
		attributes : {
			multiresSize : {
				type : "v2",
				value : [new THREE.Vector2(-1, 1), new THREE.Vector2(1, 1), new THREE.Vector2(-1, -1), new THREE.Vector2(1, -1)]
			}
		},
		vertexShader : a.postprocess.vert,
		fragmentShader : this.computeFragmentShader(1),
		depthTest : !1,
		depthWrite : !1
	})
};
CopyMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
CopyMaterial.prototype.setTexture = function (a) {
	this.fragmentShader = this.computeFragmentShader(a);
	this.needsUpdate = !0
};
var ClearMaterial = function (a, b) {
	var c = {
		uColor : {
			type : "c",
			value : new THREE.Color(b.color)
		},
		uAlpha : {
			type : "f",
			value : b.alpha
		}
	};
	THREE.ShaderMaterial.call(this, {
		uniforms : c,
		attributes : {
			multiresSize : {
				type : "v2",
				value : [new THREE.Vector2(-1, 1), new THREE.Vector2(1, 1), new THREE.Vector2(-1, -1), new THREE.Vector2(1, -1)]
			}
		},
		vertexShader : a.postprocess.vert,
		fragmentShader : a.clear.frag,
		depthTest : !1,
		depthWrite : !1
	})
};
ClearMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
var BackgroundMaterial = function (a, b, c) {
	return new THREE.ShaderMaterial({
		uniforms : {
			backgroundColor : {
				type : "c",
				value : c.colorBack
			},
			pointLightColor : {
				type : "c",
				value : c.colorPoint
			},
			pointLightPosition : {
				type : "v2",
				value : c.pointPos
			},
			uA : {
				type : "f",
				value : c.a
			}
		},
		vertexShader : a,
		fragmentShader : b,
		depthTest : !1,
		depthWrite : !1
	})
};
var SkelRaytracerMaterial = function (a, b) {
	this.computeFragmentShader = function () {
		return "#define MY_TEXTURE_SIZE " + this.textureSize + "\n#define INV_MY_TEXTURE_SIZE_MINUS_ONE " + (1 / (this.textureSize - 1)).toFixed(5) + "\n#define NUMBER_OF_SPHERES " + this.numberOfSpheres + "\n#define NUMBER_OF_CYLINDERS " + this.numberOfCylinders + "\n#define NUMBER_OF_CONES " + this.numberOfCones + "\n#define " + this.renderOutput + "\n" + skim.utils.statesToGlsl(this.states) + a.raytracer.frag
	};
	this.states = b.states;
	this.renderOutput = b.defaultRenderOutput;
	this.numberOfCones = this.numberOfCylinders = this.numberOfSpheres = 0;
	this.textureSize = 64;
	var c = new Float32Array(4 * this.textureSize * this.textureSize),
	d = new Float32Array(4 * this.textureSize * this.textureSize),
	e = new Float32Array(4 * this.textureSize * this.textureSize),
	c = {
		uEyePos : {
			type : "v3",
			value : new THREE.Vector3
		},
		uViewProjectionInverse : {
			type : "m4",
			value : new THREE.Matrix4
		},
		uNormalMatrix : {
			type : "m4",
			value : new THREE.Matrix4
		},
		uSphereTex : {
			type : "t",
			value : skim.utils.createDataTexture(c, this.textureSize)
		},
		uConeTex : {
			type : "t",
			value : skim.utils.createDataTexture(d, this.textureSize)
		},
		uCylinderTex : {
			type : "t",
			value : skim.utils.createDataTexture(e, this.textureSize)
		},
		uBackgroundRTT : {
			type : "t",
			value : b.backgroundRTT
		},
		uVerticesTexture : {
			type : "t",
			value : b.verticesTexture
		},
		uPrimitivesTexture : {
			type : "t",
			value : b.primitivesTexture
		},
		uStencilTexture : {
			type : "t",
			value : b.stencilTexture
		},
		uMaxDistance : {
			type : "f",
			value : 0
		}
	};
	THREE.ShaderMaterial.call(this, {
		uniforms : c,
		attributes : {
			sceneTilePosition : {
				type : "v2",
				value : [new THREE.Vector2(-1, 1), new THREE.Vector2(1,
						1), new THREE.Vector2(-1, -1), new THREE.Vector2(1, -1)]
			},
			multiresSize : {
				type : "v2",
				value : [new THREE.Vector2(-1, 1), new THREE.Vector2(1, 1), new THREE.Vector2(-1, -1), new THREE.Vector2(1, -1)]
			}
		},
		vertexShader : a.raytracer.vert,
		fragmentShader : this.computeFragmentShader(),
		depthTest : !1,
		depthWrite : !1
	})
};
SkelRaytracerMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
SkelRaytracerMaterial.prototype.changeRenderOutput = function (a) {
	this.renderOutput = a;
	this.fragmentShader = this.computeFragmentShader();
	this.needsUpdate = !0
};
SkelRaytracerMaterial.prototype.update = function (a) {
	this.uniforms.uEyePos.value.copy(a.eyePos);
	this.uniforms.uViewProjectionInverse.value.copy(a.viewProjectionInverse).transpose();
	this.uniforms.uNormalMatrix.value.set(a.normalMatrix.elements[0], a.normalMatrix.elements[1], a.normalMatrix.elements[2], 0, a.normalMatrix.elements[3], a.normalMatrix.elements[4], a.normalMatrix.elements[5], 0, a.normalMatrix.elements[6], a.normalMatrix.elements[7], a.normalMatrix.elements[8], 0, 0, 0, 0, 0);
	this.uniforms.uMaxDistance.value =
		a.maxDistance;
	var b = this.uniforms.uSphereTex;
	b.needsUpdate = !0;
	b.value.needsUpdate = !0;
	var c = this.uniforms.uConeTex;
	c.needsUpdate = !0;
	c.value.needsUpdate = !0;
	var d = this.uniforms.uCylinderTex;
	d.needsUpdate = !0;
	d.value.needsUpdate = !0;
	for (var e = 0; e < a.spheres.length; e++)
		b.value.image.data[4 * e] = a.spheres[e].x, b.value.image.data[4 * e + 1] = a.spheres[e].y, b.value.image.data[4 * e + 2] = a.spheres[e].z, b.value.image.data[4 * e + 3] = a.spheres[e].w * a.scaleSizeFactor;
	for (b = 0; b < a.cones.length; b++)
		c.value.image.data[12 * b] = a.cones[b].v.x,
		c.value.image.data[12 * b + 1] = a.cones[b].v.y, c.value.image.data[12 * b + 2] = a.cones[b].v.z, c.value.image.data[12 * b + 3] = a.cones[b].inf, c.value.image.data[12 * b + 4] = a.cones[b].axis.x, c.value.image.data[12 * b + 5] = a.cones[b].axis.y, c.value.image.data[12 * b + 6] = a.cones[b].axis.z, c.value.image.data[12 * b + 7] = a.cones[b].sup, c.value.image.data[12 * b + 8] = ConeAB.scaleConeThickness(a.cones[b].ctheta, a.scaleSizeFactor);
	for (c = 0; c < a.cylinders.length; c++)
		d.value.image.data[8 * c] = a.cylinders[c].v.x, d.value.image.data[8 * c + 1] = a.cylinders[c].v.y,
		d.value.image.data[8 * c + 2] = a.cylinders[c].v.z, d.value.image.data[8 * c + 3] = a.cylinders[c].radius * a.scaleSizeFactor, d.value.image.data[8 * c + 4] = a.cylinders[c].axis.x, d.value.image.data[8 * c + 5] = a.cylinders[c].axis.y, d.value.image.data[8 * c + 6] = a.cylinders[c].axis.z, d.value.image.data[8 * c + 7] = a.cylinders[c].sup;
	if (this.numberOfSpheres != a.spheres.length || this.numberOfCylinders != a.cylinders.length || this.numberOfCones != a.cones.length)
		this.numberOfSpheres = a.spheres.length, this.numberOfCones = a.cones.length, this.numberOfCylinders =
			a.cylinders.length, this.fragmentShader = this.computeFragmentShader(), this.needsUpdate = !0
};
var PostProcessMaterial = function (a, b) {
	this.screen_width = b.width;
	this.screen_height = b.height;
	this.inverseTexSizeMultiRes = new THREE.Vector2(1 / b.width, 1 / b.height);
	THREE.ShaderMaterial.call(this, {
		uniforms : {
			uTexture : {
				type : "t",
				value : b.texture
			},
			uTexCoordOffset : {
				type : "v2",
				value : this.inverseTexSizeMultiRes
			}
		},
		attributes : {
			multiresSize : {
				type : "v2",
				value : [new THREE.Vector2(-1, 1), new THREE.Vector2(1, 1), new THREE.Vector2(-1, -1), new THREE.Vector2(1, -1)]
			}
		},
		vertexShader : a.postprocess.vert,
		fragmentShader : a.postprocess.frag,
		depthTest : !1
	})
};
PostProcessMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
var EvaluationMaterial = function (a, b) {
	this.computeFragmentShader = function () {
		return "#define MY_TEXTURE_SIZE " + this.textureSize + "\n#define INV_MY_TEXTURE_SIZE_MINUS_ONE " + (1 / (this.textureSize - 1)).toFixed(15) + "\n#define NUMBER_OF_SPHERES " + this.numberOfSpheres + "\n#define NUMBER_OF_SEGMENT_MECH " + this.numberOfSegmentMech + "\n#define NUMBER_OF_SEGMENT_ORGA " + this.numberOfSegmentOrga + "\n#define KS " + skim.blobtree.KS.toFixed(15) + "\n#define KS2 " + skim.blobtree.KS2.toFixed(15) + "\n#define KIS2 " + skim.blobtree.KIS2.toFixed(15) +
		"\n#define Poly6NF1D " + skim.blobtree.Poly6NF1D.toFixed(15) + "\n#define Poly6NF0D " + skim.blobtree.Poly6NF0D.toFixed(15) + "\n#define KIS2 " + skim.blobtree.KIS2.toFixed(15) + "\n#define DIFF_ON_" + this.valueToDebug + "\n#define MAX_MARCHING_STEP " + this.maxNumberOfStep + "\n#define LENGTH_MARCHING_STEP_MIN 0.1\n#define LENGTH_MARCHING_STEP_MAX 1.\n" + skim.utils.statesToGlsl(this.states) + "#define ENV_MAP\n" + a["surfRaytracer" + b.action].frag
	};
	this.states = b.states;
	this.maxNumberOfStep = b.maxNumberOfStep;
	this.valueToDebug =
		b.valueToDebug;
	this.isDebugEval = "Debug" === b.action;
	this.numberOfSegmentOrga = this.numberOfSegmentMech = this.numberOfSpheres = 0;
	this.textureSize = b.textureSize;
	var c = new Float32Array(4 * this.textureSize * this.textureSize),
	d = new Float32Array(4 * this.textureSize * this.textureSize),
	e = new Float32Array(4 * this.textureSize * this.textureSize);
	this.screen_width = b.screen_width;
	this.screen_height = b.screen_height;
	c = {
		uEyePos : {
			type : "v3",
			value : new THREE.Vector3
		},
		uViewProjectionInverse : {
			type : "m4",
			value : new THREE.Matrix4
		},
		uSphereTex : {
			type : "t",
			value : skim.utils.createDataTexture(c, this.textureSize)
		},
		uSegmentMechTex : {
			type : "t",
			value : skim.utils.createDataTexture(d, this.textureSize)
		},
		uSegmentOrgaTex : {
			type : "t",
			value : skim.utils.createDataTexture(e, this.textureSize)
		},
		uMaxDistance : {
			type : "f",
			value : 0
		},
		uBlobtreeRicci_n : {
			type : "f",
			value : 1
		},
		uDepthTexture : {
			type : "t",
			value : b.depthTexture
		},
		uBackgroundRTT : {
			type : "t",
			value : b.backgroundRTT
		},
		uTextureSize : {
			type : "f",
			value : this.textureSize
		}
	};
	"Render" == b.action && (c.uNormalMatrix = {
			type : "m4",
			value : new THREE.Matrix4
		},
		c.uTexture = {
			type : "t",
			value : b.texture
		}, c.uColor = {
			type : "c",
			value : new THREE.Color(8421504)
		});
	this.isDebugEval && (d = new Float32Array(4 * this.textureSize * this.textureSize), e = new Float32Array(4 * this.textureSize * this.textureSize), c.uDebugTex = {
			type : "t",
			value : skim.utils.createDataTexture(d, this.textureSize)
		}, c.uDebugPointToEvalTex = {
			type : "t",
			value : skim.utils.createDataTexture(e, this.textureSize)
		});
	THREE.ShaderMaterial.call(this, {
		uniforms : c,
		attributes : {
			sceneTilePosition : {
				type : "v2",
				value : [new THREE.Vector2(-1,
						1), new THREE.Vector2(1, 1), new THREE.Vector2(-1, -1), new THREE.Vector2(1, -1)]
			},
			multiresSize : {
				type : "v2",
				value : [new THREE.Vector2(-1, 1), new THREE.Vector2(1, 1), new THREE.Vector2(-1, -1), new THREE.Vector2(1, -1)]
			}
		},
		vertexShader : a.raytracer.vert,
		fragmentShader : this.computeFragmentShader(),
		depthTest : !1,
		depthWrite : !1
	})
};
EvaluationMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
EvaluationMaterial.prototype.update = function (a) {
	a.normalMatrix && this.uniforms.uNormalMatrix.value.set(a.normalMatrix.elements[0], a.normalMatrix.elements[1], a.normalMatrix.elements[2], 0, a.normalMatrix.elements[3], a.normalMatrix.elements[4], a.normalMatrix.elements[5], 0, a.normalMatrix.elements[6], a.normalMatrix.elements[7], a.normalMatrix.elements[8], 0, 0, 0, 0, 0);
	this.uniforms.uEyePos.value.copy(a.eyePos);
	this.uniforms.uViewProjectionInverse.value.copy(a.viewProjectionInverse).transpose();
	this.uniforms.uMaxDistance.value =
		a.maxDistance
};
EvaluationMaterial.prototype.updateScene = function (a) {
	var b = this.uniforms.uSphereTex;
	b.needsUpdate = !0;
	b.value.needsUpdate = !0;
	var c = this.uniforms.uSegmentMechTex;
	c.needsUpdate = !0;
	c.value.needsUpdate = !0;
	var d = this.uniforms.uSegmentOrgaTex;
	d.needsUpdate = !0;
	d.value.needsUpdate = !0;
	for (var e = 0, f = 0, g = 0, h = a.children, k = 0; k < h.length; k++)
		if (h[k].type === skim.blobtree.typePoint) {
			var l = h[k],
			m = l.v[0],
			n = m.getPos();
			b.value.image.data[8 * e] = n.x;
			b.value.image.data[8 * e + 1] = n.y;
			b.value.image.data[8 * e + 2] = n.z;
			b.value.image.data[8 *
				e + 3] = m.getThickness();
			b.value.image.data[8 * e + 4] = l.getDensity();
			b.value.image.data[8 * e + 5] = 0;
			b.value.image.data[8 * e + 6] = 0;
			b.value.image.data[8 * e + 7] = 0;
			e++
		} else if (h[k].type === skim.blobtree.typeSegment) {
			var l = h[k],
			m = l.v0_p,
			n = l.dir,
			p = l.unit_dir,
			q = l.p_min,
			r = l.increase_unit_dir,
			t,
			s;
			l.volType == skim.VolType.Mech ? (t = c, s = f, f++) : l.volType == skim.VolType.Orga && (t = d, s = g, g++);
			t.value.image.data[28 * s] = m.x;
			t.value.image.data[28 * s + 1] = m.y;
			t.value.image.data[28 * s + 2] = m.z;
			t.value.image.data[28 * s + 3] = l.getDensity();
			t.value.image.data[28 *
				s + 4] = n.x;
			t.value.image.data[28 * s + 5] = n.y;
			t.value.image.data[28 * s + 6] = n.z;
			t.value.image.data[28 * s + 7] = l.length;
			t.value.image.data[28 * s + 8] = p.x;
			t.value.image.data[28 * s + 9] = p.y;
			t.value.image.data[28 * s + 10] = p.z;
			t.value.image.data[28 * s + 11] = l.c0;
			t.value.image.data[28 * s + 12] = r.x;
			t.value.image.data[28 * s + 13] = r.y;
			t.value.image.data[28 * s + 14] = r.z;
			t.value.image.data[28 * s + 15] = l.c1;
			t.value.image.data[28 * s + 16] = l.maxboundSq;
			t.value.image.data[28 * s + 17] = l.cyl_bd0;
			t.value.image.data[28 * s + 18] = l.cyl_bd1;
			t.value.image.data[28 *
				s + 19] = l.weight_min;
			t.value.image.data[28 * s + 20] = l.unit_delta_weight;
			t.value.image.data[28 * s + 21] = l.inv_weight_min;
			t.value.image.data[28 * s + 22] = 0;
			t.value.image.data[28 * s + 23] = 0;
			t.value.image.data[28 * s + 24] = q.x;
			t.value.image.data[28 * s + 25] = q.y;
			t.value.image.data[28 * s + 26] = q.z;
			t.value.image.data[28 * s + 27] = l.lengthSq
		}
	this.uniforms.uBlobtreeRicci_n.value = a.ricci_n;
	if (this.numberOfSpheres != e || this.numberOfSegmentOrga != g || this.numberOfSegmentMech != f)
		this.numberOfSpheres = e, this.numberOfSegmentOrga = g, this.numberOfSegmentMech =
			f, this.fragmentShader = this.computeFragmentShader(), this.needsUpdate = !0, a = this.textureSize * this.textureSize, skim.utils.assert(2 * this.numberOfSpheres < a, "Raytracer: too many spheres primitives, requires bigger texture"), skim.utils.assert(7 * this.numberOfSegmentMech < a, "Raytracer: too many segment mecha primitives, requires bigger texture"), skim.utils.assert(7 * this.numberOfSegmentOrga < a, "Raytracer: too many segment orga primitives, requires bigger texture")
};
EvaluationMaterial.prototype.setEvaluationParameters = function (a, b, c) {
	var d = this.uniforms.uDebugTex;
	d.needsUpdate = !0;
	d.value.needsUpdate = !0;
	var e = this.uniforms.uDebugPointToEvalTex;
	e.needsUpdate = !0;
	e.value.needsUpdate = !0;
	var f = new THREE.Vector3,
	g = {};
	g.g = new THREE.Vector3;
	for (var h = 0; h < this.textureSize; h++)
		for (var k = 0; k < this.textureSize; k++) {
			f.set((h / (this.textureSize - 1) - 0.5) * c, (k / (this.textureSize - 1) - 0.5) * c, b);
			a.value(f, skim.blobtree.EvalTags.Value | skim.blobtree.EvalTags.Grad, g);
			var l = this.textureSize -
				1 - k;
			d.value.image.data[4 * (h + l * this.textureSize) + 3] = g.v;
			e.value.image.data[4 * (h + l * this.textureSize)] = f.x;
			e.value.image.data[4 * (h + l * this.textureSize) + 1] = f.y;
			e.value.image.data[4 * (h + l * this.textureSize) + 2] = f.z;
			e.value.image.data[4 * (h + l * this.textureSize) + 3] = 0
		}
};
void 0 !== THREE.ShaderLib.varying_phong ? console.error("Error : varying_phong is already defined in THREE.JS !!!") : THREE.ShaderLib.varying_phong = {
	uniforms : THREE.UniformsUtils.merge([function () {
				var a = THREE.UniformsUtils.clone(THREE.UniformsLib.common);
				delete a.reflectivity;
				return a
			}
			(), THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
				ambient : {
					type : "c",
					value : new THREE.Color(16777215)
				},
				emissive : {
					type : "c",
					value : new THREE.Color(0)
				},
				specular : {
					type : "c",
					value : new THREE.Color(1118481)
				},
				wrapRGB : {
					type : "v3",
					value : new THREE.Vector3(1, 1, 1)
				}
			}
		]),
	vertexShader : ["attribute float shininess;\nattribute float reflectivity;\n#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex,
		THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "varying float vShininess;\nvarying float vReflectivity;\nvoid main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, "vShininess = shininess;\nvReflectivity = reflectivity;", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\tvNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex,
		THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "\tvViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
	fragmentShader : ["#define PHONG\nuniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nvarying float vShininess;\nvarying float vReflectivity;",
		THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment.replace("uniform float reflectivity;", ""), THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment,
		"void main() {\n   float shininess = vShininess;\n   float reflectivity = vReflectivity;\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment,
		THREE.ShaderChunk.fog_fragment, "}"].join("\n")
};
skim.SceneManager = function () {
	var a = this;
	this.scene = new THREE.Scene;
	this.surface_to_show = this.render_required = !1;
	this.surface_material = skim.gl_materials["Physical Material"].get(function (b) {
			a.render_required = !0
		});
	this.wireframe_material = skim.gl_materials["Physical Wireframe"].get(function (b) {
			a.render_required = !0
		});
	this.neutralMeshes = {};
	this.neutralObjects = {};
	this.pedestal = new skim.utils.Pedestal({});
	this.symplane_x = new skim.utils.Symplane({
			ortho_axis : "x"
		});
	this.symplane_y = new skim.utils.Symplane({
			ortho_axis : "y"
		});
	this.symplane_z = new skim.utils.Symplane({
			ortho_axis : "z"
		});
	this.helperBoundingBox = new skim.utils.HelperBoundingBox;
	this.symplane_z_to_show = this.symplane_y_to_show = this.symplane_x_to_show = this.helperBoundingBox_to_show = this.pedestal_to_show = !1;
	this.dirLight = new THREE.DirectionalLight(16777215);
	this.dirLight.position.set(200, 200, 1E3).normalize();
	this.cameraMans = {};
	this.addMesh(this.pedestal);
	this.addMesh(this.symplane_x);
	this.addMesh(this.symplane_y);
	this.addMesh(this.symplane_z);
	this.addMesh(this.helperBoundingBox);
	this.isWireframe = !1;
	this.screenshot_push = null;
	this.surface_meshes = {}

};
skim.SceneManager.prototype.constructor = skim.SceneManager;
skim.SceneManager.prototype.getScene = function () {
	return this.scene
};
skim.SceneManager.prototype.addCameraMan = function (a) {
	this.scene.add(a.rotNode);
	a.attachLightToCamera(this.dirLight, this.dirLight.target);
	this.cameraMans[a.getName()] = a
};
skim.SceneManager.prototype.removeCameraMan = function (a) {
	this.scene.remove(a.rotNode);
	a.removeLightFromCamera(this.dirLight, this.dirLight.target);
	delete this.cameraMans[a.getName()]
};
skim.SceneManager.prototype.getSurfaceMaterial = function () {
	return this.surface_material
};
skim.SceneManager.prototype.setSurfaceMaterial = function (a) {
	this.surface_material = a;
	this.render_required = !0;
	this.updateMaterial()
};
skim.SceneManager.prototype.setVisible = function (a, b) {
	a.visible = b;
	this.render_required = !0
};
skim.SceneManager.prototype.toggleVisible = function (a) {
	this.setVisible(a, !a.visible)
};
skim.SceneManager.prototype.addMesh = function (a) {
	this.scene.add(a);
	this.render_required = !0
};
skim.SceneManager.prototype.removeMesh = function (a) {
	this.scene.remove(a);
	this.render_required = !0
};
skim.SceneManager.prototype.addNeutralMesh = function (a, b) {
	void 0 === this.neutralMeshes[a] ? (this.neutralMeshes[a] = b, this.scene.add(b), this.render_required = !0) : skim.utils.assert(!1, "Error : trying to add a neutral mesh with an already existing name, nothing done.")
};
skim.SceneManager.prototype.removeNeutralMesh = function (a) {
	skim.utils.assert(void 0 !== this.neutralMeshes[a], "WARNING : trying to remove an unexisting neutral mesh");
	this.scene.remove(this.neutralMeshes[a]);
	delete this.neutralMeshes[a];
	this.render_required = !0
};
skim.SceneManager.prototype.getNeutralMesh = function (a) {
	return this.neutralMeshes[a]
};
skim.SceneManager.prototype.setNeutralMeshPosition = function (a, b) {
	var c = this.getNeutralMesh(a);
	c.position.x = b.x;
	c.position.y = b.y;
	c.position.z = b.z;
	this.render_required = !0
};
skim.SceneManager.prototype.rotateNeutralMesh = function (a, b, c) {
	this.getNeutralMesh(a).rotateOnAxis(b, c);
	this.render_required = !0
};
skim.SceneManager.prototype.setNeutralMeshScale = function (a, b) {
	var c = this.getNeutralMesh(a);
	c.scale.x = b.x;
	c.scale.y = b.y;
	c.scale.z = b.z;
	this.render_required = !0
};
skim.SceneManager.prototype.setNeutralMeshMaterial = function (a, b) {
	this.getNeutralMesh(a).material = b;
	this.render_required = !0
};
skim.SceneManager.prototype.setNeutralMeshVisible = function (a, b) {
	this.getNeutralMesh(a).visible = b;
	this.render_required = !0
};
skim.SceneManager.prototype.neutralMeshUpdated = function (a) {
	this.render_required = !0
};
skim.SceneManager.prototype.addNeutralObject = function (a, b) {
	void 0 === this.neutralObjects[a] ? (this.neutralObjects[a] = b, this.scene.add(b), this.render_required = !0) : skim.utils.assert(!1, "Error : trying to add a neutral object with an already existing name, nothing done.")
};
skim.SceneManager.prototype.removeNeutralObject = function (a) {
	skim.utils.assert(void 0 !== this.neutralObjects[a], "WARNING : trying to remove an unexisting neutral mesh");
	this.scene.remove(this.neutralObjects[a]);
	delete this.neutralObjects[a];
	this.render_required = !0
};
skim.SceneManager.prototype.getNeutralObject = function (a) {
	return this.neutralObjects[a]
};
skim.SceneManager.prototype.getNeutralObjectsVisibility = function () {
	for (var a = {}, b = Object.keys(this.neutralObjects), c = 0; c < b.length; ++c)
		a[b[c]] = this.neutralObjects[b[c]].visible;
	return a
};
skim.SceneManager.prototype.getNeutralMeshesVisibility = function () {
	for (var a = {}, b = Object.keys(this.neutralMeshes), c = 0; c < b.length; ++c)
		a[b[c]] = this.neutralMeshes[b[c]].visible;
	return a
};
skim.SceneManager.prototype.neutralObjectUpdated = function (a) {
	this.render_required = !0
};
skim.SceneManager.prototype.showWidgets = function (a) {
	skim.instances.modeler.widgets3DManager.widgets.vertices_widget.set({
		visible : a
	});
	skim.instances.modeler.widgets3DManager.widgets.primitives_widget.set({
		visible : a
	});
	skim.instances.modeler.widgets3DManager.widgets.meshes_widget.set({
		visible : a
	})
};
skim.SceneManager.prototype.renderRequired = function () {
	return this.render_required
};
skim.SceneManager.prototype.renderDone = function () {
	this.render_required = !1
};
skim.SceneManager.prototype.toggleShowSurface = function () {
	this.setShowSurface(!this.surface_to_show)
};
skim.SceneManager.prototype.isSurfaceToShow = function () {
	return this.surface_to_show
};
skim.SceneManager.prototype.updateSceneElements = function () {
	var a = skim.instances.skel.getAABB();
	if (!a.isEmpty()) {
		this.symplane_x.update(a);
		this.symplane_y.update(a);
		this.symplane_z.update(a);
		this.pedestal.update(a);
		this.helperBoundingBox.update(a);
		this.render_required = !0;
		for (var b = Object.keys(this.neutralMeshes), c = 0; c < b.length; ++c) {
			var d = this.neutralMeshes[b[c]];
			d instanceof skim.utils.DynamicMesh && d.update(a)
		}
	}
};
skim.SceneManager.prototype.setSymPlaneXVisible = function (a) {
	this.symplane_x_to_show = a;
	this.setVisible(this.symplane_x, !this.isSurfaceShown() && a)
};
skim.SceneManager.prototype.setSymPlaneYVisible = function (a) {
	this.symplane_y_to_show = a;
	this.setVisible(this.symplane_y, !this.isSurfaceShown() && a)
};
skim.SceneManager.prototype.setSymPlaneZVisible = function (a) {
	this.symplane_z_to_show = a;
	this.setVisible(this.symplane_z, !this.isSurfaceShown() && a)
};
skim.SceneManager.prototype.setSymPlaneXColor = function (a) {
	this.symplane_x.setColor(a);
	this.render_required = !0
};
skim.SceneManager.prototype.setSymPlaneYColor = function (a) {
	this.symplane_y.setColor(a);
	this.render_required = !0
};
skim.SceneManager.prototype.setSymPlaneZColor = function (a) {
	this.symplane_z.setColor(a);
	this.render_required = !0
};
skim.SceneManager.prototype.setHelperBoundingBoxVisible = function (a) {
	this.helperBoundingBox_to_show = a;
	this.setVisible(this.helperBoundingBox, a)
};
skim.SceneManager.prototype.setPedestalVisible = function (a) {
	this.pedestal_to_show = a;
	this.setVisible(this.pedestal, a)
};
skim.SceneManager.prototype.toggleSymPlaneXVisible = function () {
	this.setSymPlaneXVisible(!this.symplane_x_to_show)
};
skim.SceneManager.prototype.toggleSymPlaneYVisible = function () {
	this.setSymPlaneYVisible(!this.symplane_y_to_show)
};
skim.SceneManager.prototype.toggleSymPlaneZVisible = function () {
	this.setSymPlaneZVisible(!this.symplane_z_to_show)
};
skim.SceneManager.prototype.registerSurfaceMesh = function (a) {
	skim.utils.assert(void 0 === this.surface_meshes[a], "Error : name already registered");
	this.surface_meshes[a] = null
};
skim.SceneManager.prototype.isRegisteredSurfaceMesh = function (a) {
	return void 0 !== this.surface_meshes[a]
};
skim.SceneManager.prototype.unregisterSurfaceMesh = function (a) {
	this.removeSurface(a);
	delete this.surface_meshes[a]
};
skim.SceneManager.prototype.isReady = function () {
	for (var a = Object.keys(this.surface_meshes), b = !0, c = 0; c < a.length; ++c)
		b = b && null !== this.surface_meshes[a[c]];
	return b
};
skim.SceneManager.prototype.isSurfaceShown = function () {
	for (var a = Object.keys(this.surface_meshes), b = !0, c = 0; c < a.length; ++c)
		b = b && null !== this.surface_meshes[a[c]] && this.surface_meshes[a[c]].visible;
	return this.isReady() && b
};
skim.SceneManager.prototype.updateMaterial = function () {
	if (this.isReady())
		for (var a = Object.keys(this.surface_meshes), b = 0; b < a.length; ++b)
			this.surface_meshes[a[b]].material = this.surface_material
};
skim.SceneManager.prototype.showSurface = function (a) {
	for (var b = Object.keys(this.surface_meshes), c = 0; c < b.length; ++c)
		this.setVisible(this.surface_meshes[b[c]], a)
};
skim.SceneManager.prototype.removeSurface = function (a) {
	skim.utils.assert(void 0 !== this.surface_meshes[a], "Error : The given name does not match any registered mesh");
	null !== this.surface_meshes[a] && (this.removeMesh(this.surface_meshes[a]), this.surface_meshes[a].geometry.dispose(), this.surface_meshes[a] = null, this.render_required = !0)
};
skim.SceneManager.prototype.addSurface = function (a) {
	skim.utils.assert(void 0 !== this.surface_meshes[a.name], "Error : The given name does not match any registered mesh");
	var b = a.geometry,
	c = this.isWireframe ? this.wireframe_material : this.surface_material;
	this.isWireframe && this.checkBarycentricAttribute(b);
	this.removeSurface(a.name);
	this.surface_meshes[a.name] = new THREE.Mesh(b, c);
	this.addMesh(this.surface_meshes[a.name]);
	this.surface_ready = this.isReady();
	skim.instances.modeler.initialized && this.setShowSurface(this.surface_to_show)
};
skim.SceneManager.prototype.checkBarycentricAttribute = function (a) {
	if (void 0 === a.getAttribute("barycentric")) {
		skim.utils.assert(void 0 !== a.getAttribute("position"), "Error : position attribute must be defined in geometry");
		a.addAttribute("barycentric", new THREE.BufferAttribute(new Float32Array(3 * a.getAttribute("position").count), 3));
		a = a.getAttribute("barycentric");
		for (var b = a.count, c = 0; c < b; c += 3)
			a.setXYZ(c, 1, 0, 0), a.setXYZ(c + 1, 0, 1, 0), a.setXYZ(c + 2, 0, 0, 1)
	}
};
skim.SceneManager.prototype.setWireframe = function (a) {
	this.isWireframe = a;
	a = Object.keys(this.surface_meshes);
	for (var b = 0; b < a.length; ++b)
		if (null !== this.surface_meshes[a[b]]) {
			this.surface_meshes[a[b]].material = this.isWireframe ? this.wireframe_material : this.surface_material;
			var c = this.surface_meshes[a[b]].geometry;
			this.isWireframe && this.checkBarycentricAttribute(c)
		}
	this.render_required = !0
};
skim.SceneManager.prototype.prepareForScreenshot = function (a) {
	skim.utils.assert(null === this.screenshot_push, "Error : must not call prepareForScreenshot twice whithout calling resetAfterScreenshot in between");
	skim.utils.assert(void 0 !== a.symplane_x && void 0 !== a.symplane_y && void 0 !== a.symplane_z, "Error : must decide what we do with symplanes");
	this.screenshot_push = {
		surface : this.surface_to_show,
		symplane_x : this.symplane_x.visible,
		symplane_y : this.symplane_y.visible,
		symplane_z : this.symplane_z.visible,
		pedestal : this.pedestal.visible,
		helperBoundingBox : this.helperBoundingBox.visible,
		wireframe : this.isWireframe,
		neutral_objects : this.getNeutralObjectsVisibility(),
		neutral_meshes : this.getNeutralMeshesVisibility()
	};
	this.setShowSurface(void 0 !== a.surface ? a.surface : this.surface_to_show);
	this.setWireframe(void 0 !== a.wireframe ? a.wireframe : !1);
	this.setVisible(this.symplane_x, void 0 !== a.symplane_x ? a.symplane_x : !1);
	this.setVisible(this.symplane_y, void 0 !== a.symplane_y ? a.symplane_y : !1);
	this.setVisible(this.symplane_z, void 0 !== a.symplane_z ? a.symplane_z :
		!1);
	this.setVisible(this.pedestal, void 0 !== a.pedestal ? a.pedestal : !1);
	this.setVisible(this.helperBoundingBox, void 0 !== a.helperBoundingBox ? a.helperBoundingBox : !1);
	if (!a.neutral_objects)
		for (var b = Object.keys(this.neutralObjects), c = 0; c < b.length; ++c)
			this.neutralObjects[b[c]].visible = !1, this.neutralObjectUpdated(b[c]);
	if (!a.neutral_meshes)
		for (b = Object.keys(this.neutralMeshes), c = 0; c < b.length; ++c)
			this.neutralMeshes[b[c]].visible = !1
};
skim.SceneManager.prototype.resetAfterScreenshot = function () {
	var a = this.screenshot_push;
	this.screenshot_push = null;
	this.setShowSurface(a.surface);
	this.setVisible(this.symplane_x, a.symplane_x);
	this.setVisible(this.symplane_y, a.symplane_y);
	this.setVisible(this.symplane_z, a.symplane_z);
	this.setVisible(this.pedestal, a.pedestal);
	this.setVisible(this.helperBoundingBox, a.helperBoundingBox);
	this.setWireframe(a.wireframe);
	for (var b = Object.keys(this.neutralObjects), c = 0; c < b.length; ++c)
		this.neutralObjects[b[c]].visible =
			a.neutral_objects[b[c]], this.neutralObjectUpdated(b[c]);
	b = Object.keys(this.neutralMeshes);
	for (c = 0; c < b.length; ++c)
		this.neutralMeshes[b[c]].visible = a.neutral_meshes[b[c]]
};
skim.SceneManager.prototype.setShowSurface = function (a) {
	this.surface_to_show = a;
	this.isReady() ? (this.showSurface(a), this.setSymPlaneXVisible(this.symplane_x_to_show), this.setSymPlaneYVisible(this.symplane_y_to_show), this.setSymPlaneZVisible(this.symplane_z_to_show), this.showWidgets(!a), a ? skim.instances.modeler.pageInterface.surfaceShown() : skim.instances.modeler.pageInterface.surfaceHidden()) : (this.showWidgets(!0), skim.instances.modeler.pageInterface.surfaceHidden())
};
skim.SceneManager.prototype.dispose = function () {
	for (var a = Object.keys(this.surface_meshes), b = 0; b < a.length; ++b)
		this.unregisterSurfaceMesh(a[b]);
	a = Object.keys(this.neutralMeshes);
	for (b = 0; b < a.length; ++b)
		this.removeNeutralMesh(a[b]);
	this.removeMesh(this.pedestal);
	this.removeMesh(this.symplane_x);
	this.removeMesh(this.symplane_y);
	this.removeMesh(this.symplane_z);
	this.removeMesh(this.helperBoundingBox);
	a = Object.keys(this.cameraMans);
	for (b = 0; b < a.length; ++b)
		this.removeCameraMan(this.cameraMans[a[b]]);
	if (this.scene) {
		for (b =
				this.scene.children.length - 1; 0 <= b; b--)
			a = this.scene.children[b], this.scene.remove(a);
		this.scene = null
	}
};
skim.tables.octreeCellVertexTopo = [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]];
skim.tables.singularVertices = Array(256);
skim.tables.cubeVertexTopoDist = function (a, b) {
	var c = skim.tables.octreeCellVertexTopo;
	return Math.abs(c[a][0] - c[b][0]) + Math.abs(c[a][1] - c[b][1]) + Math.abs(c[a][2] - c[b][2])
};
skim.tables.computeSingularVerticesTable = function () {
	for (var a = 0; 255 > a; ++a) {
		for (var b = [], c = 1, d = 0; 8 > d; ++d)
			a & c && b.push(d), c <<= 1;
		if (2 <= b.length) {
			c = [[b[0]], [], [], []];
			for (d = 1; d < b.length; ++d) {
				for (var e = b[d], f = [4, 4, 4, 4], g = 0; 4 > g; ++g)
					for (var h = 0; h < c[g].length; ++h) {
						var k = skim.tables.cubeVertexTopoDist(c[g][h], e);
						k < f[g] && (f[g] = k)
					}
				h = 0;
				for (g = 1; 4 > g; ++g)
					f[g] < f[h] && (h = g);
				if (2 <= f[h])
					for (g = 0; 4 > g; ++g) {
						if (0 === c[g].length) {
							c[g].push(e);
							break
						}
					}
				else {
					c[h].push(e);
					for (g = 0; 4 > g; ++g)
						g !== h && 2 > f[g] && (c[h] = c[h].concat(c[g]), c[g] =
								[]);
					e = c;
					c = [];
					for (g = 0; 4 > g; ++g)
						0 !== e[g].length && (c[g] = e[g]);
					for (g = c.length; 4 > g; ++g)
						c.push([])
				}
			}
			skim.tables.singularVertices[a] = 0 !== c[1].length && 0 === c[2].length && 0 === c[3].length
		} else
			skim.tables.singularVertices[a] = !1
	}
};
skim.tables.computeSingularVerticesTable();
skim.tables.octreeCellFaceTopo = [[0, 4, 5, 1], [0, 1, 3, 2], [0, 2, 6, 4], [1, 5, 7, 3], [4, 6, 7, 5], [2, 3, 7, 6]];
skim.tables.EdgeVMap = [[0, 4], [1, 5], [2, 6], [3, 7], [0, 2], [1, 3], [4, 6], [5, 7], [0, 1], [2, 3], [4, 5], [6, 7]];
skim.tables.NodeProcFaceMask = [[0, 4, 0], [1, 5, 0], [2, 6, 0], [3, 7, 0], [0, 2, 1], [4, 6, 1], [1, 3, 1], [5, 7, 1], [0, 1, 2], [2, 3, 2], [4, 5, 2], [6, 7, 2]];
skim.tables.NodeProcEdgeMask = [[0, 1, 2, 3, 0], [4, 5, 6, 7, 0], [0, 4, 1, 5, 1], [2, 6, 3, 7, 1], [0, 2, 4, 6, 2], [1, 3, 5, 7, 2]];
skim.tables.FaceProcFaceMask = [[[4, 0], [5, 1], [6, 2], [7, 3]], [[2, 0], [6, 4], [3, 1], [7, 5]], [[1, 0], [3, 2], [5, 4], [7, 6]]];
skim.tables.FaceProcEdgeFathersMask0 = [0, 0, 1, 1];
skim.tables.FaceProcEdgeFathersMask1 = [0, 1, 0, 1];
skim.tables.FaceProcEdgeFathersMask = [skim.tables.FaceProcEdgeFathersMask0, skim.tables.FaceProcEdgeFathersMask1];
skim.tables.FaceProcEdgeMask = [[[4, 0, 5, 1, 1, 1], [6, 2, 7, 3, 1, 1], [4, 6, 0, 2, 0, 2], [5, 7, 1, 3, 0, 2]], [[2, 3, 0, 1, 0, 0], [6, 7, 4, 5, 0, 0], [2, 0, 6, 4, 1, 2], [3, 1, 7, 5, 1, 2]], [[1, 0, 3, 2, 1, 0], [5, 4, 7, 6, 1, 0], [1, 5, 0, 4, 0, 1], [3, 7, 2, 6, 0, 1]]];
skim.tables.EdgeProcEdgeMask = [[[3, 2, 1, 0], [7, 6, 5, 4]], [[5, 1, 4, 0], [7, 3, 6, 2]], [[6, 4, 2, 0], [7, 5, 3, 1]]];
skim.tables.AddFaceProcEdgeMask = [[3, 2, 1, 0], [7, 5, 6, 4], [11, 10, 9, 8]];
skim.tables.AddFaceProcVerticesMask = [0, 1, 3, 2];
skim.tables.ChildPositionMask = [[[0, 1], [2, 3]], [[4, 5], [6, 7]]];
skim.tables.approxVolumeFromMask = function () {
	for (var a = Array(256), b = 0; 255 >= b; ++b) {
		for (var c = 0, d = 0; 8 > d; ++d)
			c += 0 != (b & 1 << d) ? 1 : 0;
		a[b] = 0.125 * c
	}
	return a
}
();
skim.importers.Importer = function (a) {
	this.ratio = a || 10
};
skim.importers.Importer.prototype.getSkimSurfaceMesh = function (a, b, c) {
	var d = new FileReader,
	e = this;
	d.addEventListener("loadend", function () {
		var a = new skim.utils.OBJToTHREELoader(null, e.ratio),
		d = this.result;
		c && (console.log("Uncompressing data"), console.log("Compressed Size" + 2 * this.result.length + " slice 15: " + this.result.slice(0, 15)), skim.utils.assert(LZString, "Importer - LZString lib has not been loaded"), d = LZString.decompressFromBase64(this.result), skim.utils.assert(null !== d || "" !== d, "uncompressedObj is not valid, compression has gone rogue"));
		a = a.parse(d);
		0 !== a.geometry.vertices.length && 0 !== a.geometry.faces.length ? console.log("Loaded geometry is not void") : console.warn("loading an empty geometry");
		console.log("Adding the skim  default material");
		b(a)
	}, !1);
	d.readAsText(a)
};
skim.CPURaytraceController = function (a, b) {
	this.incrementalCallback = this.callback = null;
	this.renderProgress = b;
	this.index = this.height = this.width = 0;
	this.imageBuffer = a
};
skim.CPURaytraceController.prototype.constructor = skim.CPURaytraceController;
skim.CPURaytraceController.prototype.sendParameters = function (a, b, c, d, e) {
	c.projectionMatrixInverse.getInverse(c.projectionMatrix);
	(new THREE.Matrix4).multiplyMatrices(c.matrixWorld, c.projectionMatrixInverse);
	(new THREE.Matrix3).getNormalMatrix(c.matrixWorld);
	this.width = b[0];
	this.height = b[1]
};
skim.CPURaytraceController.prototype.sendEnvMapImage = function (a) {};
skim.CPURaytraceController.prototype.incrementImageBuffer = function (a) {
	for (var b = 0; b < a.imageData.length; b++)
		this.imageBuffer[this.index++] = a.imageData[b];
	this.renderProgress(Math.round(100 * a.curLine / this.height))
};
skim.CPURaytraceController.prototype.buildSurface = function (a) {
	this.incrementImageBuffer(a);
	a.curLine !== this.height ? this.incrementalCallback() : this.callback()
};
skim.CPURaytraceController.prototype.getStatus = function (a) {};
skim.CPURaytraceController.prototype.sendComputeCallback = function (a, b, c) {
	this.sendCompute(a);
	this.incrementalCallback = b;
	this.callback = c
};
skim.CPURaytraceController.prototype.onMessage = function (a) {
	a = a.data;
	switch (a.cmd) {
	case "up":
		this.setReady(!0);
		console.log("%cWORKER: worker is up !", "background: #ffff00; color: #000");
		break;
	case "log":
		console.log("%cWORKER: " + a.msg, "background: #ffff00; color: #000");
		break;
	case "error":
		console.error("%cWORKER: " + a.msg, "background: #ffff00");
		break;
	case "surface":
		a.requestID == this.currentRequestID ? this.buildSurface(a) : console.log("%cCONTROLLER: received old surface (" + a.requestID + ") from worker. Current:" +
			this.currentRequestID + ". Dropping.", "background: #ffff00; color: #000");
		break;
	case "progress":
		break;
	default:
		console.error('%cWORKER: unrecognized command "' + a.cmd + '" from worker', "background: #ffff00")
	}
};
skim.tables.MCEdgeTable = new Uint32Array([0, 265, 515, 778, 1030, 1295, 1541, 1804, 2060, 2309, 2575, 2822, 3082, 3331, 3593, 3840, 400, 153, 915, 666, 1430, 1183, 1941, 1692, 2460, 2197, 2975, 2710, 3482, 3219, 3993, 3728, 560, 825, 51, 314, 1590, 1855, 1077, 1340, 2620, 2869, 2111, 2358, 3642, 3891, 3129, 3376, 928, 681, 419, 170, 1958, 1711, 1445, 1196, 2988, 2725, 2479, 2214, 4010, 3747, 3497, 3232, 1120, 1385, 1635, 1898, 102, 367, 613, 876, 3180, 3429, 3695, 3942, 2154, 2403, 2665, 2912, 1520, 1273, 2035, 1786, 502, 255, 1013, 764, 3580, 3317, 4095, 3830, 2554, 2291, 3065, 2800, 1616, 1881,
			1107, 1370, 598, 863, 85, 348, 3676, 3925, 3167, 3414, 2650, 2899, 2137, 2384, 1984, 1737, 1475, 1226, 966, 719, 453, 204, 4044, 3781, 3535, 3270, 3018, 2755, 2505, 2240, 2240, 2505, 2755, 3018, 3270, 3535, 3781, 4044, 204, 453, 719, 966, 1226, 1475, 1737, 1984, 2384, 2137, 2899, 2650, 3414, 3167, 3925, 3676, 348, 85, 863, 598, 1370, 1107, 1881, 1616, 2800, 3065, 2291, 2554, 3830, 4095, 3317, 3580, 764, 1013, 255, 502, 1786, 2035, 1273, 1520, 2912, 2665, 2403, 2154, 3942, 3695, 3429, 3180, 876, 613, 367, 102, 1898, 1635, 1385, 1120, 3232, 3497, 3747, 4010, 2214, 2479, 2725, 2988, 1196, 1445, 1711, 1958,
			170, 419, 681, 928, 3376, 3129, 3891, 3642, 2358, 2111, 2869, 2620, 1340, 1077, 1855, 1590, 314, 51, 825, 560, 3728, 3993, 3219, 3482, 2710, 2975, 2197, 2460, 1692, 1941, 1183, 1430, 666, 915, 153, 400, 3840, 3593, 3331, 3082, 2822, 2575, 2309, 2060, 1804, 1541, 1295, 1030, 778, 515, 265, 0]);
skim.tables.MCTriTable = [[], [0, 8, 3], [0, 1, 9], [1, 8, 3, 9, 8, 1], [1, 2, 10], [0, 8, 3, 1, 2, 10], [9, 2, 10, 0, 2, 9], [2, 8, 3, 2, 10, 8, 10, 9, 8], [3, 11, 2], [0, 11, 2, 8, 11, 0], [1, 9, 0, 2, 3, 11], [1, 11, 2, 1, 9, 11, 9, 8, 11], [3, 10, 1, 11, 10, 3], [0, 10, 1, 0, 8, 10, 8, 11, 10], [3, 9, 0, 3, 11, 9, 11, 10, 9], [9, 8, 10, 10, 8, 11], [4, 7, 8], [4, 3, 0, 7, 3, 4], [0, 1, 9, 8, 4, 7], [4, 1, 9, 4, 7, 1, 7, 3, 1], [1, 2, 10, 8, 4, 7], [3, 4, 7, 3, 0, 4, 1, 2, 10], [9, 2, 10, 9, 0, 2, 8, 4, 7], [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4], [8, 4, 7, 3, 11, 2], [11, 4, 7, 11, 2, 4, 2, 0, 4], [9, 0, 1, 8, 4, 7, 2, 3, 11], [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1], [3, 10, 1, 3, 11,
		10, 7, 8, 4], [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4], [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3], [4, 7, 11, 4, 11, 9, 9, 11, 10], [9, 5, 4], [9, 5, 4, 0, 8, 3], [0, 5, 4, 1, 5, 0], [8, 5, 4, 8, 3, 5, 3, 1, 5], [1, 2, 10, 9, 5, 4], [3, 0, 8, 1, 2, 10, 4, 9, 5], [5, 2, 10, 5, 4, 2, 4, 0, 2], [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8], [9, 5, 4, 2, 3, 11], [0, 11, 2, 0, 8, 11, 4, 9, 5], [0, 5, 4, 0, 1, 5, 2, 3, 11], [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5], [10, 3, 11, 10, 1, 3, 9, 5, 4], [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10], [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3], [5, 4, 8, 5, 8, 10, 10, 8, 11], [9, 7, 8, 5, 7, 9], [9, 3, 0, 9, 5, 3, 5, 7, 3], [0, 7, 8, 0, 1, 7, 1, 5, 7], [1, 5, 3, 3, 5, 7], [9, 7, 8, 9,
		5, 7, 10, 1, 2], [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3], [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2], [2, 10, 5, 2, 5, 3, 3, 5, 7], [7, 9, 5, 7, 8, 9, 3, 11, 2], [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11], [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7], [11, 2, 1, 11, 1, 7, 7, 1, 5], [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11], [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0], [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0], [11, 10, 5, 7, 11, 5], [10, 6, 5], [0, 8, 3, 5, 10, 6], [9, 0, 1, 5, 10, 6], [1, 8, 3, 1, 9, 8, 5, 10, 6], [1, 6, 5, 2, 6, 1], [1, 6, 5, 1, 2, 6, 3, 0, 8], [9, 6, 5, 9, 0, 6, 0, 2, 6], [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8], [2, 3, 11, 10, 6, 5], [11, 0, 8, 11, 2, 0, 10, 6, 5], [0, 1, 9, 2, 3, 11, 5, 10, 6],
	[5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11], [6, 3, 11, 6, 5, 3, 5, 1, 3], [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6], [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9], [6, 5, 9, 6, 9, 11, 11, 9, 8], [5, 10, 6, 4, 7, 8], [4, 3, 0, 4, 7, 3, 6, 5, 10], [1, 9, 0, 5, 10, 6, 8, 4, 7], [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4], [6, 1, 2, 6, 5, 1, 4, 7, 8], [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7], [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6], [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9], [3, 11, 2, 7, 8, 4, 10, 6, 5], [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11], [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6], [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6], [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6], [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11], [0, 5, 9,
		0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7], [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9], [10, 4, 9, 6, 4, 10], [4, 10, 6, 4, 9, 10, 0, 8, 3], [10, 0, 1, 10, 6, 0, 6, 4, 0], [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10], [1, 4, 9, 1, 2, 4, 2, 6, 4], [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4], [0, 2, 4, 4, 2, 6], [8, 3, 2, 8, 2, 4, 4, 2, 6], [10, 4, 9, 10, 6, 4, 11, 2, 3], [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6], [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10], [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1], [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3], [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1], [3, 11, 6, 3, 6, 0, 0, 6, 4], [6, 4, 8, 11, 6, 8], [7, 10, 6, 7, 8, 10, 8, 9, 10], [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10], [10, 6, 7, 1, 10, 7, 1,
		7, 8, 1, 8, 0], [10, 6, 7, 10, 7, 1, 1, 7, 3], [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7], [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9], [7, 8, 0, 7, 0, 6, 6, 0, 2], [7, 3, 2, 6, 7, 2], [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7], [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7], [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11], [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1], [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6], [0, 9, 1, 11, 6, 7], [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0], [7, 11, 6], [7, 6, 11], [3, 0, 8, 11, 7, 6], [0, 1, 9, 11, 7, 6], [8, 1, 9, 8, 3, 1, 11, 7, 6], [10, 1, 2, 6, 11, 7], [1, 2, 10, 3, 0, 8, 6, 11, 7], [2, 9, 0, 2, 10, 9, 6, 11, 7], [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8], [7, 2, 3, 6, 2, 7],
	[7, 0, 8, 7, 6, 0, 6, 2, 0], [2, 7, 6, 2, 3, 7, 0, 1, 9], [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6], [10, 7, 6, 10, 1, 7, 1, 3, 7], [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8], [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7], [7, 6, 10, 7, 10, 8, 8, 10, 9], [6, 8, 4, 11, 8, 6], [3, 6, 11, 3, 0, 6, 0, 4, 6], [8, 6, 11, 8, 4, 6, 9, 0, 1], [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6], [6, 8, 4, 6, 11, 8, 2, 10, 1], [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6], [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9], [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3], [8, 2, 3, 8, 4, 2, 4, 6, 2], [0, 4, 2, 4, 6, 2], [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8], [1, 9, 4, 1, 4, 2, 2, 4, 6], [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1], [10, 1, 0, 10, 0, 6, 6, 0, 4], [4, 6,
		3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3], [10, 9, 4, 6, 10, 4], [4, 9, 5, 7, 6, 11], [0, 8, 3, 4, 9, 5, 11, 7, 6], [5, 0, 1, 5, 4, 0, 7, 6, 11], [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5], [9, 5, 4, 10, 1, 2, 7, 6, 11], [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5], [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2], [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6], [7, 2, 3, 7, 6, 2, 5, 4, 9], [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7], [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0], [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8], [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7], [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4], [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10], [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10], [6, 9, 5, 6, 11, 9, 11, 8, 9], [3, 6, 11,
		0, 6, 3, 0, 5, 6, 0, 9, 5], [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11], [6, 11, 3, 6, 3, 5, 5, 3, 1], [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6], [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10], [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5], [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3], [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2], [9, 5, 6, 9, 6, 0, 0, 6, 2], [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8], [1, 5, 6, 2, 1, 6], [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6], [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0], [0, 3, 8, 5, 6, 10], [10, 5, 6], [11, 5, 10, 7, 5, 11], [11, 5, 10, 11, 7, 5, 8, 3, 0], [5, 11, 7, 5, 10, 11, 1, 9, 0], [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1], [11, 1, 2, 11, 7, 1, 7, 5, 1], [0, 8, 3, 1, 2, 7,
		1, 7, 5, 7, 2, 11], [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7], [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2], [2, 5, 10, 2, 3, 5, 3, 7, 5], [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5], [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2], [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2], [1, 3, 5, 3, 7, 5], [0, 8, 7, 0, 7, 1, 1, 7, 5], [9, 0, 3, 9, 3, 5, 5, 3, 7], [9, 8, 7, 5, 9, 7], [5, 8, 4, 5, 10, 8, 10, 11, 8], [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0], [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5], [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4], [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8], [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11], [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5], [9, 4, 5, 2, 11, 3], [2, 5, 10, 3, 5, 2, 3, 4,
		5, 3, 8, 4], [5, 10, 2, 5, 2, 4, 4, 2, 0], [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9], [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2], [8, 4, 5, 8, 5, 3, 3, 5, 1], [0, 4, 5, 1, 0, 5], [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5], [9, 4, 5], [4, 11, 7, 4, 9, 11, 9, 10, 11], [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11], [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11], [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4], [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2], [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3], [11, 7, 4, 11, 4, 2, 2, 4, 0], [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4], [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9], [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7], [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10], [1, 10, 2, 8, 7,
		4], [4, 9, 1, 4, 1, 7, 7, 1, 3], [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1], [4, 0, 3, 7, 4, 3], [4, 8, 7], [9, 10, 8, 10, 11, 8], [3, 0, 9, 3, 9, 11, 11, 9, 10], [0, 1, 10, 0, 10, 8, 8, 10, 11], [3, 1, 10, 11, 3, 10], [1, 2, 11, 1, 11, 9, 9, 11, 8], [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9], [0, 2, 11, 8, 0, 11], [3, 2, 11], [2, 3, 8, 2, 8, 10, 10, 8, 9], [9, 10, 2, 0, 9, 2], [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8], [1, 10, 2], [1, 3, 8, 9, 1, 8], [0, 9, 1], [0, 3, 8], []];
skim.tables.MCCubeVerts = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
skim.tables.MCEdgeIndex = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]];
var BackgroundRenderer = function (a, b) {
	this.backgroundScene = new THREE.Scene;
	this.backgroundCamera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -1, 1E4);
	this.backgroundRTT = b;
	this.backgroundMaterial = new THREE.MeshBasicMaterial;
	var c = new THREE.PlaneGeometry(2, 2);
	this.quad = new THREE.Mesh(c, new THREE.MeshBasicMaterial);
	this.quad.visible = !1;
	var c = a.shading[0].toUpperCase() + a.shading.substring(1, a.shading.length).toLowerCase(),
	d = this;
	skim.gl_materials["Background" +
		c].get({
		colorBack : new THREE.Color(a.colorBack),
		colorPoint : new THREE.Color(a.colorFront),
		pointPos : new THREE.Vector2(0, 0),
		a : a.coef || 5
	}, function (a) {
		d.quad.material = a.mat;
		d.quad.visible = !0;
		d.backgroundScene.add(d.quad)
	})
};
BackgroundRenderer.prototype = {
	renderToTexture : function (a) {
		a.render(this.backgroundScene, this.backgroundCamera, this.backgroundRTT, !0)
	},
	renderToScreen : function (a) {
		a.render(this.backgroundScene, this.backgroundCamera)
	},
	setVisible : function (a) {
		this.quad.visible = a
	}
};
skim.Stats = function () {
	this.prev = this.start = Date.now();
	this.frames = this.fps = 0
};
skim.Stats.prototype.updateFPS = function () {
	var a = Date.now();
	this.frames++;
	if (a > this.prev + 1E3) {
		this.fps = Math.round(1E3 * this.frames / (a - this.prev));
		this.prev = a;
		this.frames = 0;
		var b = document.getElementById("fps");
		b && (b.innerHTML = "fps: " + this.fps)
	}
	return this.start = a
};
skim.MainModeler = function () {
	_.extend(this, Backbone.Events);
	this.animateId = this.stats = this.renderer = this.canvas = null;
	this.renderMode = "skeleton";
	this.envTextLoaded = 0;
	this.debugZEval = 45;
	this.isDebugEval = !1;
	this.valueToDebug = "VALUE";
	this.n_render = 0;
	this.sceneManager = new skim.SceneManager;
	this.meshManager = new skim.MeshManager(this.sceneManager);
	this.initialized = !1
};
skim.MainModeler.prototype = {
	init : function (a, b, c, d, e, f, g) {
		var h = a.parentElement;
		this.screen_width = parseInt(skim.utils.getElementStyle(h, "width"), 10);
		this.screen_height = parseInt(skim.utils.getElementStyle(h, "height"), 10);
		this.stats = new skim.Stats;
		this.viewManager = {};
		skim.blobtree.setAccuracyLevel(this.accuracyLevel);
		d.surfaceShown || (d.surfaceShown = function () {});
		d.surfaceHidden || (d.surfaceHidden = function () {});
		d.startSurface || (d.startSurface = function () {});
		d.renderProgress || (d.renderProgress = function () {});
		d.doneSurface || (d.doneSurface = function () {});
		d.helperUpdate || (d.helperUpdate = function () {});
		d.helperShow || (d.helperShow = function () {});
		d.helperHide || (d.helperHide = function () {});
		d.setColorVal || (d.setColorVal = function () {});
		d.setShininessVal || (d.setShininessVal = function () {});
		d.initStyleRingTool || (d.initStyleRingTool = function () {});
		d.setBlendVal || (d.setBlendVal = function () {});
		d.setMaterial || (d.setMaterial = function () {});
		d.downloadFile || (d.downloadFile = function () {});
		d.uploadFile || (d.uploadFile = function () {});
		d.updateObjectData || (d.updateObjectData = function () {});
		d.showSymmetries || (d.showSymmetries = function () {});
		d.loadedEnvMap || (d.loadedEnvMap = function () {});
		d.onError || (d.onError = function () {});
		d.rsqFunctorWorked || (d.rsqFunctorWorked = function () {});
		this.pageInterface = d;
		this.webGLInit(h, b.colorFront, b.colorBack, a);
		skim.gl_materials["Save Normals"].get(function (a) {});
		this.backgroundRenderer = new BackgroundRenderer(b, this.backgroundRTT);
		this.canvas = this.renderer.domElement;
		this.canvas.addEventListener("webglcontextlost",
			this.handleContextLost, !1);
		this.canvas.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
		this.initWidgets3D();
		this.initStateMachine(c);
		e();
		this.animate();
		this.initialized = !0;
		null !== f && this.cameraMan.setPosition(f);
		null !== g && this.cameraMan.setRotSpeed(g);
		return !0
	},
	dispose : function () {
		this.stopRender();
		this.cameraMan && (this.cameraMan.dispose(), this.sceneManager.removeCameraMan(this.cameraMan), this.cameraMan = null);
		this.widgets3DManager && (this.widgets3DManager.dispose(), this.widgets3DManager =
				null);
		this.sceneManager && (this.sceneManager.dispose(), this.sceneManager = null);
		this.meshManager && (this.meshManager.dispose(), this.meshManager = null);
		if (this.viewManager) {
			for (var a = Object.keys(this.viewManager), b = 0; b < a.length; b++)
				"length" !== a[b] && this.viewManager.hasOwnProperty(a[b]) && this.viewManager[a[b]].off();
			delete this.viewManager.mainCanvasView;
			delete this.viewManager.mainDocView
		}
	},
	handleContextLost : function (a) {
		console.log("handlecontextlost !");
		a.preventDefault();
		null !== this.animateId && (window.cancelAnimationFrame(this.animateId),
			this.animateId = null)
	},
	handleContextRestored : function () {
		console.log("handlecontextrestored !")
	},
	webGLResize : function (a) {
		a = a.parentElement;
		this.screen_width = parseInt(skim.utils.getElementStyle(a, "width"), 10);
		this.screen_height = parseInt(skim.utils.getElementStyle(a, "height"), 10);
		this.renderer.setSize(this.screen_width, this.screen_height);
		this.require_render = !0
	},
	webGLInit : function (a, b, c, d) {
		this.canvas = d;
		this.borderColor = c;
		this.centerColor = b;
		this.renderer = new THREE.WebGLRenderer({
				canvas : d,
				preserveDrawingBuffer : !0,
				antialias : !0,
				alpha : !1
			});
		this.renderer.sortObjects = !1;
		this.backgroundRTT = new THREE.WebGLRenderTarget(this.screen_width, this.screen_height, {
				minFilter : THREE.LinearFilter,
				magFilter : THREE.NearestFilter,
				format : THREE.RGBFormat
			});
		this.renderer.setClearColor(this.borderColor, 1);
		this.renderer.setSize(this.screen_width, this.screen_height);
		a.appendChild(this.renderer.domElement);
		this.renderer.gammaInput = !0;
		this.renderer.gammaOutput = !0;
		this.renderer.physicallyBasedShading = !0;
		this.cameraMan = new CameraMan("mainCameraMan",
				this.renderer.domElement);
		this.cameraMan.setPerspectiveCameraParameters(45, this.screen_width / this.screen_height, 1, 1E5);
		this.cameraMan.setOrthographicCameraParameters(-this.screen_width / 2, this.screen_width / 2, this.screen_height / 2, -this.screen_height / 2, 1, 1E5);
		this.cameraMan.setCameraType("PerspectiveCamera", new skim.geometry.AABBox(-50, -50, -50, 50, 50, 50));
		this.cameraMan.setDistToTarget(200);
		this.cameraMan.setDistToTarget(200);
		this.sceneManager.addCameraMan(this.cameraMan);
		this.renderer.autoClear = !1;
		this.overlays =
			new Overlays
	},
	stopRender : function () {
		this.animateId && window.cancelAnimationFrame(this.animateId);
		this.renderer.clear()
	},
	startRender : function () {
		this.animate()
	},
	initWidgets3D : function () {
		this.widgets3DManager = new skim.widgets3d.Widgets3DManager;
		var a = new skim.widgets3d.VerticesWidget({
				name : "vertices_widget",
				skel : skim.instances.skel,
				cameraMan : this.cameraMan,
				scene : this.sceneManager.getScene(),
				canvas : this.renderer.domElement,
				sizeFactor : 1.01,
				symplaneColor : 5666162,
				symColor : 5400176,
				material : null
			}),
		b = new skim.widgets3d.PrimitiveWidget({
				name : "primitives_widget",
				skel : skim.instances.skel,
				cameraMan : this.cameraMan,
				scene : this.sceneManager.getScene(),
				canvas : this.renderer.domElement,
				sizeFactor : 0.98,
				colorHex : 10066329,
				material : null
			}),
		c = new skim.widgets3d.MeshWidget({
				name : "meshes_widget",
				skel : skim.instances.skel,
				cameraMan : this.cameraMan,
				scene : this.sceneManager.getScene(),
				canvas : this.renderer.domElement,
				sizeFactor : 0.98,
				colorHex : 10066329,
				material : null
			});
		this.widgets3DManager.addWidget(a);
		this.widgets3DManager.addWidget(b);
		this.widgets3DManager.addWidget(c);
		c = new THREE.MeshBasicMaterial({
				color : 16777215,
				opacity : 0.1,
				transparent : !0
			});
		a.setMaterial(c);
		b.setMaterial(c);
		skim.gl_materials["Skim Vertices Widget"].get(function (b) {
			a.setMaterial(b.mat)
		});
		skim.gl_materials["Skim Primitives Widget"].get(function (a) {
			b.setMaterial(a.mat)
		})
	},
	setCanvasFocus : function () {
		this.renderer.domElement.setAttribute("tabindex", "0");
		this.renderer.domElement.contentEditable = !0;
		this.renderer.domElement.focus()
	},
	initStateMachine : function (a) {
		console.log("modeler init SM");
		this.setCanvasFocus();
		for (var b = Object.keys(this.viewManager),
			c = 0; c < b.length; c++)
			"length" !== b[c] && this.viewManager.hasOwnProperty(b[c]) && this.viewManager[b[c]].off();
		this.viewManager.mainCanvasView || (this.viewManager.mainCanvasView = new skim.views.MainCanvasView({
					canvas : this.renderer.domElement,
					widgets3DManager : this.widgets3DManager
				}));
		this.viewManager.mainDocView || (this.viewManager.mainDocView = new skim.views.MainDocView);
		this.statemachine = new StateMachine(a);
		this.statemachine.init(!0)
	},
	save_screenshot : function () {
		var a = new THREE.MeshBasicMaterial({
				color : 16777215
			});
		return function (b, c) {
			var d = this.cameraMan,
			e = {
				symplane_x : !1,
				symplane_y : !1,
				symplane_z : !1,
				pedestal : !1,
				wireframe : !1,
				neutral_meshes : !1,
				neutral_objects : !1
			};
			void 0 !== c && (e.surface = c);
			this.sceneManager.prepareForScreenshot(e);
			d.pushPosition();
			this.center_view(1);
			d = {};
			d.surface = this.sceneManager.getSurfaceMaterial();
			for (var e = Object.keys(this.widgets3DManager.getWidgets()), f = 0; f < e.length; ++f)
				d[e[f]] = this.widgets3DManager.getWidgets()[e[f]].getMaterial();
			switch (b) {
			case skim.SCREENSHOT.NONE:
				break;
			case skim.SCREENSHOT.MASK:
				this.sceneManager.setSurfaceMaterial(a);
				for (f = 0; f < e.length; ++f)
					this.widgets3DManager.getWidgets()[e[f]].setMaterial(a);
				this.backgroundRenderer.setVisible(!1);
				this.renderer.setClearColor(0, 1);
				break;
			case skim.SCREENSHOT.NORMAL_MAP:
				f = skim.gl_materials["Save Normals"].get(function (a) {});
				skim.utils.assert(null !== f, "Error : we assume here that the material has been loaded on modeler init. If not, then this function needs to be rewritten asynchronously");
				this.sceneManager.setSurfaceMaterial(f);
				for (f = 0; f < e.length; ++f)
					this.widgets3DManager.getWidgets()[e[f]].setMaterial(a);
				this.backgroundRenderer.setVisible(!1);
				this.renderer.setClearColor(10066329, 1);
				break;
			default:
				skim.utils.assert(!1, "Invalide screenshot mode")
			}
			this.renderer.clear();
			this.backgroundRenderer.renderToScreen(this.renderer);
			this.renderer.render(this.sceneManager.scene, this.cameraMan.getCamera());
			var g = skim.instances.modeler.renderer.domElement.toDataURL("image/png");
			if (b === skim.SCREENSHOT.MASK || b === skim.SCREENSHOT.NORMAL_MAP) {
				this.sceneManager.setSurfaceMaterial(d.surface);
				for (f = 0; f < e.length; ++f)
					this.widgets3DManager.getWidgets()[e[f]].setMaterial(d[e[f]]);
				this.backgroundRenderer.setVisible(!0);
				this.renderer.setClearColor(this.borderColor, 1)
			}
			this.sceneManager.resetAfterScreenshot();
			skim.instances.modeler.cameraMan.popPosition();
			return g
		}
	}
	(),
	save_object_img : function (a, b, c, d) {
		var e = [this.screen_width, this.screen_height],
		f = document.createElement("canvas");
		f.width = a[0];
		f.height = a[1];
		var g = f.getContext("2d"),
		h = {};
		void 0 !== b.basic && null !== b.basic && (h.basic = new Image);
		h.mask = new Image;
		void 0 !== b.normal_map && null !== b.normal_map && (h.normal_map = new Image);
		var k =
			0,
		l = Object.keys(h).length,
		m = {
			basic : null,
			mask : null,
			normal_map : null
		},
		n = function (d) {
			skim.instances.modeler.drawImageConstRatio(g, h[d], e, a);
			k++;
			m[d] = g.getImageData(0, 0, a[0], a[1]);
			if (k >= l) {
				d = {};
				if (void 0 !== b.basic && null !== b.basic)
					for (var n = 0; n < m.basic.data.length; n += 4)
						m.basic.data[n + 3] = m.mask.data[n];
				if (void 0 !== b.normal_map && null !== b.normal_map)
					for (n = 0; n < m.normal_map.data.length; n += 4)
						m.normal_map.data[n + 3] = m.mask.data[n];
				var n = a[1] / a[0],
				p = document.createElement("canvas");
				p.width = 300;
				p.height = Math.round(300 *
						n);
				var q = p.getContext("2d");
				q.scale(p.width / f.width, p.height / f.height);
				for (var r = Object.keys(b), n = 0; n < r.length; ++n)
					null !== b[r[n]] && void 0 !== b[r[n]] && (d[r[n]] = {}, g.putImageData(m[r[n]], 0, 0), void 0 !== b[r[n]].full && (d[r[n]].full = f.toDataURL("image/png")), void 0 !== b[r[n]].thumb && (q.drawImage(f, 0, 0), d[r[n]].thumb = p.toDataURL("image/png")));
				c(d)
			}
		},
		p = function () {
			n("basic")
		},
		q = function () {
			n("mask")
		},
		r = function () {
			n("normal_map")
		};
		void 0 !== h.basic && (h.basic.src = skim.instances.modeler.save_screenshot(skim.SCREENSHOT.NONE,
					d), h.basic.onload = p);
		void 0 !== h.mask && (h.mask.src = skim.instances.modeler.save_screenshot(skim.SCREENSHOT.MASK, d), h.mask.onload = q);
		void 0 !== h.normal_map && (h.normal_map.src = skim.instances.modeler.save_screenshot(skim.SCREENSHOT.NORMAL_MAP, d), h.normal_map.onload = r)
	},
	drawImageConstRatio : function (a, b, c, d) {
		var e = c[0] / c[1],
		f = d[0] / d[1];
		e > f ? (e = Math.round(f * c[1]), a.drawImage(b, (c[0] - e) / 2, 0, e, c[1], 0, 0, d[0], d[1])) : e < f ? (e = c[0] / f, a.drawImage(b, 0, (c[1] - e) / 2, c[0], e, 0, 0, d[0], d[1])) : a.drawImage(b, 0, 0, c[0], c[1], 0, 0,
			d[0], d[1])
	},
	cameraMode : skim.CAMERA_MODE.Perspective,
	setCameraMode : function (a) {
		this.cameraMode = a;
		this.cameraMan.resetOrientation();
		skim.instances.skel.computeAABB();
		var b = skim.instances.skel.aabb;
		switch (a) {
		case skim.CAMERA_MODE.Perspective:
			this.cameraMan.setCameraType("PerspectiveCamera", b);
			break;
		case skim.CAMERA_MODE.Orthographic:
			this.cameraMan.setCameraType("OrthographicCamera", b);
			break;
		case skim.CAMERA_MODE.PXOrthographic:
			this.cameraMan.setCameraType("OrthographicCamera", b);
			this.cameraMan.rotateAxis(new THREE.Vector3(0,
					1, 0), -Math.PI / 2);
			break;
		case skim.CAMERA_MODE.NXOrthographic:
			this.cameraMan.setCameraType("OrthographicCamera", b);
			this.cameraMan.rotateAxis(new THREE.Vector3(0, 1, 0), Math.PI / 2);
			break;
		case skim.CAMERA_MODE.PYOrthographic:
			this.cameraMan.setCameraType("OrthographicCamera", b);
			this.cameraMan.rotateAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
			break;
		case skim.CAMERA_MODE.NYOrthographic:
			this.cameraMan.setCameraType("OrthographicCamera", b);
			this.cameraMan.rotateAxis(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
			break;
		case skim.CAMERA_MODE.PZOrthographic:
			this.cameraMan.setCameraType("OrthographicCamera",
				b);
			this.cameraMan.rotateAxis(new THREE.Vector3(0, 1, 0), Math.PI);
			break;
		case skim.CAMERA_MODE.NZOrthographic:
			this.cameraMan.setCameraType("OrthographicCamera", b);
			break;
		default:
			skim.utils.assert(!1, "Error : unknown camera mode")
		}
	},
	center_view : function (a) {
		skim.instances.skel.computeAABB();
		this.cameraMan.centerView(skim.instances.skel.aabb, a)
	},
	renderRequired : function () {
		return this.widgets3DManager.renderRequired() || this.cameraMan.renderRequired() || this.sceneManager.renderRequired() || this.require_render
	},
	renderDone : function () {
		this.widgets3DManager.renderDone();
		this.cameraMan.renderDone();
		this.sceneManager.renderDone();
		this.require_render = !1
	},
	sceneWasReady : !0,
	last_skel_aabb : new skim.geometry.AABBox,
	animate : function () {
		this.animateId = requestAnimationFrame(this.animate.bind(this));
		this.last_skel_aabb.equals(skim.instances.skel.getAABB()) || (this.sceneManager.updateSceneElements(), this.last_skel_aabb.copy(skim.instances.skel.getAABB()));
		if (this.sceneManager.isReady()) {
			if (!1 == this.sceneWasReady) {
				this.sceneWasReady =
					!0;
				this.pageInterface.renderProgress(!0, 100);
				this.pageInterface.doneSurface();
				var a = this.meshManager.getMergedMeshesData();
				skim.instances.modeler.pageInterface.updateObjectData(a.volume, a.surface, a.aabb)
			}
		} else
			this.sceneWasReady ? (this.sceneWasReady = !1, this.pageInterface.startSurface()) : this.pageInterface.renderProgress(this.meshManager.getGlobalMeshStatus().isDone, this.meshManager.getGlobalMeshProgress());
		this.updateModeler();
		this.renderRequired() && (this.renderer.clear(), this.backgroundRenderer.renderToScreen(this.renderer),
			this.renderer.render(this.sceneManager.scene, this.cameraMan.getCamera()), this.overlays.render(this.renderer), this.renderDone());
		this.stats.updateFPS();
		-1 != navigator.userAgent.indexOf("Firefox") && 60 == this.n_render && (console.log("Save FF " + this.n_render), this.canvas.width--, this.cameraMan.setDistToTarget(this.cameraMan.getDistToTarget()), this.canvas.width++);
		this.n_render++
	},
	accuracyLevel : 2,
	setAccuracyLevel : function (a) {
		skim.blobtree.setAccuracyLevel(a);
		this.accuracyLevel = a;
		this.meshManager.resetMeshesComputation()
	},
	exportMesh : function (a, b, c, d, e, f) {
		void 0 !== f && skim.blobtree.setAccuracyLevel(f);
		skim.utils.assert(void 0 !== skim.settings || void 0 !== skim.settings.unit, "Error : skim.settings.unit is undefined");
		this.meshManager.exportMesh(a, b, c, d, e, skim.settings.unit);
		void 0 !== f && skim.blobtree.setAccuracyLevel(this.accuracyLevel)
	},
	updateModeler : function () {
		this.widgets3DManager.updateWidgets()
	},
	detectWebGL : function () {
		try {
			var a = !!window.WebGLRenderingContext && !!document.createElement("canvas").getContext("experimental-webgl");
			a || console.error("webgl not detected !");
			return a
		} catch (b) {
			return console.error("Failed to init webGL: ", b.message),
			!1
		}
	},
	alterDepthDebug : function (a) {
		this.debugZEval += a;
		this.require_render = !0
	}
};
var Transformer = {
	selection : {
		vertices : {},
		primitives : {},
		setVertex : function (a) {
			Transformer.selection.vertices[a.id] = a;
			var b = skim.settings.colors.verticesColors.selected,
			c = skim.engine.getVArrSym(a, {});
			skim.instances.modeler.widgets3DManager.widgets.vertices_widget.setColor(c, skim.settings.colors.verticesColors.symHighlight);
			skim.instances.modeler.widgets3DManager.widgets.vertices_widget.setColor([a], b);
			Transformer.creation.updateGrid()
		},
		setVertexUnderMouse : function () {
			skim.utils.assert(null !== this.w3dHit.v,
				"Error : Transformer.selection.setVertex can only be called when mouse is under a vertex");
			Transformer.selection.setVertex(this.w3dHit.v)
		},
		unsetVertex : function (a) {
			delete Transformer.selection.vertices[a.id];
			skim.instances.modeler.widgets3DManager.widgets.vertices_widget.uncolor([a]);
			a = skim.engine.getVArrSym(a, {});
			skim.instances.modeler.widgets3DManager.widgets.vertices_widget.uncolor(a);
			Transformer.creation.updateGrid()
		},
		unsetAllVertices : function () {
			for (var a = Object.keys(Transformer.selection.vertices),
				b = 0; b < a.length; ++b)
				void 0 !== Transformer.selection.vertices[a[b]] && Transformer.selection.unsetVertex(Transformer.selection.vertices[a[b]]);
			a = Object.keys(Transformer.selection.vertices);
			skim.utils.assert(0 === a.length, "Error : keys should be empty now...");
			Transformer.creation.updateGrid()
		},
		setPrimitive : function (a) {
			Transformer.selection.primitives[a.id] = a;
			var b = skim.settings.colors.primitivesColors.selected,
			c = skim.engine.getPArrSym(a, {});
			skim.instances.modeler.widgets3DManager.widgets.primitives_widget.setColor(c,
				skim.settings.colors.primitivesColors.symHighlight);
			skim.instances.modeler.widgets3DManager.widgets.primitives_widget.setColor([a], b)
		},
		setPrimitiveUnderMouse : function () {
			skim.utils.assert(null !== this.w3dHit.p, "Error : Transformer.selection.setPrimitive can only be called when mouse is under a prim");
			Transformer.selection.setPrimitive(this.w3dHit.p)
		},
		unsetPrimitive : function (a) {
			delete Transformer.selection.primitives[a.id];
			skim.instances.modeler.widgets3DManager.widgets.primitives_widget.uncolor([a]);
			a = skim.engine.getPArrSym(a, {});
			skim.instances.modeler.widgets3DManager.widgets.primitives_widget.uncolor(a)
		},
		unsetAllPrimitives : function () {
			for (var a = Object.keys(Transformer.selection.primitives), b = 0; b < a.length; ++b)
				void 0 !== Transformer.selection.primitives[a[b]] && Transformer.selection.unsetPrimitive(Transformer.selection.primitives[a[b]]);
			a = Object.keys(Transformer.selection.primitives);
			skim.utils.assert(0 === a.length, "Error : keys should be empty now...")
		}
	},
	cam : {
		centered : !1,
		isSkeletonOnCanvas : function () {
			var a =
				skim.instances.skel.getAABB(),
			b = !1;
			a.isEmpty() || (a = Transformer.cam.project.project_aabb(a), b = -1 < a.min_x && 1 > a.max_x && -1 < a.min_y && 1 > a.max_y);
			return b
		},
		setupTargetPointUnderMouse : function (a, b) {
			a.ray = skim.instances.modeler.cameraMan.getRay(a.canvasX, a.canvasY);
			switch (skim.settings.cameraTarget) {
			case skim.CAMERA_TARGET_0:
				a.interest_point = skim.instances.modeler.cameraMan.getTarget().clone();
				break;
			case skim.CAMERA_TARGET_SMART:
				var c = skim.instances.modeler.cameraMan.getTarget(),
				d = (new THREE.Vector3(c.x, c.y,
						c.z)).project(skim.instances.modeler.cameraMan.getCamera()),
				d = Transformer.cam.isSkeletonOnCanvas(),
				e = Object.keys(Transformer.selection.vertices);
				if (1 !== e.length)
					if (e = new THREE.Raycaster(a.ray.origin, a.ray.direction), a.interest_point = new THREE.Vector3, a.interest_point.copy(c), void 0 !== a.w3dHit && null !== a.w3dHit && void 0 !== a.w3dHit.point && null !== a.w3dHit.point)
						a.interest_point.copy(a.w3dHit.point);
					else {
						var c = [],
						f = skim.instances.modeler.meshManager.getBlobtrees()[0],
						g = f.aabb.getBoundingSphere(),
						g = a.ray.origin.distanceTo(g.center) +
							g.radius,
						h = {};
						f.intersectRayBlob(e.ray, h, g, 0.5) && c.push(h);
						0 !== c.length && (a.interest_point = c[0].point)
					}
				else
					a.interest_point = Transformer.selection.vertices[e[0]].getPos().clone();
				e = a.interest_point;
				b && d && (d = skim.instances.skel.getAABB(), a.obj_center_point = d.getCenter(), e = a.obj_center_point);
				d = (new THREE.Vector3(e.x, e.y, e.z)).project(skim.instances.modeler.cameraMan.getCamera());
				d = new THREE.Vector3(0, 0, d.z);
				d.unproject(skim.instances.modeler.cameraMan.getCamera());
				skim.instances.modeler.cameraMan.setTarget(d.x,
					d.y, d.z);
				skim.instances.modeler.cameraMan.setDistToTarget((new THREE.Vector3).subVectors(d, skim.instances.modeler.cameraMan.getCameraWorldPosition()).length());
				break;
			default:
				console.error("Error : skim.settings.cameraTarget is set to an unknown value")
			}
		},
		center_on_hit : function () {
			var a = null;
			return function () {
				if ("background" !== this.on) {
					null !== a && (clearInterval(a), a = null);
					var b = skim.instances.modeler.cameraMan.getTarget().clone(),
					c = this.w3dHit.point,
					d = 0;
					a = setInterval(function () {
							if (60 >= d) {
								var e = d / 60;
								d += 2;
								skim.instances.modeler.cameraMan.setTarget(e * c.x + (1 - e) * b.x, e * c.y + (1 - e) * b.y, e * c.z + (1 - e) * b.z)
							} else
								clearInterval(a), a = null
						}, 1 / 60)
				}
			}
		}
		(),
		zoomStraight : {
			modeler : skim.instances.modeler,
			increase : function () {
				Transformer.cam.setupTargetPointUnderMouse(this, !1);
				skim.instances.modeler.cameraMan.zoomTarget(0.2);
				Transformer.cam.centered = !1
			},
			decrease : function () {
				Transformer.cam.setupTargetPointUnderMouse(this, !1);
				skim.instances.modeler.cameraMan.zoomTarget(-0.2);
				Transformer.cam.centered = !1
			}
		},
		zoomCursor : {
			modeler : skim.instances.modeler,
			timeout : null,
			zoomAnim : function () {
				$(skim.instances.modeler.canvas).css("cursor", "crosshair");
				clearTimeout(Transformer.cam.zoomCursor.timeout);
				Transformer.cam.zoomCursor.timeout = setTimeout(function () {
						$(skim.instances.modeler.canvas).css("cursor", "default")
					}, 200)
			},
			incdec : function (a, b) {
				var c = skim.instances.skel.getAABB().getDimensions();
				skim.instances.modeler.cameraMan.setMaxDist(10 * Math.max(Math.max(c.x, c.y), c.z));
				Transformer.cam.setupTargetPointUnderMouse(a, !1);
				skim.instances.modeler.cameraMan.zoomPoint(b,
					a.interest_point);
				Transformer.cam.zoomCursor.zoomAnim();
				Transformer.cam.centered = !1
			},
			increase : function () {
				Transformer.cam.zoomCursor.incdec(this, 0.2);
				Transformer.cam.centered = !1
			},
			decrease : function () {
				Transformer.cam.zoomCursor.incdec(this, -0.2);
				Transformer.cam.centered = !1
			}
		},
		animZoomCursor : {
			origin_d : -1,
			interval : null,
			increase : function () {
				-1 === Transformer.cam.animZoomCursor.origin_d && (Transformer.cam.animZoomCursor.origin_d = skim.instances.modeler.cameraMan.getDistToTarget());
				var a = skim.settings.cameraTarget;
				skim.settings.cameraTarget = skim.CAMERA_TARGET_SMART;
				Transformer.cam.zoomCursor.incdec(this, 0.15);
				skim.settings.cameraTarget = a
			},
			decrease : function () {
				if (Transformer.cam.isSkeletonOnCanvas())
					Transformer.cam.animZoomCursor.center000_decrease.call(this);
				else {
					var a = skim.settings.cameraTarget;
					skim.settings.cameraTarget = skim.CAMERA_TARGET_SMART;
					Transformer.cam.zoomCursor.incdec(this, -0.15);
					skim.settings.cameraTarget = a
				}
			},
			center_increase : function () {
				null !== Transformer.cam.animZoomCursor.interval && (clearInterval(Transformer.cam.animZoomCursor.interval),
					Transformer.cam.animZoomCursor.interval = null);
				var a = skim.instances.modeler.cameraMan.getTarget().clone(),
				b = skim.instances.modeler.cameraMan.getDistToTarget(),
				c = "background" === this.on ? a : this.w3dHit.point,
				d = 0.6 * b;
				-1 === Transformer.cam.animZoomCursor.origin_d && (Transformer.cam.animZoomCursor.origin_d = b);
				var e = 0;
				Transformer.cam.animZoomCursor.interval = setInterval(function () {
						if (60 >= e) {
							var f = e / 60;
							e += 2;
							skim.instances.modeler.cameraMan.setDistToTarget(f * d + (1 - f) * b);
							skim.instances.modeler.cameraMan.setTarget(f *
								c.x + (1 - f) * a.x, f * c.y + (1 - f) * a.y, f * c.z + (1 - f) * a.z)
						} else
							clearInterval(Transformer.cam.animZoomCursor.interval), Transformer.cam.animZoomCursor.interval = null
					}, 1 / 60)
			},
			center000_decrease : function () {
				if (-1 !== Transformer.cam.animZoomCursor.origin_d) {
					null !== Transformer.cam.animZoomCursor.interval && (clearInterval(Transformer.cam.animZoomCursor.interval), Transformer.cam.animZoomCursor.interval = null);
					var a = skim.instances.modeler.cameraMan.getTarget().clone(),
					b = skim.instances.modeler.cameraMan.getDistToTarget(),
					c = "background" === this.on ? a : this.w3dHit.point,
					d = b / 0.6;
					Transformer.cam.isSkeletonOnCanvas() && (d = Transformer.cam.animZoomCursor.origin_d, Transformer.cam.animZoomCursor.origin_d = -1, c = new THREE.Vector3(0, 0, 0));
					var e = 0;
					Transformer.cam.animZoomCursor.interval = setInterval(function () {
							if (60 >= e) {
								var f = e / 60;
								e += 2;
								skim.instances.modeler.cameraMan.setDistToTarget(f * d + (1 - f) * b);
								skim.instances.modeler.cameraMan.setTarget(f * c.x + (1 - f) * a.x, f * c.y + (1 - f) * a.y, f * c.z + (1 - f) * a.z)
							} else
								clearInterval(Transformer.cam.animZoomCursor.interval),
								Transformer.cam.animZoomCursor.interval = null
						}, 1 / 60)
				}
			}
		},
		project : {
			project_aabb : function (a) {
				a = a.getCorners();
				for (var b = {
						min_x : 1E4,
						min_y : 1E4,
						max_x : -1E4,
						max_y : -1E4
					}, c = 0; 8 > c; ++c)
					a[c].project(skim.instances.modeler.cameraMan.getCamera()), a[c].x > b.max_x && (b.max_x = a[c].x), a[c].y > b.max_y && (b.max_y = a[c].y), a[c].x < b.min_x && (b.min_x = a[c].x), a[c].y < b.min_y && (b.min_y = a[c].y);
				return b
			}
		},
		translate : {
			init : function () {
				Transformer.cam.setupTargetPointUnderMouse(this, !1);
				this.prevCanvasX = this.canvasX;
				this.prevCanvasY = this.canvasY;
				$("body").addClass("noselect")
			},
			run : function () {
				var a = skim.instances.modeler.cameraMan.getTarget(),
				b = (new THREE.Vector3(a.x, a.y, a.z)).project(skim.instances.modeler.cameraMan.getCamera()),
				c = new THREE.Vector3(0, 0, b.z);
				c.x = 2 * (this.canvasX / skim.instances.modeler.canvas.width) - 1;
				c.y = 2 *  - (this.canvasY / skim.instances.modeler.canvas.height) + 1;
				c.unproject(skim.instances.modeler.cameraMan.getCamera());
				var d = c.clone();
				c.x = 2 * (this.prevCanvasX / skim.instances.modeler.viewManager.mainCanvasView.el.width) - 1;
				c.y = 2 *
					 - (this.prevCanvasY / skim.instances.modeler.viewManager.mainCanvasView.el.height) + 1;
				c.z = b.z;
				b = c.unproject(skim.instances.modeler.cameraMan.getCamera());
				skim.instances.modeler.cameraMan.setTarget(a.x - d.x + b.x, a.y - d.y + b.y, a.z - d.z + b.z);
				this.prevCanvasX = this.canvasX;
				this.prevCanvasY = this.canvasY;
				Transformer.creation.updateGrid();
				Transformer.cam.centered = !1
			},
			finalize : function () {
				$("body").removeClass("noselect")
			}
		},
		rotateShowcase : function () {
			var a = skim.instances.modeler.cameraMan.getRotMode();
			skim.instances.modeler.cameraMan.setRotMode("basic");
			skim.instances.modeler.cameraMan.prepareRotation(0, 0);
			skim.instances.modeler.cameraMan.rotateFromMouse(2, 0);
			skim.instances.modeler.cameraMan.setRotMode(a)
		},
		automatedRotate : {
			rotating : !1,
			timer : null,
			launchTimer : null,
			launchDelay : 1E4,
			delay : 17,
			launch : function () {
				var a = Transformer.cam.automatedRotate;
				a.timer = window.setInterval(function () {
						var a = skim.instances.modeler.cameraMan.getRotMode();
						skim.instances.modeler.cameraMan.setRotMode("basic");
						skim.instances.modeler.cameraMan.prepareRotation(0, 0);
						var c = skim.instances.modeler.cameraMan.getRotSpeed();
						skim.instances.modeler.cameraMan.rotateFromMouse(c, 0);
						skim.instances.modeler.cameraMan.setRotMode(a)
					}, a.delay);
				a.rotating = !0
			},
			delayedlaunch : function () {
				var a = Transformer.cam.automatedRotate;
				window.clearTimeout(a.launchTimer);
				a.launchTimer = setTimeout(function () {
						a.rotating || Transformer.cam.automatedRotate.launch()
					}, a.launchDelay)
			},
			stop : function () {
				var a = Transformer.cam.automatedRotate;
				window.clearInterval(a.timer);
				window.clearTimeout(a.launchTimer);
				a.rotating = !1
			},
			toggle : function () {
				var a = Transformer.cam.automatedRotate;
				a.rotating ? a.stop() : a.launch()
			}
		},
		rotate : {
			in_trackball : function () {
				var a = this.canvasX - this.width / 2,
				b = this.canvasY - this.height / 2;
				return Math.sqrt(a * a + b * b) < this.diameter / 2
			},
			init : function () {
				$("body").addClass("noselect");
				Transformer.cam.setupTargetPointUnderMouse(this, !0);
				skim.instances.modeler.cameraMan.prepareRotation(this.canvasX, this.canvasY);
				if (skim.settings.trackballHelper && (this.dynamic_feedback = !1, "trackball" == skim.instances.modeler.cameraMan.rotMode)) {
					var a = new THREE.Geometry;
					a.vertices.length =
						0;
					a.faces.length = 0;
					a.vertices.push(new THREE.Vector3(0.995, 0, 0));
					a.vertices.push(new THREE.Vector3(0.9955, 0, 0));
					for (var b = 1; 19 > b; ++b) {
						var c = b / 20 * Math.PI / 2;
						a.vertices.push(new THREE.Vector3(0.995 * Math.cos(c), 0.995 * Math.sin(c), 0));
						a.vertices.push(new THREE.Vector3(Math.cos(c), Math.sin(c), 0))
					}
					a.vertices.push(new THREE.Vector3(0, 0.995, 0));
					a.vertices.push(new THREE.Vector3(0, 0.9955, 0));
					c = a.vertices.length;
					for (b = 0; b < c; ++b) {
						var d = a.vertices[b];
						a.vertices.push(new THREE.Vector3(-d.x, -d.y, 0))
					}
					for (b = 0; 38 > b; b +=
						2)
						a.faces.push(new THREE.Face3(b, b + 1, b + 3)), a.faces.push(new THREE.Face3(b, b + 3, b + 2));
					for (b = 0; 38 > b; b += 2)
						a.faces.push(new THREE.Face3(c + b, c + b + 1, c + b + 3)), a.faces.push(new THREE.Face3(c + b, c + b + 3, c + b + 2));
					b = new THREE.MeshBasicMaterial({
							color : 10066329
						});
					this.visu_trackball = new THREE.Mesh(a, b);
					this.scaleNode = new THREE.Object3D;
					this.scaleNode.add(this.visu_trackball);
					skim.instances.modeler.overlays.addElement(this.scaleNode);
					this.width = skim.instances.modeler.cameraMan.canvas.width;
					this.height = skim.instances.modeler.cameraMan.canvas.height;
					this.diameter = Math.min(this.height, this.width);
					this.scaleNode.scale.x = this.diameter / this.width;
					this.scaleNode.scale.y = this.diameter / this.height;
					this.unit_x = new THREE.Vector3(1, 0, 0);
					a = -Math.PI / 4;
					this.dynamic_feedback && (b = new THREE.Vector3(this.canvasX - 0.5 * this.width, this.height - this.canvasY - 0.5 * this.height, 0), b.normalize(), c = this.unit_x.dot(b), c = Math.acos(c), d = new THREE.Vector3, d.crossVectors(this.unit_x, b), a = 0 > d.dot(new THREE.Vector3(0, 0, 1)) ? a + -c : a + c);
					this.visu_trackball.rotation.z = a;
					Transformer.cam.rotate.in_trackball.call(this) ?
					$(skim.instances.modeler.canvas).css("cursor", "move") : $(skim.instances.modeler.canvas).css("cursor", "NS-resize")
				}
			},
			run : function () {
				skim.instances.modeler.cameraMan.rotateFromMouse(this.canvasX, this.canvasY);
				if (skim.settings.trackballHelper) {
					if (this.dynamic_feedback && "trackball" == skim.instances.modeler.cameraMan.rotMode) {
						var a = new THREE.Vector3(this.canvasX - 0.5 * this.width, this.height - this.canvasY - 0.5 * this.height, 0);
						a.normalize();
						var b = this.unit_x.dot(a),
						b = Math.acos(b),
						c = new THREE.Vector3;
						c.crossVectors(this.unit_x,
							a);
						0 > c.dot(new THREE.Vector3(0, 0, 1)) ? this.visu_trackball.rotation.z = -b - Math.PI / 4 : this.visu_trackball.rotation.z = b - Math.PI / 4
					}
					Transformer.cam.rotate.in_trackball.call(this) ? $(skim.instances.modeler.canvas).css("cursor", "move") : $(skim.instances.modeler.canvas).css("cursor", "NS-resize")
				}
				Transformer.creation.updateGrid();
				Transformer.cam.centered = !1
			},
			finalize : function () {
				$("body").removeClass("noselect");
				"trackball" == skim.instances.modeler.cameraMan.rotMode && skim.settings.trackballHelper && (skim.instances.modeler.overlays.removeElement(this.scaleNode),
					this.scaleNode.remove(this.visu_trackball), delete this.scaleNode);
				$(skim.instances.modeler.canvas).css("cursor", "default");
				skim.instances.modeler.widgets3DManager.widgets.vertices_widget.render_required = !0
			}
		},
		center : function () {
			skim.instances.skel.getAABB();
			skim.instances.modeler.center_view(1);
			skim.instances.modeler.cameraMan.resetOrientation();
			Transformer.creation.updateGrid();
			Transformer.cam.centered = !0
		},
		turnleft : function () {
			Transformer.cam.centered ? ObjectUtils.rotateObjectAroundAxis(skim.instances.modeler.cameraMan.rotNode,
				new THREE.Vector3(0, 1, 0), -Math.PI / 2) : Transformer.cam.center()
		},
		turnright : function () {
			Transformer.cam.centered ? ObjectUtils.rotateObjectAroundAxis(skim.instances.modeler.cameraMan.rotNode, new THREE.Vector3(0, 1, 0), Math.PI / 2) : Transformer.cam.center()
		},
		turnup : function () {
			Transformer.cam.centered ? ObjectUtils.rotateObjectAroundAxis(skim.instances.modeler.cameraMan.rotNode, new THREE.Vector3(1, 0, 0), -Math.PI / 2) : Transformer.cam.center()
		},
		turndown : function () {
			Transformer.cam.centered ? ObjectUtils.rotateObjectAroundAxis(skim.instances.modeler.cameraMan.rotNode,
				new THREE.Vector3(1, 0, 0), Math.PI / 2) : Transformer.cam.center()
		},
		outputPosition : function () {
			var a = skim.instances.modeler.cameraMan.getPosition();
			console.log("Camera position : " + ("{ rotNode: { px:" + a.rotNode.px.toString() + ",py:" + a.rotNode.py.toString() + ",pz:" + a.rotNode.pz.toString() + ",rx:" + a.rotNode.rx.toString() + ",ry:" + a.rotNode.ry.toString() + ",rz:" + a.rotNode.rz.toString() + "},distToTarget:" + a.distToTarget.toString() + "}"))
		}
	},
	translate : {
		init : function () {},
		finalize : function () {}

	},
	vertex : {
		modeler : skim.instances.modeler,
		createAccordingToSymmetries : function (a, b, c, d, e, f, g) {
			for (var h = skim.engine.getSymmetries(), k = skim.engine.getSymmetries(), l = Object.keys(k), m = 0; m < l.length; ++m) {
				var n = l[m];
				k[n] = k[n] && void 0 !== a[n] && !1 !== a[n]
			}
			skim.engine.setSymmetries(k);
			a = skim.engine.addVertex(b, c, d, e, f, g);
			skim.engine.setSymmetries(h);
			return a
		},
		create : function () {
			$("body").addClass("noselect");
			var a = skim.instances.defaultMaterial;
			void 0 !== this.v_material && (a = this.v_material.clone());
			var b = skim.VolType.Mech;
			void 0 !== this.voltype && null !==
			this.voltype && (b = this.voltype);
			var c = 10;
			if (null !== this.w3dHit.v)
				c = this.w3dHit.v.getThickness();
			else if (null !== this.w3dHit.p)
				for (var d = skim.engine.getPrimitiveById(this.w3dHit.p.id), e = (new THREE.Vector3).subVectors(this.w3dHit.point, d.v[0].getPos()).length() - d.v[0].getThickness(), c = d.v[0].getThickness(), f = 1; f < d.v.length; ++f) {
					var g = (new THREE.Vector3).subVectors(this.w3dHit.point, d.v[f].getPos()).length() - d.v[f].getThickness();
					g < e && (c = d.v[f].getThickness())
				}
			else if (!skim.utils.isEmpty(skim.engine.vars.vertices))
				for (var d =
						skim.engine.vars.vertices, h = Object.keys(d), e = (new THREE.Vector3).subVectors(this.w3dHit.point, d[h[0]].getPos()).length() - d[h[0]].getThickness(), c = d[h[0]].getThickness(), f = 0; f < h.length; ++f)
					g = (new THREE.Vector3).subVectors(this.w3dHit.point, d[h[f]].getPos()).length() - d[h[f]].getThickness(), g < e && (c = d[h[f]].getThickness());
			e = new THREE.Vector3(Math.round(this.w3dHit.point.x), Math.round(this.w3dHit.point.y), Math.round(this.w3dHit.point.z));
			Transformer.creation.magnetPosition(e, c);
			skim.engine.addVertex(e.x,
				e.y, e.z, c, a, b);
			skim.file.saveState();
			skim.engine.update_skeleton();
			skim.engine.update_blobtree()
		},
		thick : {
			init : function () {
				new THREE.Vector3;
				this.v = this.w3dHit.v;
				var a = this.v.getPos();
				this.proj_v_p = (new THREE.Vector3(a.x, a.y, a.z)).project(skim.instances.modeler.cameraMan.getCamera());
				this.last_proj_hit = new THREE.Vector3(2 * (this.canvasX / skim.instances.modeler.canvas.width) - 1, 2 *  - (this.canvasY / skim.instances.modeler.canvas.height) + 1, this.proj_v_p.z);
				this.last_proj_hit.unproject(skim.instances.modeler.cameraMan.getCamera())
			},
			run : function () {
				var a = new THREE.Vector3(2 * (this.canvasX / skim.instances.modeler.canvas.width) - 1, 2 *  - (this.canvasY / skim.instances.modeler.canvas.height) + 1, this.proj_v_p.z);
				a.unproject(skim.instances.modeler.cameraMan.getCamera());
				var b = new THREE.Vector3;
				b.subVectors(a, this.last_proj_hit);
				var c = new THREE.Vector3;
				c.subVectors(this.last_proj_hit, this.v.getPos());
				c.normalize();
				b = b.dot(c);
				b = this.v.get("thickness") + b / skim.instances.modeler.widgets3DManager.widgets.vertices_widget.get("sizeFactor");
				b = Math.abs(b);
				this.last_proj_hit = a;
				null !== this.v && (a = skim.engine.getVertexById(this.v.id), a.setVertexAndPropagate(a.getPos().x, a.getPos().y, a.getPos().z, b, a.getMaterial(), a.getVolType()));
				skim.engine.update_skeleton()
			},
			finalize : function () {
				skim.engine.update_parametrics();
				skim.engine.update_blobtree();
				skim.file.saveState()
			},
			decrease : function () {
				var a = this.hit;
				if (null !== a) {
					var b = skim.engine.getVertexById(a.id),
					c = Math.round(Math.round(a.getThickness()) / 1.1);
					c === Math.round(a.getThickness()) && (c = 1 < a.getThickness() ? c -
							1 : 1);
					b.setVertexAndPropagate(b.getPos().x, b.getPos().y, b.getPos().z, c, b.getMaterial(), b.getVolType())
				}
				skim.file.saveState();
				skim.engine.update_skeleton();
				skim.engine.update_parametrics();
				skim.engine.update_blobtree()
			},
			increase : function () {
				var a = this.hit;
				if (null !== a) {
					var b = skim.engine.getVertexById(a.id),
					c = b.getPos().clone(),
					d = {
						t : Math.round(1.1 * Math.round(a.get("thickness")))
					};
					d.t === Math.round(a.getThickness()) && (d.t += 1);
					Transformer.vertex.thick.vertexThickIncreaseAdjustThickness(this, b, c, d);
					b.setVertexAndPropagate(c.x,
						c.y, c.z, d.t, b.getMaterial(), b.getVolType())
				}
				skim.file.saveState();
				skim.engine.update_skeleton();
				skim.engine.update_parametrics();
				skim.engine.update_blobtree()
			},
			vertexThickIncreaseAdjustThickness : function (a, b, c, d) {}

		},
		translate : {
			init : function () {
				$("body").addClass("noselect");
				this.prevCanvasX = this.canvasX;
				this.prevCanvasY = this.canvasY;
				"vertices_widget" == this.w3dHit.w.get("name") ? this.v = this.w3dHit.v : "primitives_widget" == this.w3dHit.w.get("name") && (this.p = null, skim.utils.assert(!1, "Should not happen, we do not manage primitives !"));
				var a = this.w3dHit.point;
				this.hitZ = (new THREE.Vector3(a.x, a.y, a.z)).project(skim.instances.modeler.cameraMan.getCamera()).z;
				this.prev_hit = new THREE.Vector3(a.x, a.y, a.z);
				this.v_origin = this.v.getPos().clone();
				this.runned = 0;
				Transformer.translate.init()
			},
			run : function () {
				if (this.canvasX !== this.prevCanvasX || this.canvasY !== this.prevCanvasY) {
					var a = new THREE.Vector3(0, 0, this.hitZ);
					a.x = 2 * (this.canvasX / skim.instances.modeler.canvas.width) - 1;
					a.y = 2 *  - (this.canvasY / skim.instances.modeler.canvas.height) + 1;
					a.unproject(skim.instances.modeler.cameraMan.getCamera());
					var a = a.clone(),
					b = new THREE.Vector3;
					b.subVectors(a, this.prev_hit);
					if (void 0 !== this.v) {
						var a = new THREE.Vector3(this.v_origin.x + b.x, this.v_origin.y + b.y, this.v_origin.z + b.z),
						b = {
							t : this.v.get("thickness")
						},
						c = skim.engine.getVertexById(this.v.id);
						Transformer.creation.magnetPosition(a, b.t);
						Transformer.creation.magnetPositionOnGrid(a, b.t);
						Transformer.vertex.translate.vertexTranslateRunAdjustPos(this, c, a, b);
						c.setVertexAndPropagate(a.x, a.y, a.z, b.t, c.getMaterial(), c.getVolType());
						skim.engine.update_skeleton();
						this.runned++;
						this.prevCanvasX = this.canvasX;
						this.prevCanvasY = this.canvasY;
						Transformer.creation.updateOrthoLines(this.v.getPos())
					}
				}
			},
			vertexTranslateRunAdjustPos : function (a, b, c, d) {},
			finalize : function () {
				skim.engine.update_parametrics();
				skim.engine.update_blobtree();
				$("body").removeClass("noselect");
				1 < this.runned && (skim.file.saveState(), Transformer.translate.finalize())
			}
		},
		symGroup : {},
		lastHit : null,
		highlight : function () {
			for (var a = Transformer.selection.vertices, b = Object.keys(a), c = {}, d = 0; d < b.length; ++d)
				skim.engine.getVArrSym(a[b[d]],
					c);
			if (void 0 === a[this.hit.id] && void 0 === c[this.hit.id]) {
				null !== Transformer.vertex.lastHit && Transformer.vertex.lastHit.id !== this.hit.id && Transformer.vertex.unhighlight();
				b = skim.settings.colors.verticesColors.highlight;
				Transformer.vertex.symGroup = skim.engine.getVArrSym(this.hit, Transformer.vertex.symGroup);
				for (var e = Object.keys(Transformer.vertex.symGroup), d = 0; d < e.length; ++d)
					void 0 === a[Transformer.vertex.symGroup[e[d]].id] && void 0 === c[Transformer.vertex.symGroup[e[d]].id] || delete Transformer.vertex.symGroup[e[d]];
				skim.instances.modeler.widgets3DManager.widgets.vertices_widget.setColor(Transformer.vertex.symGroup, skim.settings.colors.verticesColors.symHighlight);
				skim.instances.modeler.widgets3DManager.widgets.vertices_widget.setColor([this.hit], b);
				Transformer.vertex.lastHit = this.hit
			}
		},
		unhighlight : function () {
			skim.instances.modeler.widgets3DManager.widgets.vertices_widget.uncolor([Transformer.vertex.lastHit]);
			skim.instances.modeler.widgets3DManager.widgets.vertices_widget.uncolor(Transformer.vertex.symGroup);
			Transformer.vertex.symGroup = {};
			Transformer.vertex.lastHit = null
		},
		del : function () {
			Object.keys(skim.instances.skel.vertices);
			for (var a = Object.keys(Transformer.selection.vertices), b = 0; b < a.length; ++b) {
				var c = Transformer.selection.vertices[a[b]];
				if (null !== c) {
					var d = skim.engine.getJSON();
					Transformer.selection.unsetVertex(c);
					skim.engine.getVertexById(c.id).destroy();
					0 === Object.keys(skim.engine.vars.vertices).length && 0 === Object.keys(skim.engine.vars.primitives).length ? skim.engine.loadJSON(d) : skim.file.saveState();
					skim.engine.update_skeleton();
					skim.engine.update_parametrics();
					skim.engine.update_blobtree()
				}
			}
		},
		delUnderMouse : function () {
			Transformer.selection.setVertexUnderMouse.call(this);
			Transformer.vertex.del.call(this)
		},
		merge : function () {
			var a = Object.keys(Transformer.selection.vertices);
			skim.utils.assert(1 === a.length, "Error : can only merge if one and only one vertex is selected");
			var a = Transformer.selection.vertices[a[0]],
			b = this.w3dHit.v;
			a == b || skim.engine.hasOwnersRings(a) || (Transformer.selection.unsetAllVertices.call(this),
				skim.engine.merge_vertex(a, b), skim.engine.update_skeleton(), skim.engine.update_parametrics(), skim.engine.update_blobtree(), skim.file.saveState(), Transformer.selection.setVertex.call(this));
			Transformer.creation.updateGrid()
		},
		removeSymmetries : function () {
			skim.engine.removeAllVertexSymmetries();
			skim.engine.update_skeleton();
			skim.engine.update_parametrics();
			skim.engine.update_blobtree();
			skim.file.saveState()
		}
	},
	primitive : {
		symGroup : {},
		lastHit : null,
		highlight : function () {
			for (var a = Transformer.selection.primitives,
				b = Object.keys(a), c = {}, d = 0; d < b.length; ++d)
				skim.engine.getPArrSym(a[b[d]], c);
			if (void 0 === a[this.hit.id] && void 0 === c[this.hit.id]) {
				null !== Transformer.primitive.lastHit && Transformer.primitive.lastHit.id !== this.hit.id && Transformer.primitive.unhighlight();
				b = skim.settings.colors.verticesColors.highlight;
				Transformer.primitive.symGroup = skim.engine.getPArrSym(this.hit, Transformer.primitive.symGroup);
				for (var e = Object.keys(Transformer.primitive.symGroup), d = 0; d < e.length; ++d)
					void 0 === a[Transformer.primitive.symGroup[e[d]].id] &&
					void 0 === c[Transformer.primitive.symGroup[e[d]].id] || delete Transformer.primitive.symGroup[e[d]];
				skim.instances.modeler.widgets3DManager.widgets.primitives_widget.setColor(Transformer.primitive.symGroup, skim.settings.colors.verticesColors.symHighlight);
				skim.instances.modeler.widgets3DManager.widgets.primitives_widget.setColor([this.hit], b);
				Transformer.primitive.lastHit = this.hit
			}
		},
		unhighlight : function () {
			skim.instances.modeler.widgets3DManager.widgets.primitives_widget.uncolor([Transformer.primitive.lastHit]);
			skim.instances.modeler.widgets3DManager.widgets.primitives_widget.uncolor(Transformer.primitive.symGroup);
			Transformer.primitive.symGroup = {};
			Transformer.primitive.lastHit = null
		},
		del : function () {
			for (var a = Object.keys(Transformer.selection.primitives), b = skim.engine.getJSON(), c = 0; c < a.length; ++c) {
				var d = Transformer.selection.primitives[a[c]];
				Transformer.selection.unsetPrimitive(d);
				if (null !== d && void 0 !== d)
					for (c = skim.engine.getPrimitiveById(d.id), d = c.v, c.destroy(), c = 0; c < d.length; c++)
						d[c].hasOwners() || null ===
						d[c] || d[c].destroy()
			}
			0 !== a.length && (0 === Object.keys(skim.engine.vars.vertices).length && 0 === Object.keys(skim.engine.vars.primitives).length ? skim.engine.loadJSON(b) : skim.file.saveState(), skim.engine.update_skeleton(), skim.engine.update_parametrics(), skim.engine.update_blobtree())
		},
		delUnderMouse : function () {
			Transformer.selection.setPrimitiveUnderMouse.call(this);
			Transformer.primitive.del.call(this)
		}
	},
	helper : {
		helperShow : function () {
			skim.instances.modeler.pageInterface.helperShow && skim.instances.modeler.pageInterface.helperShow()
		},
		helperHide : function () {
			skim.instances.modeler.pageInterface.helperHide && skim.instances.modeler.pageInterface.helperHide()
		}
	},
	hierarchy : {
		colors : [6399, 16580352, 65280, 16711860, 10617087, 64767, 16745472],
		anchor : null,
		anchorSyms : {},
		groups : [],
		sym_constrained_groups : [],
		color_groups : function () {
			for (var a = Transformer.hierarchy.groups, b = 0; b < a.length; ++b)
				skim.instances.modeler.widgets3DManager.widgets.vertices_widget.setColor(a[b], Transformer.hierarchy.colors[b % Transformer.hierarchy.colors.length])
		},
		uncolor_groups : function () {
			for (var a =
					Transformer.hierarchy.groups, b = 0; b < a.length; ++b)
				skim.instances.modeler.widgets3DManager.widgets.vertices_widget.uncolor(a[b])
		},
		add_to_group : function (a, b, c) {
			skim.utils.assert(b === Transformer.hierarchy.anchor || void 0 !== c[b.id], "v should be in g");
			if (void 0 === c[a.id] && !skim.engine.hasOwnersRings(a)) {
				for (var d = Object.keys(Transformer.hierarchy.anchorSyms), e = 0; e < d.length; e++)
					if (a.id === Transformer.hierarchy.anchorSyms[d[e]].id)
						return;
				c[a.id] = a;
				d = Object.keys(a.vAdj);
				for (e = 0; e < d.length; ++e) {
					var f = d[e];
					f !=
					b.id && f != Transformer.hierarchy.anchor.id && Transformer.hierarchy.add_to_group(a.vAdj[f].v, a, c)
				}
			}
		},
		isSymConstrained : function (a) {
			skim.utils.assert(a < Object.keys(Transformer.hierarchy.sym_constrained_groups).length, "symmetry test for this group does not exist");
			return Transformer.hierarchy.sym_constrained_groups[a].x || Transformer.hierarchy.sym_constrained_groups[a].y || Transformer.hierarchy.sym_constrained_groups[a].z
		},
		select_anchor : function () {
			Transformer.hierarchy.anchorSyms = {};
			skim.engine.getVArrSym(this.hit,
				Transformer.hierarchy.anchorSyms);
			Transformer.hierarchy.groups.length = 0;
			var a = Transformer.hierarchy.anchor.vAdj,
			b = Object.keys(a),
			c = b.length,
			d = Transformer.hierarchy.groups;
			d.length = 0;
			for (var e = Transformer.hierarchy.sym_constrained_groups.length = 0; e < c; ++e) {
				var f = b[e],
				g = a[f].v;
				if (!skim.engine.hasOwnersRings(g)) {
					for (var h = !1, k = 0; k < d.length; ++k)
						void 0 !== d[k][g.id] && (h = !0);
					h || (g = {}, Transformer.hierarchy.add_to_group(a[f].v, Transformer.hierarchy.anchor, g), d.push(g), Transformer.hierarchy.sym_constrained_groups[d.length -
							1] = skim.engine.getSymConstrainsForGroup(g))
				}
			}
		},
		selected_vertex_as_anchor : function () {
			var a = Object.keys(Transformer.selection.vertices);
			skim.utils.assert(1 === a.length, "Error : selected_vertex_as_anchor can only be called when 1 vertex and no more is selected");
			Transformer.hierarchy.anchor = Transformer.selection.vertices[a[0]];
			Transformer.hierarchy.select_anchor.call(this)
		},
		v_ref : null,
		translate : {
			vertex_init : function () {
				Transformer.hierarchy.v_ref = this.w3dHit.v;
				Transformer.hierarchy.translate.init(Transformer.hierarchy.v_ref,
					this)
			},
			prim_init : function () {
				var a = this.w3dHit.p;
				skim.utils.assert(a.getType() == skim.skel.typeSegment, "Error : for now hierarchy translation on primitive only works on segments");
				var b = null;
				if (a.v[0] === Transformer.hierarchy.anchor)
					b = a.v[1];
				else if (a.v[1] === Transformer.hierarchy.anchor)
					b = a.v[0];
				else {
					b = new THREE.Vector3;
					b.subVectors(a.v[0].getPos(), this.w3dHit.point);
					var c = b.lengthSq();
					b.subVectors(a.v[1].getPos(), this.w3dHit.point);
					b = b.lengthSq() > c ? a.v[0] : a.v[1]
				}
				Transformer.hierarchy.v_ref = b;
				Transformer.hierarchy.translate.init(b,
					this)
			},
			init : function (a, b) {
				$("body").addClass("noselect");
				b.prevCanvasX = b.canvasX;
				b.prevCanvasY = b.canvasY;
				var c = b.w3dHit.point,
				d = (new THREE.Vector3(c.x, c.y, c.z)).project(skim.instances.modeler.cameraMan.getCamera());
				b.hitZ = d.z;
				b.prev_hit = new THREE.Vector3(c.x, c.y, c.z);
				b.v_group = {};
				b.sym_constrained_g = !1;
				d = Transformer.hierarchy.groups;
				for (c = 0; c < d.length; ++c)
					void 0 !== d[c][a.id] && (b.v_group = d[c], b.sym_constrained_g = Transformer.hierarchy.sym_constrained_groups[c]);
				b.v_origins = {};
				for (var d = Object.keys(b.v_group),
					e = d.length, c = 0; c < e; ++c) {
					var f = d[c];
					b.v_origins[f] = b.v_group[f].getPos().clone()
				}
				b.runned = !1;
				Transformer.translate.init()
			},
			run : function () {
				var a = Transformer.hierarchy.v_ref,
				b = new THREE.Vector3(0, 0, this.hitZ);
				b.x = 2 * (this.canvasX / skim.instances.modeler.canvas.width) - 1;
				b.y = 2 *  - (this.canvasY / skim.instances.modeler.canvas.height) + 1;
				b.unproject(skim.instances.modeler.cameraMan.getCamera());
				var b = b.clone(),
				c = new THREE.Vector3;
				c.subVectors(b, this.prev_hit);
				c.x = this.sym_constrained_g.x ? 0 : c.x;
				c.y = this.sym_constrained_g.y ?
					0 : c.y;
				c.z = this.sym_constrained_g.z ? 0 : c.z;
				var b = skim.engine.getVertexById(a.id),
				d = new THREE.Vector3(this.v_origins[b.id].x + c.x, this.v_origins[b.id].y + c.y, this.v_origins[b.id].z + c.z);
				Transformer.creation.magnetPositionOnGrid(d, b.getThickness(), !1);
				b.setVertexAndPropagate(d.x, d.y, d.z, b.getThickness(), b.getMaterial(), b.getVolType());
				c.subVectors(b.getPos(), this.v_origins[b.id]);
				skim.utils.assert(void 0 !== a, "Error : running hierarchy translation with an undefined vertex");
				var e = a.id,
				f = this.v_origins;
				skim.engine.processVertices(function (a) {
					a.id !=
					e && a.setVertexAndPropagate(f[a.id].x + c.x, f[a.id].y + c.y, f[a.id].z + c.z, a.getThickness(), a.getMaterial(), a.getVolType())
				}, this.v_group);
				skim.engine.update_skeleton();
				this.runned = !0;
				this.prevCanvasX = this.canvasX;
				this.prevCanvasY = this.canvasY;
				Transformer.creation.updateOrthoLines(a.getPos())
			},
			finalize : function () {
				skim.engine.update_parametrics();
				skim.engine.update_blobtree();
				$("body").removeClass("noselect");
				Transformer.hierarchy.v_ref = null;
				this.runned && (skim.file.saveState(), Transformer.translate.finalize())
			}
		},
		axis_rotate : {
			incdec : function (a, b) {
				var c = (new THREE.Vector3).subVectors(b.getPos(), Transformer.hierarchy.anchor.getPos()),
				d = Transformer.hierarchy.groups,
				e = {};
				this.sym_constrained_g = null;
				for (var f = 0; f < d.length; ++f)
					void 0 !== d[f][b.id] && (e = d[f], this.sym_constrained_g = Transformer.hierarchy.sym_constrained_groups[f]);
				if (null !== this.sym_constrained_g && !this.sym_constrained_g.x && !this.sym_constrained_g.y && !this.sym_constrained_g.z) {
					var g = b.id,
					h = new THREE.Vector3;
					skim.engine.processVertices(function (b) {
						b.id !=
						g && (h.copy(b.getPos()), h.sub(Transformer.hierarchy.anchor.getPos()), VectorUtils.rotateAroundAxis(h, c, a), h.add(Transformer.hierarchy.anchor.getPos()), b.setVertexAndPropagate(h.x, h.y, h.z, b.getThickness(), b.getMaterial(), b.getVolType()))
					}, e);
					skim.engine.update_skeleton();
					skim.engine.update_parametrics();
					skim.engine.update_blobtree()
				}
			},
			increase : function () {
				Transformer.hierarchy.axis_rotate.incdec(Math.PI / 16, this.w3dHit.v)
			},
			decrease : function () {
				Transformer.hierarchy.axis_rotate.incdec(-Math.PI / 16, this.w3dHit.v)
			}
		},
		rotate : {
			vertex_init : function () {
				Transformer.hierarchy.v_ref = this.w3dHit.v;
				Transformer.hierarchy.rotate.init(Transformer.hierarchy.v_ref, this)
			},
			prim_init : function () {
				var a = this.w3dHit.p;
				skim.utils.assert(a.getType() == skim.skel.typeSegment, "Error : for now hierarchy translation on primitive only works on segments");
				var b = null;
				if (a.v[0] === Transformer.hierarchy.anchor)
					b = a.v[1];
				else if (a.v[1] === Transformer.hierarchy.anchor)
					b = a.v[0];
				else {
					b = new THREE.Vector3;
					b.subVectors(a.v[0].getPos(), this.w3dHit.point);
					var c = b.lengthSq();
					b.subVectors(a.v[1].getPos(), this.w3dHit.point);
					b = b.lengthSq() > c ? a.v[0] : a.v[1]
				}
				Transformer.hierarchy.v_ref = b;
				Transformer.hierarchy.rotate.init(b, this)
			},
			init : function (a, b) {
				$("body").addClass("noselect");
				b.prevCanvasX = b.canvasX;
				b.prevCanvasY = b.canvasY;
				var c = b.w3dHit.point,
				d = (new THREE.Vector3(c.x, c.y, c.z)).project(skim.instances.modeler.cameraMan.getCamera());
				b.hitZ = d.z;
				b.prev_hit = new THREE.Vector3(c.x, c.y, c.z);
				b.v_group = {};
				var e = Transformer.hierarchy.groups;
				b.sym_constrained_g = null;
				for (d = 0; d < e.length; ++d)
					void 0 !== e[d][a.id] && (b.v_group = e[d], b.sym_constrained_g = Transformer.hierarchy.sym_constrained_groups[d]);
				b.v_origins = {};
				for (var e = Object.keys(b.v_group), f = e.length, d = 0; d < f; ++d) {
					var g = e[d];
					b.v_origins[g] = b.v_group[g].getPos().clone()
				}
				b.rot_sphere = {
					c : Transformer.hierarchy.anchor.getPos().clone(),
					r : (new THREE.Vector3).subVectors(Transformer.hierarchy.anchor.getPos(), c).length()
				};
				b.runned = !1
			},
			run : function () {
				var a = Transformer.hierarchy.v_ref;
				if (null !== this.sym_constrained_g && !this.sym_constrained_g.x &&
					!this.sym_constrained_g.y && !this.sym_constrained_g.z) {
					var b = skim.instances.modeler.cameraMan.getRay(this.canvasX, this.canvasY),
					c = skim.geometry.RaySphereIntersect(this.rot_sphere.c, this.rot_sphere.r, b.origin, b.direction),
					d = new THREE.Vector3,
					e = skim.engine.getVertexById(a.id);
					2 == c ? (b = VectorUtils.newLinearVect(b.origin, b.direction, skim.geometry.inter1), d.subVectors(b, this.prev_hit)) : (c = (new THREE.Vector3).subVectors(this.rot_sphere.c, b.origin).dot(b.direction), b = VectorUtils.newLinearVect(b.origin, b.direction,
								c), b = (new THREE.Vector3).subVectors(b, this.rot_sphere.c), b.normalize(), VectorUtils.setLinearVect(d, this.rot_sphere.c, b, this.rot_sphere.r), d.set(d.x - this.prev_hit.x, d.y - this.prev_hit.y, d.z - this.prev_hit.z));
					e.setVertexAndPropagate(this.v_origins[e.id].x + d.x, this.v_origins[e.id].y + d.y, this.v_origins[e.id].z + d.z, e.getThickness(), e.getMaterial(), e.getVolType());
					d = (new THREE.Vector3).subVectors(Transformer.hierarchy.anchor.getPos(), this.v_origins[e.id]);
					b = (new THREE.Vector3).subVectors(Transformer.hierarchy.anchor.getPos(),
						e.getPos());
					d.normalize();
					b.normalize();
					var f = (new THREE.Vector3).crossVectors(d, b),
					e = f.length(),
					d = 0 <= d.dot(b);
					f.normalize();
					var g = d ? Math.asin(e) : Math.PI - Math.asin(e),
					h = a.id,
					k = this.v_origins,
					l = new THREE.Vector3;
					skim.engine.processVertices(function (a) {
						a.id != h && (l.copy(k[a.id]), l.sub(Transformer.hierarchy.anchor.getPos()), VectorUtils.rotateAroundAxis(l, f, g), l.add(Transformer.hierarchy.anchor.getPos()), a.setVertexAndPropagate(l.x, l.y, l.z, a.getThickness(), a.getMaterial(), a.getVolType()))
					}, this.v_group);
					skim.engine.update_skeleton();
					this.runned = !0;
					this.prevCanvasX = this.canvasX;
					this.prevCanvasY = this.canvasY
				}
			},
			finalize : function () {
				skim.engine.update_parametrics();
				skim.engine.update_blobtree();
				$("body").removeClass("noselect");
				this.runned && skim.file.saveState()
			}
		}
	},
	segment : {
		create : function () {
			$("body").addClass("noselect");
			var a = null,
			a = void 0 !== this.v_material ? this.v_material.clone() : this.w3dHit.v.getMaterial().clone(),
			b = null;
			void 0 !== this.p_material && null !== this.p_material && (b = [this.p_material.clone(),
					this.p_material.clone()]);
			var c = skim.VolType.Mech;
			void 0 !== this.voltype && null !== this.voltype && (c = this.voltype);
			this.v = this.w3dHit.v;
			var d = this.w3dHit.point;
			this.hitZ = (new THREE.Vector3(d.x, d.y, d.z)).project(skim.instances.modeler.cameraMan.getCamera()).z;
			a = Transformer.vertex.createAccordingToSymmetries(skim.engine.getVertexSymmetries(skim.engine.getVertexById(this.v.id)), Math.round(d.x), Math.round(d.y), Math.round(d.z), this.v.getThickness(), a, c);
			skim.engine.addSegment(skim.engine.getVertexById(this.v.id),
				a, b, c);
			skim.file.saveState();
			skim.engine.update_skeleton();
			skim.engine.update_parametrics();
			skim.engine.update_blobtree()
		},
		split : function () {
			var a = this.w3dHit.point,
			b = this.w3dHit.p,
			c = b.v[0],
			a = (new THREE.Vector3).subVectors(a, c.get("pos")).dot(b.unit_dir) / b.length;
			Transformer.selection.unsetPrimitive(b);
			skim.engine.splitSegment(skim.engine.getPrimitiveById(b.id), a);
			skim.file.saveState();
			skim.engine.update_skeleton();
			skim.engine.update_parametrics();
			skim.engine.update_blobtree();
			skim.instances.modeler.statemachine.activate_over();
			skim.instances.modeler.statemachine.activate_over()
		}
	},
	triangle : {
		create : function () {
			$("body").addClass("noselect");
			void 0 !== this.v_material ? this.v_material.clone() : this.w3dHit.v.getMaterial().clone();
			var a = null;
			void 0 !== this.p_material && null !== this.p_material && (a = [this.p_material.clone(), this.p_material.clone(), this.p_material.clone()]);
			var b = skim.VolType.Mech;
			void 0 !== this.voltype && null !== this.voltype && (b = this.voltype);
			this.v = this.w3dHit.v;
			var c = this.w3dHit.point,
			d = skim.instances.modeler.cameraMan.getCameraWorldNormal(),
			e = VectorUtils.newLinearVect(c, d, 0.5 * this.v.getThickness()),
			c = VectorUtils.newLinearVect(c, d, 0.5 * -this.v.getThickness()),
			e = Transformer.vertex.createAccordingToSymmetries(skim.engine.getVertexSymmetries(skim.engine.getVertexById(this.v.id)), Math.round(e.x), Math.round(e.y), Math.round(e.z), this.v.getThickness(), this.v_material, b),
			c = Transformer.vertex.createAccordingToSymmetries(skim.engine.getVertexSymmetries(skim.engine.getVertexById(this.v.id)), Math.round(c.x), Math.round(c.y), Math.round(c.z), this.v.getThickness(),
					this.v_material, b);
			skim.engine.addTriangle(skim.engine.getVertexById(this.v.id), e, c, a, b);
			skim.file.saveState();
			skim.engine.update_skeleton();
			skim.engine.update_parametrics();
			skim.engine.update_blobtree()
		},
		split : function () {
			var a = this.w3dHit.point,
			b = this.w3dHit.p;
			Transformer.selection.unsetPrimitive(b);
			var c = skim.engine.getPrimitiveById(b.id),
			d = [c.v[0], c.v[1], c.v[2]],
			e = (new THREE.Vector3).subVectors(b.v[1].getPos(), b.v[0].getPos()),
			f = (new THREE.Vector3).subVectors(b.v[2].getPos(), b.v[0].getPos()),
			b =
				skim.triangleUtils.getUVCoord(e, f, b.v[0].getPos(), a),
			c = skim.engine.splitTriangle(c, b.u, b.v);
			if (c.edge !== skim.engine.TriEdge.E_NONE) {
				for (var d = [d[c.edge], d[(c.edge + 1) % 3]], g = d[0].getOwnersTriangles(), h = [], k = Object.keys(g), l = 0; l < k.length; ++l) {
					var m = g[k[l]];
					m.hasVertDef(d[1]) && (e.subVectors(m.v[1].getPos(), m.v[0].getPos()), f.subVectors(m.v[2].getPos(), m.v[0].getPos()), b = skim.triangleUtils.getUVCoord(e, f, m.v[0].getPos(), a), b = skim.engine.splitTriangle(m, b.u, b.v), h.push(b.vnew), skim.utils.assert(null !==
							b.edge, "Error : split should have resulted in an edge split, not a triangle split"))
				}
				for (l = 0; l < h.length; ++l)
					skim.engine.mergeVertexDef(h[l], c.vnew)
			}
			skim.file.saveState();
			skim.engine.update_skeleton();
			skim.engine.update_parametrics();
			skim.engine.update_blobtree();
			skim.instances.modeler.statemachine.activate_over();
			skim.instances.modeler.statemachine.activate_over()
		}
	},
	ring : {
		split : function () {
			var a = skim.geometry.GetXAngleFromPoint(this.w3dHit.point);
			Transformer.ring.splitRing(this.w3dHit.p, a);
			skim.file.saveState();
			skim.engine.update_skeleton();
			skim.engine.update_parametrics();
			skim.engine.update_blobtree();
			skim.instances.modeler.statemachine.activate_over();
			skim.instances.modeler.statemachine.activate_over()
		},
		splitRing : function (a, b) {
			skim.engine.splitRing(a, b)
		}
	},
	prim : {
		translate : {
			init : function () {
				$("body").addClass("noselect");
				this.prevCanvasX = this.canvasX;
				this.prevCanvasY = this.canvasY;
				this.p = this.w3dHit.p;
				var a = this.w3dHit.point;
				this.hitZ = (new THREE.Vector3(a.x, a.y, a.z)).project(skim.instances.modeler.cameraMan.getCamera()).z;
				this.prev_hit = new THREE.Vector3(a.x, a.y, a.z);
				for (var a = {}, b = 0; b < this.p.v.length; ++b)
					a[this.p.v[b].id] = this.p.v[b];
				this.sym_ctr = skim.engine.getSymConstrainsForGroup(a);
				this.v_origins = {};
				for (a = 0; a < this.p.v.length; ++a)
					b = skim.engine.getVertexById(this.p.v[a].id).getMaster(), this.v_origins[b.id] = {
						pos : b.getPos().clone(),
						thick : b.getThickness()
					};
				this.runned = !1;
				Transformer.translate.init()
			},
			run : function () {
				var a = new THREE.Vector3(0, 0, this.hitZ);
				a.x = 2 * (this.canvasX / skim.instances.modeler.canvas.width) - 1;
				a.y =
					2 *  - (this.canvasY / skim.instances.modeler.canvas.height) + 1;
				a.unproject(skim.instances.modeler.cameraMan.getCamera());
				var b = a.clone(),
				a = new THREE.Vector3;
				a.subVectors(b, this.prev_hit);
				Transformer.prim.translate.adjustPrimTranslation(this, a);
				this.sym_ctr.x && (a.x = 0);
				this.sym_ctr.y && (a.y = 0);
				this.sym_ctr.z && (a.z = 0);
				if (void 0 !== this.p) {
					skim.engine.getPrimitiveById(this.p.id);
					for (var b = Object.keys(this.v_origins), c = 0; c < b.length; c++) {
						var d = skim.engine.getVertexById(b[c]),
						e = new THREE.Vector3(this.v_origins[b[c]].pos.x +
								a.x, this.v_origins[b[c]].pos.y + a.y, this.v_origins[b[c]].pos.z + a.z),
						f = {
							t : this.v_origins[b[c]].thick
						};
						Transformer.prim.translate.magnetOnAxis(this, d, e, f);
						d.setVertexAndPropagate(e.x, e.y, e.z, f.t, d.getMaterial(), d.getVolType())
					}
				}
				skim.engine.update_skeleton();
				this.runned = !0;
				this.prevCanvasX = this.canvasX;
				this.prevCanvasY = this.canvasY
			},
			adjustPrimTranslation : function (a, b) {},
			magnetOnAxis : function (a, b, c, d) {},
			finalize : function () {
				skim.engine.update_parametrics();
				skim.engine.update_blobtree();
				$("body").removeClass("noselect");
				this.runned && (skim.file.saveState(), Transformer.translate.finalize())
			}
		}
	},
	creation : {
		x_symmetry_activate_toggle : function () {
			skim.engine.setSymmetries({
				x : !skim.engine.symmetry.x
			})
		},
		y_symmetry_activate_toggle : function () {
			skim.engine.setSymmetries({
				y : !skim.engine.symmetry.y
			})
		},
		z_symmetry_activate_toggle : function () {
			skim.engine.setSymmetries({
				z : !skim.engine.symmetry.z
			})
		},
		sym_toggle_v_colored : {
			x : {},
			y : {},
			z : {}

		},
		sym_show_toggle_v_hl : function (a) {
			0 !== Object.keys(Transformer.creation.sym_toggle_v_colored[a]).length ?
			(skim.instances.modeler.widgets3DManager.widgets.vertices_widget.uncolor(Transformer.creation.sym_toggle_v_colored[a]), Transformer.creation.sym_toggle_v_colored[a] = {}) : (skim.engine.processVertices(function (b) {
					void 0 !== skim.engine.getVertexSymmetries(b)[a] && (Transformer.creation.sym_toggle_v_colored[a][b.id] = b.getReactor())
				}), skim.instances.modeler.widgets3DManager.widgets.vertices_widget.setColor(Transformer.creation.sym_toggle_v_colored[a], skim.settings.colors.verticesColors.highlight))
		},
		x_symmetry_show_toggle : function () {
			skim.instances.modeler.sceneManager.toggleSymPlaneXVisible();
			Transformer.creation.sym_show_toggle_v_hl("x")
		},
		y_symmetry_show_toggle : function () {
			skim.instances.modeler.sceneManager.toggleSymPlaneYVisible();
			Transformer.creation.sym_show_toggle_v_hl("y")
		},
		z_symmetry_show_toggle : function () {
			skim.instances.modeler.sceneManager.toggleSymPlaneZVisible();
			Transformer.creation.sym_show_toggle_v_hl("z")
		},
		rotateAllAroundX : function () {
			var a = skim.instances.modeler.meshManager.getBlobtrees()[0];
			if (a.valid_aabb) {
				var b = a.aabb.getCenter();
				skim.engine.processVertices(function (a) {
					var d =
						a.getPos().clone();
					a.setVertexAndPropagate(d.x, d.y - b.y, d.z - b.z, a.getThickness(), a.getMaterial(), a.getVolType())
				}, null)
			}
			skim.engine.processVertices(function (a) {
				var b = a.getPos().clone(),
				e = (new THREE.Matrix4).makeRotationX(Math.PI / 30);
				b.applyMatrix4(e);
				a.setVertexAndPropagate(b.x, b.y, b.z, a.getThickness(), a.getMaterial(), a.getVolType())
			}, null);
			skim.engine.update_skeleton();
			skim.engine.update_parametrics();
			skim.engine.update_blobtree()
		},
		mode : {
			el : skim.skel.typeSegment,
			type : skim.VolType.Orga,
			p_material : null,
			v_material : new skim.Material(null, null, null),
			voltype : skim.VolType.Mech,
			magnet : {
				threshold : 0.33,
				axis : ["x", "y", "z"]
			},
			grid : {
				size : 6,
				active : !1,
				meshes : [],
				infos : [],
				center_idx : {
					x : 0,
					y : 0,
					z : 0
				},
				ortho_lines : {}

			}
		},
		setGridActive : function (a) {
			if ((Transformer.creation.mode.grid.active = a) && 0 === Transformer.creation.mode.grid.meshes.length) {
				a = new THREE.LineBasicMaterial({
						color : 15658734
					});
				for (var b = null, c = 0; 5 > c; ++c) {
					for (var d = Math.pow(Transformer.creation.mode.grid.size / 2, c), e = d * Transformer.creation.mode.grid.size, f = new THREE.Geometry,
						g = -e; g <= e; g += 1 * d)
						b = new THREE.Vector3, b.z = 0, b.x = -e, b.y = g, f.vertices.push(b), b = b.clone(), b.x = e, f.vertices.push(b), b = b.clone(), b.x = g, b.y = -e, f.vertices.push(b), b = b.clone(), b.y = e, f.vertices.push(b);
					Transformer.creation.mode.grid.meshes.push(new THREE.Line(f, a, THREE.LinePieces));
					Transformer.creation.mode.grid.infos.push({
						size : e,
						step : d
					});
					skim.instances.modeler.sceneManager.addNeutralMesh("grid_lvl_" + c, Transformer.creation.mode.grid.meshes[c])
				}
				d = ["x", "y", "z"];
				for (c = 0; c < d.length; ++c)
					f = new THREE.Geometry, b =
						new THREE.Vector3, b[d[c]] = -1E4, f.vertices.push(b), b = new THREE.Vector3, b[d[c]] = 1E4, f.vertices.push(b), Transformer.creation.mode.grid.ortho_lines[d[c]] = new THREE.Line(f, a, THREE.LinePieces), skim.instances.modeler.sceneManager.addNeutralMesh("grid_lvl_ortho_" + d[c], Transformer.creation.mode.grid.ortho_lines[d[c]])
			}
			Transformer.creation.setGridVisibilityAndOrientation()
		},
		setGridVisibilityAndOrientation : function () {
			var a = ["x", "y", "z"],
			b = {
				x : new THREE.Euler(0, Math.PI / 2, 0),
				y : new THREE.Euler(Math.PI / 2, 0, 0),
				z : new THREE.Euler(0,
					0, 0)
			},
			c = new THREE.Vector3,
			d = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)],
			e = Transformer.creation.mode.grid,
			f = Object.keys(Transformer.selection.vertices);
			if (0 !== f.length && e.active) {
				var f = Transformer.selection.vertices[f[0]],
				g = (new THREE.Vector3).subVectors(skim.instances.modeler.cameraMan.getTarget(), skim.instances.modeler.cameraMan.getCameraWorldPosition());
				g.normalize();
				for (var h = "z", k = Math.abs(g.dot(d[2])), l = 0; 2 > l; ++l) {
					var m = Math.abs(g.dot(d[l]));
					m > k && (k = m, h = a[l])
				}
				for (d =
						0; d < e.meshes.length; ++d) {
					skim.instances.modeler.sceneManager.setVisible(e.meshes[d], !0);
					e.meshes[d].rotation.copy(b[h]);
					g = e.meshes[d];
					k = Math.pow(Transformer.creation.mode.grid.size / 2, Math.min(d + 1, e.meshes.length - 1));
					c.copy(f.getPos());
					for (l = 0; 3 > l; l++)
						a[l] !== h ? c[a[l]] = Math.round(c[a[l]] / k) * k : c[h] = Math.round(c[h]);
					g.position.copy(c)
				}
				for (l = 0; l < a.length; ++l)
					a[l] === h ? (skim.instances.modeler.sceneManager.setVisible(e.ortho_lines[a[l]], !0), e.ortho_lines[a[l]].position.copy(f.getPos())) : skim.instances.modeler.sceneManager.setVisible(e.ortho_lines[a[l]],
						!1)
			} else {
				for (l = 0; l < e.meshes.length; ++l)
					skim.instances.modeler.sceneManager.setVisible(e.meshes[l], !1);
				f = Object.keys(e.ortho_lines);
				for (l = 0; l < f.length; ++l)
					skim.instances.modeler.sceneManager.setVisible(e.ortho_lines[f[l]], !1)
			}
		},
		getVisibleGridPlane : function () {
			var a = Transformer.creation.mode.grid;
			return a.meshes[0].rotation.y === Math.PI / 2 ? "x" : a.meshes[0].rotation.x === Math.PI / 2 ? "y" : "z"
		},
		updateGrid : function () {
			Transformer.creation.setGridVisibilityAndOrientation()
		},
		updateOrthoLines : function (a) {
			var b = ["x",
				"y", "z"],
			c = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)],
			d = Transformer.creation.mode.grid,
			e = Object.keys(Transformer.selection.vertices);
			if (0 !== e.length && d.active) {
				e = (new THREE.Vector3).subVectors(skim.instances.modeler.cameraMan.getTarget(), skim.instances.modeler.cameraMan.getCameraWorldPosition());
				e.normalize();
				for (var f = "z", g = Math.abs(e.dot(c[2])), h = 0; 2 > h; ++h) {
					var k = Math.abs(e.dot(c[h]));
					k > g && (g = k, f = b[h])
				}
				for (h = 0; h < b.length; ++h)
					b[h] === f ? (skim.instances.modeler.sceneManager.setVisible(d.ortho_lines[b[h]],
							!0), d.ortho_lines[b[h]].position.copy(a)) : skim.instances.modeler.sceneManager.setVisible(d.ortho_lines[b[h]], !1)
			} else
				for (e = Object.keys(d.ortho_lines), h = 0; h < e.length; ++h)
					skim.instances.modeler.sceneManager.setVisible(d.ortho_lines[e[h]], !1)
		},
		magnetPositionOnGrid : function () {
			var a = {
				x : new THREE.Vector3(1, 0, 0),
				y : new THREE.Vector3(0, 1, 0),
				z : new THREE.Vector3(0, 0, 1)
			},
			b = new THREE.Vector3;
			return function (c, d, e) {
				var f = void 0 !== e ? e : !0;
				e = Transformer.creation.mode.grid;
				if (e.active) {
					var g = Transformer.creation.getVisibleGridPlane();
					if (f) {
						var f = (new THREE.Vector3).subVectors(c, skim.instances.modeler.cameraMan.getCameraWorldPosition()),
						h = (new THREE.Vector3).subVectors(e.meshes[0].position, c).dot(a[g]),
						h = 1E-4 < Math.abs(f.dot(a[g])) ? h / f.dot(a[g]) : 0;
						c.set(c.x + h * f.x, c.y + h * f.y, c.z + h * f.z)
					}
					f = null;
					switch (g) {
					case "x":
						f = ["y", "z"];
						break;
					case "y":
						f = ["z", "x"];
						break;
					case "z":
						f = ["x", "y"];
						break;
					default:
						skim.utils.assert(!1, "Error : unrecognized axis")
					}
					for (h = 0; h < e.meshes.length; ++h) {
						var k = e.infos[h].size,
						l = e.infos[h].step;
						if (d < e.infos[h].size /
							2 && (c[f[0]] >= e.meshes[h].position[f[0]] - k && c[f[0]] <= e.meshes[h].position[f[0]] + k && c[f[1]] >= e.meshes[h].position[f[1]] - k && c[f[1]] <= e.meshes[h].position[f[1]] + k) && (b[f[0]] = Math.round(c[f[0]] / l) * l, b[f[1]] = Math.round(c[f[1]] / l) * l, b[g] = c[g], (new THREE.Vector3).subVectors(b, c).length() < d)) {
							c.copy(b);
							break
						}
					}
				}
			}
		}
		(),
		setModeElement : function (a) {
			skim.utils.assert(a === skim.skel.typeSegment || a === skim.skel.typeTriangle || a === skim.skel.typeVertex, "Error : unmanaged element");
			Transformer.creation.mode.el = a
		},
		setModePMaterial : function (a,
			b, c) {
			null === a ? Transformer.creation.mode.p_material = null : null === Transformer.creation.mode.p_material ? Transformer.creation.mode.p_material = new skim.Material(a, b, c) : Transformer.creation.mode.p_material.set(a, b, c)
		},
		getModePMaterial : function () {
			return Transformer.creation.mode.p_material
		},
		getModeVMaterial : function () {
			return Transformer.creation.mode.v_material
		},
		setModeVolType : function (a) {
			Transformer.creation.mode.voltype = a
		},
		getModeVolType : function (a) {
			return Transformer.creation.mode.voltype
		},
		setModeVMaterial : function (a,
			b, c) {
			Transformer.creation.mode.v_material.set(a, b, c)
		},
		createAccordingToMode : function () {
			this.v_material = Transformer.creation.mode.v_material;
			this.p_material = Transformer.creation.mode.p_material;
			this.voltype = Transformer.creation.mode.voltype;
			switch (Transformer.creation.mode.el) {
			case skim.skel.typeSegment:
				Transformer.segment.create.call(this);
				break;
			case skim.skel.typeTriangle:
				Transformer.triangle.create.call(this);
				break;
			case skim.skel.typeVertex:
				Transformer.vertex.create.call(this);
				break;
			default:
				skim.utils.assert(!1,
					"Error : unknown mode element")
			}
		},
		magnetPosition : function (a, b) {
			for (var c = Transformer.creation.mode.magnet.axis, d = Transformer.creation.mode.magnet.threshold, e = 0; e < c.length; ++e)
				Math.abs(a[c[e]]) < b * d && (a[c[e]] = 0);
			return a
		}
	},
	step : {
		prev : function () {
			skim.file.restoreLastState()
		},
		next : function () {
			skim.file.restoreNextState()
		}
	},
	debug : {
		toggleDiffSurfaceEvalGPUvsCPU : function () {
			skim.instances.modeler.isDebugEval = !skim.instances.modeler.isDebugEval;
			skim.instances.modeler.setRenderFunctionHook(!1);
			skim.instances.modeler.require_render =
				!0
		},
		increaseZDepth : function () {
			skim.instances.modeler.alterDepthDebug(0.5)
		},
		decreaseZDepth : function () {
			skim.instances.modeler.alterDepthDebug(-0.5)
		}
	},
	render : {
		modeler : skim.instances.modeler,
		switchRootBlend : function () {
			var a = skim.instances.modeler.meshManager.getBlobtrees()[0].ricci_n,
			a = a * a;
			500 < a ? a = 1 : 1 == a && (a = 1.1);
			skim.instances.modeler.meshManager.getBlobtrees()[0].setRicciN(a)
		},
		updateBlobtree : function () {
			skim.engine.update_parametrics();
			skim.engine.update_blobtree()
		},
		octreeCellPolygonize : function () {
			skim.instances.modeler.octree_nets.cellPolygonize()
		},
		octreeCellPolygonize128 : function () {
			console.log("Display octree cell of size 128");
			skim.instances.modeler.octree_nets.cellPolygonize(128)
		},
		octreeCellPolygonize64 : function () {
			console.log("Display octree cell of size 64");
			skim.instances.modeler.octree_nets.cellPolygonize(64)
		},
		octreeCellPolygonize32 : function () {
			console.log("Display octree cell of size 32");
			skim.instances.modeler.octree_nets.cellPolygonize(32)
		},
		octreeCellPolygonize16 : function () {
			console.log("Display octree cell of size 16");
			skim.instances.modeler.octree_nets.cellPolygonize(16)
		},
		octreeCellPolygonize8 : function () {
			console.log("Display octree cell of size 8");
			skim.instances.modeler.octree_nets.cellPolygonize(8)
		},
		octreeCellPolygonize4 : function () {
			console.log("Display octree cell of size 4");
			skim.instances.modeler.octree_nets.cellPolygonize(4)
		},
		octreeCellPolygonize2 : function () {
			console.log("Display octree cell of size 2");
			skim.instances.modeler.octree_nets.cellPolygonize(2)
		},
		octreeCellPolygonize1 : function () {
			console.log("Display octree cell of size 1");
			skim.instances.modeler.octree_nets.cellPolygonize(1)
		},
		octreePolygonize : function () {
			skim.instances.modeler.octree_nets.polygonize()
		},
		octreeSwitchWireframe : function () {
			skim.instances.modeler.sceneManager.setWireframe(!skim.instances.modeler.sceneManager.isWireframe)
		},
		octree_show_surface : function () {
			skim.instances.modeler.sceneManager.setShowSurface(!0)
		},
		octree_hide_surface : function () {
			skim.instances.modeler.sceneManager.setShowSurface(!1)
		},
		octreeSubdivide : function () {
			this.epsilon_octree *= 0.5;
			this.modeler.octree_nets.subdivide(this.epsilon_octree)
		},
		octreeFitGeom : function () {
			skim.instances.modeler.octree_nets.fitGeometry()
		}
	}
};
var TransitionDef, StateDef, StateMachineDef;
function get_caller(a, b) {
	for (var c = a, d = b.split("."), e = 0; e < d.length; e++)
		c = c[d[e]];
	return c
}
var MouseHandler = function () {
	this.canvasY = this.canvasX = 0;
	this.on = "background";
	this.w3dHit = null;
	this.onSelection = this.onPrim = this.onSkel = !1;
	this.hit = this.last_hit = null
};
MouseHandler.prototype.hitover = function () {
	return null !== this.hit && null !== this.last_hit ? this.hit.id !== this.last_hit.id : this.hit !== this.last_hit
};
MouseHandler.prototype.is_canvas_event = function (a) {
	return "mousemove" == a || -1 == a.indexOf("scroll") && -1 != a.indexOf("up") ? !1 : !0
};
MouseHandler.prototype.update = function (a) {
	this.last_hit = this.hit;
	this.canvasX = a.canvasX;
	this.canvasY = a.canvasY;
	a = skim.instances.modeler.widgets3DManager.computeHit(this.canvasX, this.canvasY);
	this.hit = null;
	this.on = "background";
	this.onPrim = this.onSkel = !1;
	a.hit && (this.onSkel = !0, a.v ? (this.on = "vertex", this.hit = a.v, this.onSelection = void 0 !== Transformer.selection.vertices[a.v.id]) : a.p && (this.on = a.p.type, this.hit = a.p, this.onPrim = !0, this.onSelection = void 0 !== Transformer.selection.primitives[a.p.id]));
	this.w3dHit =
		a
};
var Mouse = new MouseHandler;
function Event_handler() {
	this.helpmsg = this.callback = this.dest = this.type = this.helper = "";
	this.after = this.before = null;
	this.controls = [];
	this.init = function (a, b) {
		console.log('create event "' + a + '": helper=' + b.helper + ", control=" + b.control);
		this.helper = b.hasOwnProperty("helper") ? b.helper : "";
		if (b.control)
			for (var c = b.control, d = 0; d < c.length; d++) {
				var e = c[d].split(" on ");
				this.controls.push([e[0], 1 < e.length ? e[1] : ""])
			}
		b.helpmsg && (this.helpmsg = b.helpmsg);
		b.callback && (this.callback = b.callback);
		b.before && (this.before =
				b.before);
		b.after && (this.after = b.after);
		if (-1 != a.indexOf("->"))
			d = a.substr(a.indexOf("->") + 2), this.dest = skim.utils.ltrim(d), this.type = "transition";
		else {
			if ("enter" == a) {
				this.type = "enter";
				this.dest = b;
				return
			}
			if ("exit" == a) {
				this.type = "exit";
				this.dest = b;
				return
			}
			this.dest = a;
			this.type = "function"
		}
		c = skim.instances.modeler.statemachine;
		for (d = 0; d < this.controls.length; d++)
			Mouse.is_canvas_event(this.controls[d][0]) ? (console.log("bind MCV event " + this.controls[d][0]), e = skim.instances.modeler.viewManager.mainCanvasView) :
			(console.log("bind MDV event " + this.controls[d][0]), e = skim.instances.modeler.viewManager.mainDocView), e.off(this.controls[d][0], c.dispatch_event, c), e.on(this.controls[d][0], c.dispatch_event, c)
	}
}
function State() {
	this.helper = this.name = "";
	this.evts = [];
	this.enter_func = [];
	this.exit_func = [];
	this.context = {};
	this.ctrlhelper = "";
	this.substatemachine = [];
	this.debug_context = function () {
		var a = this.context;
		console.log("debugging context of state " + this.name);
		for (var b in a)
			"length" !== b && a.hasOwnProperty(b) && console.log("var " + b + " : " + a[b])
	};
	this.init = function (a, b) {
		this.name = a;
		console.log("init state: " + a);
		this.add_def(b)
	};
	this.enter = function (a) {
		for (var b = 0; b < this.substatemachine.length; ++b)
			this.substatemachine[b].reset();
		for (b = 0; b < this.enter_func.length; b++)
			this.enter_func[b].call(this.context, a)
	};
	this.exit = function (a) {
		for (var b = 0; b < this.substatemachine.length; ++b)
			this.substatemachine[b].reset();
		for (b = 0; b < this.exit_func.length; b++)
			this.exit_func[b].call(this.context, a)
	};
	this.add_def = function (a) {
		for (var b in a)
			if ("length" !== b && a.hasOwnProperty(b))
				if ("helper" == b)
					this.helper = skim.utils.ltrim(a[b]);
				else if ("sub-sm" == b)
					for (var c = 0; c < a[b].length; ++c)
						console.log("state " + this.name + " adding substatemachine"), this.substatemachine.push(new StateMachine(a[b][c])),
						this.substatemachine[this.substatemachine.length - 1].init(!1);
				else if ("ctrlhelper" == b)
					this.ctrlhelper = skim.utils.ltrim(a[b]);
				else {
					var d = new Event_handler;
					d.init(b, a[b]);
					if ("enter" == d.type)
						for (c = 0; c < d.dest.length; c++)
							this.enter_func.push(get_caller(Transformer, d.dest[c]));
					else if ("exit" == d.type)
						for (c = 0; c < d.dest.length; c++)
							this.exit_func.push(get_caller(Transformer, d.dest[c]));
					else
						"function" != d.type && "transition" != d.type || this.evts.push(d)
				}
	};
	this.dispatch = function (a, b) {
		if (0 !== this.substatemachine.length)
			for (var c =
					0; c < this.substatemachine.length; ++c) {
				var d = this.substatemachine[c].dispatch_event(b);
				if ("none" != d)
					return ["subsm", d, null, null, null]
			}
		for (c = 0; c < this.evts.length; c++)
			for (var d = this.evts[c], e = 0; e < d.controls.length; e++)
				if (d.controls[e][0] == a) {
					var f = d.controls[e][1];
					if ("" === f || f == Mouse.on || f == Mouse.on + ":selected" && Mouse.onSelection || f == Mouse.on + ":unselected" && !Mouse.onSelection || "!" == f[0] && f.substring(1) != Mouse.on || "out" == f && Mouse.hitover())
						return [d.type, d.dest, d.callback, d.before, d.after]
				}
		return ["none",
			!1]
	}
}
function StateMachine(a) {
	_.extend(this, Backbone.Events);
	this.initialize = function () {
		_.bindAll(this)
	};
	this.def = a;
	this.current_state = null;
	this.events = [];
	this.states = {};
	this.canvasY = this.canvasX = 0;
	this.main = !1;
	this.init = function (a) {
		console.log("init state machine !");
		var c = this.def.states;
		this.main = a;
		for (var d in c)
			"length" !== d && c.hasOwnProperty(d) && (a = c[d], "all" != d && (this.states[d] = new State, this.states[d].init(d, a)));
		for (d in this.states)
			"length" !== d && this.states.hasOwnProperty(d) && this.states[d].add_def(c.all);
		this.reset();
		this.update_helper()
	};
	this.reset = function () {
		this.canvasY = this.canvasX = 0;
		this.current_state && this.current_state.exit();
		this.current_state = this.states[this.def.start];
		this.current_state.enter({
			canvasX : this.canvasX,
			canvasY : this.canvasY
		})
	};
	this.update_context = function (a, c) {
		for (var d in c)
			"length" !== d && c.hasOwnProperty(d) && (a.context[d] = c[d])
	};
	this.subsm_concat_evts = function (a, c) {
		c.push.apply(c, a.current_state.evts);
		for (var d = a.current_state.substatemachine, e = 0; e < d.length; ++e)
			this.subsm_concat_evts(d[e],
				c)
	};
	this.update_helper = function () {
		var a = this.current_state.helper;
		if ("none" == this.current_state.ctrlhelper)
			skim.instances.modeler.pageInterface.helperUpdate(a, {});
		else if (skim.instances.modeler.pageInterface.helperUpdate(a, null), this.main && "inherit" != this.current_state.ctrlhelper) {
			var c = [];
			this.subsm_concat_evts(this, c);
			for (var d = {}, e = 0; e < c.length; e++) {
				var f = c[e];
				if (void 0 !== f.helper && "" !== f.helper) {
					var g = f.helper[0];
					g in d || (d[g] = []);
					d[g].push(f)
				}
			}
			skim.instances.modeler.pageInterface && skim.instances.modeler.pageInterface.helperUpdate(a,
				d)
		}
	};
	this.last_mousemove_time = (new Date).getTime();
	this.last_mousemove = this.next_time_event = null;
	this.activate_over = function () {
		for (var a = 0; a < this.current_state.substatemachine.length; a++)
			this.current_state.substatemachine[a].activate_over();
		skim.instances.modeler.statemachine.dispatch_event({
			canvasX : Mouse.canvasX,
			canvasY : Mouse.canvasY,
			complexType : "mousemove",
			preventDefault : function () {},
			stopPropagation : function () {}

		})
	};
	this.dispatch_event = function (a) {
		var c = a.complexType;
		this.main && "mousemove" == c && Mouse.update(a);
		var d = !1,
		d = this.current_state.dispatch(c, a);
		if ("subsm" == d[0])
			d = d[1], "transition" == d && this.update_helper();
		else if ("none" == d[0])
			d = "none";
		else if ("transition" == d[0])
			a.preventDefault(), console.log("change current state from " + this.current_state.name + " to " + d[1] + " on event " + c + " on " + Mouse.on), c = {
				canvasX : Mouse.canvasX,
				canvasY : Mouse.canvasY,
				hit : Mouse.hit,
				w3dHit : Mouse.w3dHit,
				on : Mouse.on,
				onSkel : Mouse.onSkel,
				onPrim : Mouse.onPrim,
				onSelection : Mouse.onSelection
			},
		this.update_context(this.current_state, c),
		d[3] &&
		get_caller(Transformer, d[3]).call(this.current_state.context),
		this.current_state.exit(c),
		this.current_state.context = {},
		this.current_state = this.states[d[1]],
		this.update_context(this.current_state, c),
		this.current_state.enter(c),
		d[4] && get_caller(Transformer, d[4]).call(this.current_state.context),
		"mousemove" != a.complexType && this.activate_over(),
		this.update_helper(),
		d = "transition";
		else if ("function" == d[0]) {
			a.preventDefault();
			c = this.current_state.context;
			c.canvasX = Mouse.canvasX;
			c.canvasY = Mouse.canvasY;
			c.hit = Mouse.hit;
			c.w3dHit = Mouse.w3dHit;
			c.on = Mouse.on;
			c.onSkel = Mouse.onSkel;
			c.onPrim = Mouse.onPrim;
			c.onSelection = Mouse.onSelection;
			var e = get_caller(Transformer, d[1]);
			e.call(c, a);
			"mousemove" != a.complexType && this.activate_over();
			"" !== d[2] && (e = get_caller(window, d[2]), e.call(c, a));
			d = "function"
		} else
			d = d[0];
		Mouse.is_canvas_event(a.complexType) && skim.instances.modeler.setCanvasFocus();
		"none" != d && a.stopPropagation && a.stopPropagation();
		return d
	}
};
skim.widgets3d.Widgets3DManager = function () {
	_.extend(this, Backbone.Events);
	this.bg_widget = {};
	_.extend(this.bg_widget, Backbone.Events);
	this.widgets = {};
	this.last_w3d_under = null;
	this.addWidget = function (a) {
		this.widgets[a.get("name")] = a
	};
	this.getWidgets = function () {
		return this.widgets
	};
	this.removeWidget = function (a) {
		skim.utils.assert(void 0 !== this.widgets[a.get("name")], "The widget3D to remove from the manager does not exist in the manager");
		delete this.widgets[a.get("name")]
	};
	this.updateWidgets = function () {
		for (var a =
				Object.keys(this.widgets), b = a.length, c = 0; c < b; ++c)
			this.widgets[a[c]].update()
	};
	this.renderRequired = function () {
		for (var a = !1, b = Object.keys(this.widgets), c = b.length, d = 0; d < c; ++d)
			a |= this.widgets[b[d]].renderRequired();
		return a
	};
	this.renderDone = function () {
		for (var a = Object.keys(this.widgets), b = a.length, c = 0; c < b; ++c)
			this.widgets[a[c]].renderDone()
	};
	this.computeHit = function (a, b) {
		for (var c = [], d = Object.keys(this.widgets), e = d.length, f = 0; f < e; ++f) {
			var g = this.widgets[d[f]].computeHit(a, b);
			g.hit && c.push(g)
		}
		d = {
			depth : 1E5,
			w : null
		};
		for (f = 0; f < c.length; ++f)
			c[f].depth <= d.depth && (d = c[f]);
		if (d.p)
			for (f = 0; f < d.p.v.length; f++)
				for (e = 0; e < c.length; e++)
					if (g = c[e], g.v && g.v == d.p.v[f])
						return g;
		return d
	};
	this.dispose = function () {
		for (var a = Object.keys(this.widgets), b = a.length, c = 0; c < b; ++c)
			this.widgets[a[c]].dispose(), delete this.widgets[a[c]]
	}
};
skim.widgets3d.widgetNames = {};
skim.widgets3d.Widget3D = Backbone.Model.extend({
		initialize : function (a, b) {
			skim.utils.assert(void 0 !== a.name, "All Widget3D must have a name to be available for the StateMachine");
			skim.utils.assert(void 0 === skim.widgets3d.widgetNames[a.name], "The widget name is already in use");
			this.material = null
		},
		setMaterial : function (a) {
			console.error("Error : should be reimplemented in widgets")
		},
		getMaterial : function () {
			return this.material
		},
		computeHit : function (a, b) {
			console.error("This function should be overwritten in skim.widgets3d.Widget3D subclasses");
			return {
				depth : 0,
				hit : !1,
				w : null,
				p : null,
				v : null
			}
		},
		renderRequired : function () {
			console.error("This function should be overwritten in skim.widgets3d.Widget3D subclasses");
			return !1
		},
		renderDone : function () {
			console.error("This function should be overwritten in skim.widgets3d.Widget3D subclasses")
		},
		dispose : function () {
			console.error("This function should be overwritten in skim.widgets3d.Widget3D subclasses")
		}
	});
skim.widgets3d.BufferManager = function (a, b) {
	this.primWidget = a;
	this.polyhedrons = this.geometry = null;
	this.initBufferSize = 0;
	this.type = b || "FATHEROFALL";
	this.freeVIdx = [];
	this.freeFIdx = [];
	this.bufferEvents = {
		added : {},
		changed : {},
		removed : {},
		colored : {},
		all : !1
	}
};
skim.widgets3d.BufferManager.prototype.updatePrimWidget = function (a, b, c) {};
skim.widgets3d.BufferManager.prototype.initBuffer = function (a) {};
skim.widgets3d.BufferManager.prototype.addGeometryToScene = function (a) {
	this.polyhedrons && (this.polyhedrons = this.polyhedrons.clone(), a.add(this.polyhedrons))
};
skim.widgets3d.BufferManager.prototype.updateVisibility = function (a) {
	this.polyhedrons && (this.polyhedrons.visible = a)
};
skim.widgets3d.BufferManager.prototype.buildGeometry = function () {
	for (var a = Object.keys(this.primWidget.get("skel").prims), b = a.length, c = 0, d = 0; c < b; ++c) {
		var e = this.primWidget.get("skel").prims[a[c]];
		e.type === this.type && (this.bufferEvents.added[e.id] = e, d++)
	}
	this.bufferEvents.changed = {};
	this.bufferEvents.removed = {};
	null !== this.polyhedrons && skim.instances.modeler.sceneManager.getScene().remove(this.polyhedrons);
	this.freeVIdx.length = 0;
	this.freeFIdx.length = 0;
	a = Math.max(this.initBufferSize, 1.5 * d);
	0 !== a && (null !==
		this.geometry && this.geometry.dispose(), this.geometry = new THREE.Geometry, this.geometry.normals = [], this.initBuffer(a), this.geometry.verticesNeedUpdate = !0, this.geometry.elementsNeedUpdate = !0, this.geometry.normalsNeedUpdate = !0, this.geometry.colorsNeedUpdate = !0, this.geometry.computeBoundingBox(), this.geometry.computeBoundingSphere(), this.polyhedrons = new THREE.Mesh(this.geometry, this.primWidget.material), this.polyhedrons.doubleSided = !0, this.polyhedrons.frustumCulled = !1, this.addGeometryToScene(this.primWidget.get("scene")),
		this.primWidget.updateVisibility(), this.updateGeometry())
};
skim.widgets3d.BufferManager.prototype.processGeometry = function () {
	Object.keys(this.bufferEvents.added).length - Object.keys(this.bufferEvents.removed).length > this.freeVIdx.length ? this.buildGeometry() : this.updateGeometry()
};
skim.widgets3d.BufferManager.prototype.updateGeometry = function () {
	if (null !== this.geometry) {
		for (var a = this.geometry.vertices, b = Object.keys(this.bufferEvents.removed), c = b.length, d = 0; d < c; ++d) {
			this.geometry.verticesNeedUpdate = !0;
			for (var e = this.bufferEvents.removed[b[d]], f = e.widgetinfo.v_idx, g = e.widgetinfo.f_idx, e = 0; e < this.verticesNumber; ++e)
				a[f + e].set(0, 0, 0);
			this.freeVIdx.push(f);
			this.freeFIdx.push(g)
		}
		b = Object.keys(this.bufferEvents.added);
		c = b.length;
		for (d = 0; d < c; ++d)
			this.geometry.verticesNeedUpdate = !0,
			this.geometry.normalsNeedUpdate = !0, this.geometry.colorsNeedUpdate = !0, e = this.bufferEvents.added[b[d]], f = this.freeVIdx.pop(), g = this.freeFIdx.pop(), this.updatePrimWidget(e, f, g), this.primWidget.updateWidgetInfo(e, f, g);
		b = Object.keys(this.bufferEvents.changed);
		c = b.length;
		for (d = 0; d < c; ++d)
			this.geometry.verticesNeedUpdate = !0, this.geometry.normalsNeedUpdate = !0, e = this.bufferEvents.changed[b[d]], f = e.widgetinfo.v_idx, g = e.widgetinfo.f_idx, this.updatePrimWidget(e, f, g);
		b = Object.keys(this.bufferEvents.colored);
		c =
			b.length;
		for (d = 0; d < c; ++d)
			this.geometry.colorsNeedUpdate = !0, e = this.bufferEvents.colored[b[d]], f = e.widgetinfo.v_idx, g = e.widgetinfo.f_idx, this.updatePrimWidget(e, f, g);
		this.polyhedrons.doubleSided = !0
	}
};
skim.widgets3d.BufferManager.prototype.updateNeeded = function () {
	return !skim.utils.isEmpty(this.bufferEvents.added) || !skim.utils.isEmpty(this.bufferEvents.changed) || !skim.utils.isEmpty(this.bufferEvents.colored) || !skim.utils.isEmpty(this.bufferEvents.removed)
};
skim.widgets3d.BufferManager.prototype.resetBufferEvents = function () {
	this.bufferEvents = {
		added : {},
		changed : {},
		removed : {},
		colored : {},
		all : !1
	}
};
skim.widgets3d.BufferManager.prototype.renderRequired = function () {
	return null !== this.geometry && (this.geometry.verticesNeedUpdate || this.geometry.colorsNeedUpdate || this.geometry.elementsNeedUpdate || this.geometry.normalsNeedUpdate)
};
skim.widgets3d.BufferManager.prototype.dispose = function () {
	this.primWidget.get("scene").remove(this.polyhedrons);
	null !== this.geometry && (this.geometry.dispose(), this.geometry = null);
	this.polyhedrons = null
};
skim.widgets3d.SegmentBuffer = function (a) {
	skim.widgets3d.BufferManager.call(this, a, skim.skel.typeSegment);
	this.initBufferSize = 10;
	this.primWidgetTubeAngle = -Math.PI / 3;
	this.verticesNumber = 12;
	this.primWidgetTubeF = [[0, 1, 3], [0, 3, 2], [2, 3, 5], [2, 5, 4], [4, 5, 7], [4, 7, 6], [6, 7, 9], [6, 9, 8], [8, 9, 11], [8, 11, 10], [10, 11, 1], [10, 1, 0]]
};
skim.widgets3d.SegmentBuffer.prototype = Object.create(skim.widgets3d.BufferManager.prototype);
skim.widgets3d.SegmentBuffer.prototype.constructor = skim.widgets3d.SegmentBuffer;
skim.widgets3d.SegmentBuffer.prototype.initBuffer = function (a) {
	for (var b = this.geometry.vertices, c = this.geometry.faces, d = this.geometry.normals, e = 0; e < a; ++e) {
		for (var f = this.geometry.vertices.length, g = 0; g < this.verticesNumber; ++g)
			b.push(new THREE.Vector3), d.push(new THREE.Vector3);
		for (var g = c.length, h = 0; h < this.primWidgetTubeF.length; ++h) {
			c.push(new THREE.Face3(this.primWidgetTubeF[h][0] + f, this.primWidgetTubeF[h][1] + f, this.primWidgetTubeF[h][2] + f));
			var k = c[c.length - 1];
			k.vertexNormals = [d[k.a], d[k.b], d[k.c]];
			k.color.setHex(this.primWidget.get("colorHex"))
		}
		this.freeVIdx.push(f);
		this.freeFIdx.push(g)
	}
};
skim.widgets3d.SegmentBuffer.prototype.updatePrimWidget = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3,
	c = new THREE.Vector3;
	return function (d, e, f) {
		var g = this.geometry.vertices,
		h = this.geometry.faces,
		k = this.geometry.normals,
		l = d.v[0].get("pos"),
		m = this.primWidget.get("sizeFactor") * d.v[0].get("thickness"),
		n = d.v[1].get("pos"),
		p = this.primWidget.get("sizeFactor") * d.v[1].get("thickness"),
		q = p - m;
		skim.geometry.GetOrthogonalRandVect(d.unit_dir, a);
		a.normalize();
		b.set(d.length * a.x - q * d.unit_dir.x, d.length *
			a.y - q * d.unit_dir.y, d.length * a.z - q * d.unit_dir.z);
		for (q = 0; q < this.verticesNumber; q += 2)
			VectorUtils.setLinearVect(g[e + q], l, a, m), VectorUtils.setLinearVect(g[e + q + 1], n, a, p), k[e + q].copy(b), k[e + q + 1].copy(b), skim.geometry.RotateVectAroundN(a, d.unit_dir, this.primWidgetTubeAngle, c), a.copy(c), skim.geometry.RotateVectAroundN(b, d.unit_dir, this.primWidgetTubeAngle, c), b.copy(c);
		for (e = 0; e < this.primWidgetTubeF.length; ++e)
			g = h[f + e], g.vertexNormals[0] = k[g.a], g.vertexNormals[1] = k[g.b], g.vertexNormals[2] = k[g.c], g.color.setHex(null !==
				d.widgetinfo.color ? d.widgetinfo.color : this.primWidget.get("colorHex"))
	}
}
();
skim.widgets3d.TriangleBuffer = function (a) {
	skim.widgets3d.BufferManager.call(this, a, skim.skel.typeTriangle);
	this.primWidgetTubeAngle = -Math.PI / 3;
	this.verticesNumber = 30;
	this.facesNumber = 32;
	this.half_hexatube = [[0, 1, 3, 2], [2, 3, 5, 4], [4, 5, 7, 6]]
};
skim.widgets3d.TriangleBuffer.prototype = Object.create(skim.widgets3d.BufferManager.prototype);
skim.widgets3d.TriangleBuffer.prototype.constructor = skim.widgets3d.TriangleBuffer;
skim.widgets3d.TriangleBuffer.prototype.initBuffer = function (a) {
	for (var b = this.geometry.vertices, c = this.geometry.faces, d = this.geometry.normals, e = 0; e < a; ++e) {
		for (var f = this.geometry.vertices.length, g = 0; g < this.verticesNumber; ++g)
			b.push(new THREE.Vector3), d.push(new THREE.Vector3);
		for (var g = c.length, h = null, k = f; k < f + 24; k += 8)
			for (var l = 0; 3 > l; ++l)
				c.push(new THREE.Face3(this.half_hexatube[l][0] + k, this.half_hexatube[l][1] + k, this.half_hexatube[l][2] + k)), h = c[c.length - 1], h.color.setHex(this.primWidget.get("colorHex")),
				h.vertexNormals = [d[h.a], d[h.b], d[h.c]], c.push(new THREE.Face3(this.half_hexatube[l][0] + k, this.half_hexatube[l][2] + k, this.half_hexatube[l][3] + k)), h = c[c.length - 1], h.color.setHex(this.primWidget.get("colorHex")), h.vertexNormals = [d[h.a], d[h.b], d[h.c]];
		for (var k = f + 24, m = [[k, f + 1, f], [k + 2, f + 1, k], [f + 9, f + 1, k + 2], [f + 9, k + 2, k + 4], [f + 9, k + 4, f], [k + 4, k, f]], l = 0; 6 > l; l++)
			c.push(new THREE.Face3(m[l][0], m[l][1], m[l][2])), h = c[c.length - 1], h.color.setHex(this.primWidget.get("colorHex")), h.vertexNormals = [d[h.a], d[h.b], d[h.c]];
		c.push(new THREE.Face3(k + 4, k + 2, k));
		h = c[c.length - 1];
		h.color.setHex(this.primWidget.get("colorHex"));
		h.vertexNormals = [d[h.a], d[h.b], d[h.c]];
		m = [[k + 3, f + 7, f + 15], [k + 1, f + 7, k + 3], [f + 6, f + 7, k + 1], [f + 6, k + 1, k + 5], [f + 6, k + 5, f + 15], [f + 15, k + 5, k + 3]];
		for (l = 0; 6 > l; l++)
			c.push(new THREE.Face3(m[l][0], m[l][1], m[l][2])), h = c[c.length - 1], h.color.setHex(this.primWidget.get("colorHex")), h.vertexNormals = [d[h.a], d[h.b], d[h.c]];
		c.push(new THREE.Face3(k + 1, k + 3, k + 5));
		h = c[c.length - 1];
		h.color.setHex(this.primWidget.get("colorHex"));
		h.vertexNormals =
			[d[h.a], d[h.b], d[h.c]];
		this.freeVIdx.push(f);
		this.freeFIdx.push(g)
	}
};
skim.widgets3d.TriangleBuffer.prototype.updatePrimWidget = function () {
	var a = new THREE.Vector3,
	b = new THREE.Vector3,
	c = new THREE.Vector3,
	d = new THREE.Vector3;
	return function (e, f, g) {
		for (var h = this.geometry.vertices, k = this.geometry.faces, l = this.geometry.normals, m = e.v[0].get("pos"), n = this.primWidget.get("sizeFactor") * e.v[0].get("thickness"), p = e.v[1].get("pos"), q = this.primWidget.get("sizeFactor") * e.v[1].get("thickness"), r = e.v[2].get("pos"), t = this.primWidget.get("sizeFactor") * e.v[2].get("thickness"), m = [{
					v_p : m,
					v_t : n
				}, {
					v_p : p,
					v_t : q
				}, {
					v_p : r,
					v_t : t
				}, {
					v_p : m,
					v_t : n
				}
			], n = [e.length_p0p1, e.length_p1p2, e.length_p2p0], p = [e.unit_p0p1, e.unit_p1p2, e.unit_p2p0], q = 0; 3 > q; ++q)
			for (b.copy(e.unit_normal), r = m[q + 1].v_t - m[q].v_t, c.set(n[q] * b.x - r * p[q].x, n[q] * b.y - r * p[q].y, n[q] * b.z - r * p[q].z).normalize(), VectorUtils.setLinearVect(h[f], m[q].v_p, b, m[q].v_t), l[f++].copy(c), VectorUtils.setLinearVect(h[f], m[q + 1].v_p, b, m[q + 1].v_t), l[f++].copy(c), r = 0; 3 > r; ++r)
				skim.geometry.RotateVectAroundN(b, p[q], this.primWidgetTubeAngle, a), b.copy(a), skim.geometry.RotateVectAroundN(c,
					p[q], this.primWidgetTubeAngle, a), c.copy(a), VectorUtils.setLinearVect(h[f], m[q].v_p, b, m[q].v_t), l[f++].copy(c), VectorUtils.setLinearVect(h[f], m[q + 1].v_p, b, m[q + 1].v_t), l[f++].copy(c);
		d.copy(c);
		c.multiplyScalar(-1);
		m = [];
		m.push(skim.triangleUtils.getParametrisedVertexAttr(e, 0.05, 0.05));
		m.push(skim.triangleUtils.getParametrisedVertexAttr(e, 0.9, 0.05));
		m.push(skim.triangleUtils.getParametrisedVertexAttr(e, 0.05, 0.9));
		for (r = 0; 3 > r; r++)
			VectorUtils.setLinearVect(h[f], m[r].pos, e.unit_normal, m[r].thick), l[f++].copy(c),
			VectorUtils.setLinearVect(h[f], m[r].pos, e.unit_normal, -m[r].thick), l[f++].copy(d);
		for (h = 0; h < this.facesNumber; ++h)
			f = k[g + h], f.vertexNormals[0] = l[f.a], f.vertexNormals[1] = l[f.b], f.vertexNormals[2] = l[f.c], f.color.setHex(null !== e.widgetinfo.color ? e.widgetinfo.color : this.primWidget.get("colorHex"))
	}
}
();
skim.widgets3d.RingBuffer = function (a) {
	skim.widgets3d.BufferManager.call(this, a, skim.skel.typeRing);
	this.radialSegments = 76;
	this.tubularSegments = 3;
	this.verticesNumber = 4 * this.radialSegments * (this.tubularSegments + 1);
	this.facesNumber = 2 * this.verticesNumber;
	this.faceTracker = {}

};
skim.widgets3d.RingBuffer.prototype = Object.create(skim.widgets3d.BufferManager.prototype);
skim.widgets3d.RingBuffer.prototype.constructor = skim.widgets3d.RingBuffer;
skim.widgets3d.RingBuffer.prototype.initBuffer = function (a) {
	for (var b = this.geometry.vertices, c = this.geometry.faces, d = this.geometry.normals, e = 0; e < a; ++e) {
		for (var f = this.geometry.vertices.length, g = 0; g < this.verticesNumber; ++g)
			b.push(new THREE.Vector3), d.push(new THREE.Vector3);
		for (var g = c.length, h = 4 * (this.tubularSegments + 1), k = 0, l = 0, m = 0, n = 0, p = 0, q = 0, r = 0; r < this.radialSegments - 1; r++)
			for (var q = f + h * (r + 1) - 1, t = p = f + r * h; t < q + 1; t++) {
				n = t;
				m = t + 1;
				l = h + 1 + t;
				k = h + t;
				t == q && (n = p, m = p + h, l = q + h, k = q);
				var s = new THREE.Face3(k, l, m),
				u = new THREE.Face3(k, m, n);
				s.vertexNormals = [d[k], d[l], d[m]];
				u.vertexNormals = [d[k], d[m], d[n]];
				s.color.setHex(this.primWidget.get("colorHex"));
				u.color.setHex(this.primWidget.get("colorHex"));
				c.push(s);
				c.push(u)
			}
		q = f + h * this.radialSegments - 1;
		for (t = p = f + (this.radialSegments - 1) * h; t < q + 1; t++)
			n = t, m = t + 1, l = f + 1 + t - p, k = f + t - p, t == q && (k = p, l = q, m = f + h - 1, n = f), s = new THREE.Face3(k, l, m), u = new THREE.Face3(k, m, n), s.vertexNormals = [d[k], d[l], d[m]], u.vertexNormals = [d[k], d[m], d[n]], s.color.setHex(this.primWidget.get("colorHex")),
			u.color.setHex(this.primWidget.get("colorHex")), c.push(s), c.push(u);
		this.freeVIdx.push(f);
		this.freeFIdx.push(g)
	}
};
skim.widgets3d.RingBuffer.prototype.updatePrimWidget = function (a, b, c) {
	this.faceTracker[c] = a;
	var d = this.geometry.vertices,
	e = this.geometry.faces,
	f = this.geometry.normals,
	g = Math.PI / 2,
	h,
	k,
	l,
	m,
	n,
	p,
	q,
	r,
	t,
	s,
	u,
	w,
	y = new THREE.Vector3,
	B = 0;
	for (m = 0; m < this.radialSegments; m += 2)
		for (q = 0; 2 > q && m + q <= this.radialSegments - 1; q++)
			for (r = 2 * (m + q) / this.radialSegments * Math.PI, t = Math.cos(r), s = Math.sin(r), n = 0; 4 > n; n++)
				for (h = skim.ringUtils.getRZTFromAngle(a, r, n + 1), l = h.z * this.primWidget.get("sizeFactor"), k = h.x, h.set(k * t, k * s, h.y), p = 0; p <
					this.tubularSegments + 1; p++)
					u = n * Math.PI / 2 + p / this.tubularSegments * g, w = Math.cos(u), u = Math.sin(u), y.set((k + l * w) * t, (k + l * w) * s, h.z + l * u), d[b + B] = y.clone(), f[b + B] = y.clone().subVectors(y, h).normalize(), B++;
	for (b = 0; b < this.facesNumber; ++b)
		d = e[c + b], d.vertexNormals[0] = f[d.a], d.vertexNormals[1] = f[d.b], d.vertexNormals[2] = f[d.c], d.color.setHex(null !== a.widgetinfo.color ? a.widgetinfo.color : this.primWidget.get("colorHex"));
	this.geometry.computeBoundingSphere();
	this.geometry.computeBoundingBox()
};
skim.widgets3d.RingBuffer.prototype.getRingPrimByFaceIdx = function (a) {
	return this.faceTracker[this.facesNumber * Math.floor(a / this.facesNumber)]
};
skim.widgets3d.verticesWidgetRefGeom = new THREE.SphereGeometry(1, 16, 12);
skim.widgets3d.verticesWidgetRefGeom.normals = [];
for (var i = 0; i < skim.widgets3d.verticesWidgetRefGeom.vertices.length; ++i)
	skim.widgets3d.verticesWidgetRefGeom.normals.push((new THREE.Vector3).copy(skim.widgets3d.verticesWidgetRefGeom.vertices[i]));
skim.widgets3d.VerticesWidget = skim.widgets3d.Widget3D.extend({
		initialize : function (a, b) {
			skim.utils.assert(void 0 !== a.skel, "The vertices widget cannot work without a skel (skim.skel.Skeleton)");
			skim.utils.assert(void 0 !== a.cameraMan, "The vertices widget cannot work without a cameraMan");
			skim.utils.assert(void 0 !== a.canvas, "The vertices widget cannot work without a canvas");
			skim.widgets3d.Widget3D.prototype.initialize.call(this, a, b);
			void 0 === a.sizeFactor && this.set({
				sizeFactor : 1
			});
			void 0 === a.symplaneColor &&
			this.set({
				symplaneColor : 7463793
			});
			void 0 === a.visible && this.set({
				visible : !0
			});
			this.listenTo(this.get("skel"), "vertexAdded", this.vertexAdded);
			this.listenTo(this.get("skel"), "vertexRemoved", this.vertexRemoved);
			this.on("change:sizeFactor", this.changeAll, this);
			this.on("change:visible", this.updateVisibility, this);
			this.bufferEvents = {
				all : !1,
				added : {},
				changed : {},
				removed : {},
				colored : {}

			};
			this.geometry = this.polyhedrons = null;
			this.freeVIdx = [];
			this.freeFIdx = [];
			this.render_required = !1;
			this.spheres = [];
			this.updateSpheres();
			this.material = null !== a.material && void 0 !== a.material ? a.material : new THREE.MeshPhongMaterial({
					color : 3715961,
					specular : 0,
					shininess : 30,
					shading : THREE.SmoothShading
				})
		},
		setMaterial : function (a) {
			this.material = a;
			null !== this.polyhedrons && (this.polyhedrons.material = this.material);
			this.requireRender()
		},
		computeHit : function (a, b) {
			var c = {};
			c.depth = this.get("cameraMan").camera.far + this.get("cameraMan").camera.near;
			c.hit = !1;
			c.w = this;
			if (!this.get("visible"))
				return c;
			for (var d = this.get("cameraMan").getRay(a, b), e = Object.keys(this.get("skel").vertices),
				f = e.length, g = 0; g < f; ++g) {
				var h = this.get("skel").vertices[e[g]],
				k = h.get("pos"),
				l = h.get("thickness") * this.get("sizeFactor"),
				k = skim.geometry.RaySphereIntersect(k, l, d.origin, d.direction),
				l = skim.geometry.inter1,
				m = skim.geometry.inter2;
				switch (k) {
				case 1:
					l < c.depth && (c.hit = !0, c.depth = l, c.v = h, c.point = new THREE.Vector3(d.origin.x + l * d.direction.x, d.origin.y + l * d.direction.y, d.origin.z + l * d.direction.z));
					break;
				case 2:
					k = Math.min(l, m),
					k < c.depth && (c.hit = !0, c.depth = k, c.v = h, c.point = new THREE.Vector3(d.origin.x + k * d.direction.x,
								d.origin.y + k * d.direction.y, d.origin.z + k * d.direction.z))
				}
			}
			return c
		},
		requireRender : function () {
			this.render_required = !0
		},
		renderRequired : function () {
			return this.render_required || null !== this.geometry && (this.geometry.verticesNeedUpdate || this.geometry.colorsNeedUpdate || this.geometry.elementsNeedUpdate || this.geometry.normalsNeedUpdate)
		},
		renderDone : function () {
			this.render_required = !1
		},
		updateSpheres : function () {
			this.spheres = [];
			for (var a = Object.keys(this.get("skel").vertices), b = Object.keys(this.get("skel").vertices).length,
				c = 0; c < b; ++c) {
				var d = this.get("skel").vertices[a[c]],
				e = d.get("pos"),
				d = this.get("sizeFactor") * d.get("thickness");
				this.spheres[c] = new THREE.Vector4(e.x, e.y, e.z, d);
				this.spheres[c].computeOBB()
			}
			this.requireRender()
		},
		getVertexDefaultColorHex : function (a) {
			return skim.engine.close_to_axis(a.attributes.pos, a.attributes.thickness) ? skim.settings.colors.verticesColors.onSymPlane : skim.settings.colors.verticesColors.defaultColor
		},
		updateGeometry : function () {
			if (this.bufferEvents.all || Object.keys(this.bufferEvents.added).length -
				Object.keys(this.bufferEvents.removed).length > this.freeVIdx.length)
				this.buildGeometry();
			else {
				for (var a = 0, b = 0, c = skim.widgets3d.verticesWidgetRefGeom, a = Object.keys(this.bufferEvents.removed), b = Object.keys(this.bufferEvents.removed).length, d = 0; d < b; ++d) {
					this.geometry.verticesNeedUpdate = !0;
					this.requireRender();
					for (var e = this.bufferEvents.removed[a[d]], f = e.widgetinfo.v_idx, g = 0; g < c.vertices.length; ++g)
						this.geometry.vertices[f + g].set(0, 0, 0);
					this.freeVIdx.push(f);
					this.freeFIdx.push(e.widgetinfo.f_idx)
				}
				a = Object.keys(this.bufferEvents.changed);
				b = Object.keys(this.bufferEvents.changed).length;
				for (d = 0; d < b; ++d) {
					this.geometry.verticesNeedUpdate = !0;
					this.requireRender();
					for (var e = this.bufferEvents.changed[a[d]], f = e.widgetinfo.v_idx, h = e.get("pos"), k = this.get("sizeFactor") * e.get("thickness"), g = 0; g < c.vertices.length; ++g) {
						var l = c.vertices[g];
						this.geometry.vertices[f + g].copy(l).multiplyScalar(k).add(h)
					}
				}
				a = Object.keys(this.bufferEvents.added);
				b = Object.keys(this.bufferEvents.added).length;
				for (d = 0; d < b; ++d) {
					this.geometry.verticesNeedUpdate = !0;
					this.geometry.colorsNeedUpdate =
						!0;
					this.requireRender();
					for (var e = this.bufferEvents.added[a[d]], f = this.freeVIdx.pop(), m = this.freeFIdx.pop(), h = e.get("pos"), k = this.get("sizeFactor") * e.get("thickness"), g = 0; g < c.vertices.length; ++g)
						l = c.vertices[g], this.geometry.vertices[f + g].copy(l).multiplyScalar(k).add(h);
					for (g = 0; g < c.faces.length; ++g)
						this.geometry.faces[m + g].color.setHex(this.getVertexDefaultColorHex(e));
					this.updateWidgetInfo(e, f, m)
				}
				a = Object.keys(this.bufferEvents.colored);
				b = Object.keys(this.bufferEvents.colored).length;
				for (d = 0; d <
					b; ++d)
					for (this.geometry.colorsNeedUpdate = !0, this.requireRender(), e = this.bufferEvents.colored[a[d]], m = e.widgetinfo.f_idx, e = null === e.widgetinfo.color ? this.getVertexDefaultColorHex(e) : e.widgetinfo.color, g = 0; g < c.faces.length; ++g)
						this.geometry.faces[m + g].color.setHex(e);
				this.geometry.computeBoundingSphere()
			}
		},
		buildGeometry : function () {
			null !== this.polyhedrons && (this.get("scene").remove(this.polyhedrons), this.polyhedrons.geometry.dispose(), this.polyhedrons = null);
			this.freeVIdx.length = 0;
			this.freeFIdx.length =
				0;
			this.geometry = new THREE.Geometry;
			for (var a = Object.keys(this.get("skel").vertices), b = Object.keys(this.get("skel").vertices).length, c = 0; c < b; ++c) {
				for (var d = this.get("skel").vertices[a[c]], e = d.get("pos"), f = this.get("sizeFactor") * d.get("thickness"), g = this.geometry.vertices.length, h = skim.widgets3d.verticesWidgetRefGeom, k = 0; k < h.vertices.length; ++k) {
					var l = h.vertices[k];
					this.geometry.vertices.push((new THREE.Vector3(l.x, l.y, l.z)).multiplyScalar(f).add(e))
				}
				e = new THREE.Color;
				e.setHex(null === d.widgetinfo.color ?
					this.getVertexDefaultColorHex(d) : d.widgetinfo.color);
				skim.engine.close_to_axis(d.attributes.pos, d.attributes.thickness) && e.setHex(skim.settings.colors.verticesColors.onSymPlane);
				f = this.geometry.faces.length;
				for (k = 0; k < h.faces.length; ++k)
					l = h.faces[k], this.geometry.faces.push(new THREE.Face3(l.a + g, l.b + g, l.c + g, l.normal)), this.geometry.faces[f + k].vertexNormals = [h.normals[l.a], h.normals[l.b], h.normals[l.c]], this.geometry.faces[this.geometry.faces.length - 1].color.copy(e);
				this.updateWidgetInfo(d, g, f)
			}
			for (c =
					0; c < b; ++c) {
				g = this.geometry.vertices.length;
				h = skim.widgets3d.verticesWidgetRefGeom;
				for (k = 0; k < h.vertices.length; ++k)
					this.geometry.vertices.push(new THREE.Vector3);
				f = this.geometry.faces.length;
				for (k = 0; k < h.faces.length; ++k)
					l = h.faces[k], this.geometry.faces.push(new THREE.Face3(l.a + g, l.b + g, l.c + g, l.normal)), this.geometry.faces[f + k].vertexNormals = [h.normals[l.a], h.normals[l.b], h.normals[l.c]];
				this.freeVIdx.push(g);
				this.freeFIdx.push(f)
			}
			this.geometry.verticesNeedUpdate = !0;
			this.geometry.elementsNeedUpdate =
				!0;
			this.geometry.normalsNeedUpdate = !0;
			this.polyhedrons = new THREE.Mesh(this.geometry, this.material);
			this.polyhedrons.doubleSided = !0;
			this.get("scene").add(this.polyhedrons);
			this.geometry.computeBoundingBox();
			this.geometry.computeBoundingSphere();
			this.updateVisibility()
		},
		getSym : function (a) {
			return a.syminfo ? a.syminfo : null
		},
		updateVisibility : function () {
			this.polyhedrons && (this.get("visible") ? this.polyhedrons.visible = !0 : this.polyhedrons.visible = !1);
			this.requireRender()
		},
		update : function () {
			var a = this.bufferEvents;
			!a.all && skim.utils.isEmpty(a.added) && skim.utils.isEmpty(a.changed) && skim.utils.isEmpty(a.removed) && skim.utils.isEmpty(a.colored) || (this.updateSpheres(), this.updateGeometry(), this.bufferEvents = {
					all : !1,
					added : {},
					changed : {},
					removed : {},
					colored : {}

				})
		},
		updateWidgetInfo : function (a, b, c) {
			a.widgetinfo.v_idx = b;
			a.widgetinfo.f_idx = c
		},
		changeAll : function () {
			this.bufferEvents.all = !0
		},
		vertexAdded : function (a) {
			this.bufferEvents.added[a.v.id] = a.v;
			a.v.on("change", this.vertexChanged, this)
		},
		vertexChanged : function (a) {
			void 0 ===
			this.bufferEvents.added[a.id] && (this.bufferEvents.changed[a.id] = a)
		},
		vertexRemoved : function (a) {
			a.v.off("change", this.vertexChanged, this);
			void 0 !== this.bufferEvents.added[a.v.id] ? delete this.bufferEvents.added[a.v.id] : this.bufferEvents.removed[a.v.id] = a.v;
			void 0 !== this.bufferEvents.changed[a.v.id] && delete this.bufferEvents.changed[a.v.id];
			void 0 !== this.bufferEvents.colored[a.v.id] && delete this.bufferEvents.colored[a.v.id]
		},
		setColor : function (a, b) {
			for (var c = Object.keys(a), d = 0; d < c.length; ++d) {
				var e = a[c[d]];
				void 0 !== this.get("skel").vertices[e.id] && (skim.utils.assert(this.get("skel").vertices[e.id] == e, "The vertex does not belong to the skeleton, it cannot be colored in widgets"), e.widgetinfo.color = b, this.bufferEvents.colored[e.id] = e)
			}
		},
		uncolor : function (a) {
			for (var b = Object.keys(a), c = 0; c < b.length; ++c) {
				var d = a[b[c]];
				null !== d && (void 0 !== d && void 0 !== this.get("skel").vertices[d.id]) && (skim.utils.assert(this.get("skel").vertices[d.id] == d, "The vertex does not belong to the skeleton, it cannot be uncolored in widgets"),
					d.widgetinfo.color = null, this.bufferEvents.colored[d.id] = d)
			}
		},
		dispose : function () {
			this.stopListening();
			this.get("scene").remove(this.polyhedrons);
			this.polyhedrons = null;
			null !== this.geometry && this.geometry.dispose();
			null !== this.material && this.material.dispose()
		}
	});
skim.widgets3d.PrimitiveWidget = skim.widgets3d.Widget3D.extend({
		initialize : function (a, b) {
			skim.utils.assert(void 0 !== a.skel, "The primitives widget cannot work without a skel (skim.skel.Skeleton)");
			skim.utils.assert(void 0 !== a.cameraMan, "The primitives widget cannot work without a cameraMan");
			skim.utils.assert(void 0 !== a.canvas, "The primitives widget cannot work without a canvas");
			skim.widgets3d.Widget3D.prototype.initialize.call(this, a, b);
			void 0 === a.sizeFactor && this.set({
				sizeFactor : 1
			});
			void 0 === a.colorHex &&
			this.set({
				colorHex : 10066329
			});
			void 0 === a.visible && this.set({
				visible : !0
			});
			this.listenTo(this.get("skel"), "primAdded", this.primAdded);
			this.listenTo(this.get("skel"), "primChanged", this.primChanged);
			this.listenTo(this.get("skel"), "primRemoved", this.primRemoved);
			this.on("change:colorHex", this.buildGeometry, this);
			this.on("change:sizeFactor", this.buildGeometry, this);
			this.on("change:visible", this.updateVisibility, this);
			this.primWidgets = {};
			this.primWidgets[skim.skel.typeSegment] = new skim.widgets3d.SegmentBuffer(this);
			this.primWidgets[skim.skel.typeRing] = new skim.widgets3d.RingBuffer(this);
			this.primWidgets[skim.skel.typeTriangle] = new skim.widgets3d.TriangleBuffer(this);
			this.primWidgets[skim.skel.typeTextRing] = new skim.widgets3d.RingBuffer(this);
			this.primWidgets[skim.skel.typeText] = new skim.widgets3d.BufferManager(this, skim.skel.typeText);
			this.primWidgets[skim.skel.typeHeightMapRing] = new skim.widgets3d.BufferManager(this, skim.skel.typeHeightMapRing);
			this.updateCylcones();
			this.render_required = !1;
			this.material = null !==
				a.material && void 0 !== a.material ? a.material : new THREE.MeshPhongMaterial({
					color : 10330018,
					specular : 0,
					shininess : 30,
					shading : THREE.SmoothShading
				});
			this.resetBufferEvents();
			for (var c = Object.keys(this.primWidgets), d = 0; d < c.length; d++)
				this.primWidgets[c[d]].buildGeometry()
		},
		setMaterial : function (a) {
			this.material = a;
			a = Object.keys(this.primWidgets);
			for (var b = 0; b < a.length; ++b) {
				var c = this.primWidgets[a[b]].polyhedrons;
				null !== c && (c.material = this.material)
			}
			this.requireRender()
		},
		resetBufferEvents : function () {
			this.bufferEventsAll =
				!1;
			for (var a = Object.keys(this.primWidgets), b = 0; b < a.length; b++)
				this.primWidgets[a[b]].resetBufferEvents()
		},
		updateWidgetInfo : function (a, b, c) {
			a.widgetinfo.v_idx = b;
			a.widgetinfo.f_idx = c
		},
		updateCylcones : function () {
			this.requireRender();
			this.cylinders = [];
			this.cones = [];
			for (var a = Object.keys(this.get("skel").prims), b = a.length, c = 0, d = 0, e = 0; e < b; ++e) {
				var f = this.get("skel").prims[a[e]];
				if (f.type == skim.skel.typeSegment) {
					var g = f.v[0].get("pos"),
					h = f.v[1].get("pos"),
					k = this.get("sizeFactor") * f.v[0].get("thickness"),
					l = this.get("sizeFactor") * f.v[1].get("thickness"),
					m = k - l,
					n = f.length,
					f = f.unit_dir,
					p = Math.abs(m) / n;
					1E-6 < p ? (g = new ConeAB({
								pointA : new THREE.Vector4(g.x, g.y, g.z, k),
								pointB : new THREE.Vector4(h.x, h.y, h.z, l)
							}), this.cones[c] = g.formatVTtheta(n, f, p, m).computeOBB(), c++) : (m = new CylinderAB({
								pointA : g,
								pointB : h,
								radius : k
							}), this.cylinders[d] = m.formatVTtheta(n, f, p).computeOBB(), d++)
				}
			}
		},
		computeRayHit : function (a, b, c) {
			for (var d = Object.keys(this.get("skel").prims), e = d.length, f = 0; f < e; ++f) {
				var g = this.get("skel").prims[d[f]];
				if (g.type == skim.skel.typeSegment) {
					if (0 !== g.length) {
						var h = g.v[0].get("pos"),
						k = g.v[1].get("pos"),
						l = this.get("sizeFactor") * g.v[0].get("thickness"),
						m = this.get("sizeFactor") * g.v[1].get("thickness");
						this.intersect_cylcone(h, k, l, m, g.unit_dir, g.length, a, b, c, g)
					}
				} else if (g.type == skim.skel.typeRing)
					g = new THREE.Raycaster(a, b), null !== this.primWidgets[skim.skel.typeRing].polyhedrons && (g = g.intersectObjects([this.primWidgets[skim.skel.typeRing].polyhedrons], !0), 0 < g.length && (h = 0, 1 < g.length && (h = g[0].distance < g[1].distance ?
									0 : 1), g[h].distance < c.depth && (c.hit = !0, c.depth = g[h].distance, c.p = this.primWidgets[skim.skel.typeRing].getRingPrimByFaceIdx(g[h].faceIndex), c.point = g[h].point)));
				else if (g.type != skim.skel.typeTextRing && g.type == skim.skel.typeTriangle) {
					var h = g.v[0].get("pos"),
					k = g.v[1].get("pos"),
					n = g.v[2].get("pos"),
					l = this.get("sizeFactor") * g.v[0].get("thickness"),
					m = this.get("sizeFactor") * g.v[1].get("thickness"),
					p = this.get("sizeFactor") * g.v[2].get("thickness");
					0 !== g.length_p0p1 && this.intersect_cylcone(h, k, l, m, g.unit_p0p1,
						g.length_p0p1, a, b, c, g);
					0 !== g.length_p1p2 && this.intersect_cylcone(k, n, m, p, g.unit_p1p2, g.length_p1p2, a, b, c, g);
					0 !== g.length_p2p0 && this.intersect_cylcone(n, h, p, l, g.unit_p2p0, g.length_p2p0, a, b, c, g);
					if (0 !== (new THREE.Vector3).crossVectors(g.unit_p0p1, g.unit_p2p0).length) {
						var q = {
							p0 : new THREE.Vector3(h.x + l * g.unit_normal.x, h.y + l * g.unit_normal.y, h.z + l * g.unit_normal.z),
							p1 : new THREE.Vector3(k.x + m * g.unit_normal.x, k.y + m * g.unit_normal.y, k.z + m * g.unit_normal.z),
							p2 : new THREE.Vector3(n.x + p * g.unit_normal.x, n.y + p * g.unit_normal.y,
								n.z + p * g.unit_normal.z)
						};
						this.intersect_tri(q, a, b, c, g);
						q = {
							p0 : new THREE.Vector3(h.x - l * g.unit_normal.x, h.y - l * g.unit_normal.y, h.z - l * g.unit_normal.z),
							p1 : new THREE.Vector3(k.x - m * g.unit_normal.x, k.y - m * g.unit_normal.y, k.z - m * g.unit_normal.z),
							p2 : new THREE.Vector3(n.x - p * g.unit_normal.x, n.y - p * g.unit_normal.y, n.z - p * g.unit_normal.z)
						};
						this.intersect_tri(q, a, b, c, g)
					}
				}
			}
		},
		computeHit : function (a, b) {
			var c = {};
			c.depth = this.get("cameraMan").camera.far + this.get("cameraMan").camera.near;
			c.hit = !1;
			c.w = this;
			c.p = null;
			c.v = null;
			if (!this.get("visible"))
				return c;
			var d = this.get("cameraMan").getRay(a, b);
			this.computeRayHit(d.origin, d.direction, c);
			return c
		},
		intersect_torus : function (a, b, c, d, e) {
			var f = {};
			skim.geometry.RayTorusIntersect(a, b, c, f);
			if (0 < f.n_inter) {
				a = f.inter_t[0];
				c = b = 0;
				for (var g = 1, h = f.inter_t.length; g < h; g++)
					c = a, a = Math.min(a, f.inter_t[g]), b = c != a ? g : b;
				f = f.inter_p[b];
				d.hit = !0;
				d.depth = a;
				d.p = e;
				d.point = f
			}
		},
		intersect_tri : function (a, b, c, d, e) {
			var f = new THREE.Vector3;
			f.subVectors(a.p1, a.p0);
			var g = new THREE.Vector3;
			g.subVectors(a.p2,
				a.p0);
			var h = new THREE.Vector3;
			h.crossVectors(f, g);
			var k = -h.dot(c);
			if (0 !== k) {
				var l = new THREE.Vector3;
				l.subVectors(b, a.p0);
				a = new THREE.Vector3;
				a.crossVectors(l, g);
				g = -a.dot(c) / k;
				a.crossVectors(f, l);
				f = -a.dot(c) / k;
				h = h.dot(l) / k;
				0 < h && (0 <= g && 0 <= f && 1 >= g + f && h < d.depth) && (d.hit = !0, d.depth = h, d.p = e, d.point = new THREE.Vector3(b.x + h * c.x, b.y + h * c.y, b.z + h * c.z))
			}
		},
		intersect_cylcone : function (a, b, c, d, e, f, g, h, k, l) {
			var m = c - d,
			n = Math.abs(m) / f,
			p = {};
			1E-6 < n ? (a = {}, d = d * f / m, a.v = new THREE.Vector3(b.x + d * e.x, b.y + d * e.y, b.z + d * e.z), 0 <
				m ? (a.axis = new THREE.Vector3(-e.x, -e.y, -e.z), a.inf = Math.abs(d), a.sup = a.inf + f) : (a.axis = e, a.sup = Math.abs(d), a.inf = a.sup - f), a.cos_theta = 1 / Math.sqrt(1 + n * n), p.n_inter = skim.geometry.RayConeIntersect(a, g, h, p)) : (b = {}, b.v = a, b.axis = e, b.inf = 0, b.sup = f, b.r = 0.5 * (c + d), p.n_inter = skim.geometry.RayCylinderIntersect(b, g, h, p));
			switch (p.n_inter) {
			case 1:
				p.inter_t[0] < k.depth && (k.hit = !0, k.depth = p.inter_t[0], k.p = l, k.point = p.inter_p[0]);
				break;
			case 2:
				e = p.inter_t[0] < p.inter_t[1] ? 0 : 1,
				p.inter_t[e] < k.depth && (k.hit = !0, k.depth = p.inter_t[e],
					k.p = l, k.point = p.inter_p[e])
			}
		},
		requireRender : function () {
			this.render_required = !0
		},
		renderRequired : function () {
			for (var a = !1, b = Object.keys(this.primWidgets), c = 0; c < b.length; c++)
				a = a || this.primWidgets[b[c]].renderRequired();
			return this.render_required || a
		},
		renderDone : function () {
			this.render_required = !1
		},
		updateGeometry : function () {
			var a = Object.keys(this.primWidgets);
			if (this.bufferEventsAll)
				for (var b = 0; b < a.length; b++)
					this.primWidgets[a[b]].buildGeometry();
			for (b = 0; b < a.length; b++)
				this.primWidgets[a[b]].processGeometry()
		},
		updateVisibility : function () {
			for (var a = this.get("visible"), b = Object.keys(this.primWidgets), c = 0; c < b.length; c++)
				this.primWidgets[b[c]].updateVisibility(a);
			this.requireRender()
		},
		changeAll : function () {
			this.bufferEventsAll = !0
		},
		update : function () {
			for (var a = this.bufferEventsAll, b = Object.keys(this.primWidgets), c = 0; c < b.length; c++)
				a = a || this.primWidgets[b[c]].updateNeeded();
			a && (this.updateCylcones(), this.updateGeometry(), this.resetBufferEvents())
		},
		primAdded : function (a) {
			a.p.type !== skim.skel.typeMesh && (this.primWidgets[a.p.type].bufferEvents.added[a.p.id] =
					a.p)
		},
		primChanged : function (a) {
			a.p.type !== skim.skel.typeMesh && void 0 === this.primWidgets[a.p.type].bufferEvents.added[a.p.id] && (this.primWidgets[a.p.type].bufferEvents.changed[a.p.id] = a.p)
		},
		primRemoved : function (a) {
			a.p.type !== skim.skel.typeMesh && (void 0 === this.primWidgets[a.p.type].bufferEvents.added[a.p.id] ? (delete this.primWidgets[a.p.type].bufferEvents.changed[a.p.id], this.primWidgets[a.p.type].bufferEvents.removed[a.p.id] = a.p) : delete this.primWidgets[a.p.type].bufferEvents.added[a.p.id], void 0 !==
				this.primWidgets[a.p.type].bufferEvents.colored[a.p.id] && delete this.primWidgets[a.p.type].bufferEvents.colored[a.p.id])
		},
		setColor : function (a, b) {
			for (var c = Object.keys(a), d = 0; d < c.length; ++d) {
				var e = a[c[d]];
				void 0 !== this.get("skel").prims[e.id] && (skim.utils.assert(this.get("skel").prims[e.id] == e, "The vertex does not belong to the skeleton, it cannot be colored in widgets"), e.widgetinfo.color = b, this.primWidgets[e.type].bufferEvents.colored[e.id] = e)
			}
		},
		uncolor : function (a) {
			for (var b = Object.keys(a), c = 0; c <
				b.length; ++c) {
				var d = a[b[c]];
				null !== d && (void 0 !== d && void 0 !== this.get("skel").prims[d.id]) && (skim.utils.assert(this.get("skel").prims[d.id] == d, "The vertex does not belong to the skeleton, it cannot be uncolored in widgets"), d.widgetinfo.color = null, this.primWidgets[d.type].bufferEvents.colored[d.id] = d)
			}
		},
		dispose : function () {
			this.stopListening();
			for (var a = Object.keys(this.primWidgets), b = 0; b < a.length; ++b)
				this.primWidgets[a[b]].dispose(), delete this.primWidgets[a[b]]
		}
	});
skim.widgets3d.MeshWidget = skim.widgets3d.Widget3D.extend({
		initialize : function (a, b) {
			skim.utils.assert(void 0 !== a.skel, "The vertices widget cannot work without a skel (skim.skel.Skeleton)");
			skim.utils.assert(void 0 !== a.cameraMan, "The vertices widget cannot work without a cameraMan");
			skim.utils.assert(void 0 !== a.canvas, "The vertices widget cannot work without a canvas");
			skim.widgets3d.Widget3D.prototype.initialize.call(this, a, b);
			void 0 === a.symplaneColor && this.set({
				symplaneColor : 7463793
			});
			void 0 === a.visible &&
			this.set({
				visible : !0
			});
			this.listenTo(this.get("skel"), "primAdded", this.primAdded);
			this.listenTo(this.get("skel"), "primChanged", this.primChanged);
			this.listenTo(this.get("skel"), "primRemoved", this.primRemoved);
			this.on("change:visible", this.updateVisibility, this);
			this.bufferEvents = {
				all : !1,
				added : {},
				changed : {},
				removed : {},
				colored : {}

			};
			this.polyhedrons = {};
			this.geometries = {};
			this.render_required = !1;
			this.material = null !== a.material && void 0 !== a.material ? a.material : new THREE.MeshPhongMaterial({
					color : 10066329,
					specular : 0,
					shininess : 30,
					shading : THREE.SmoothShading
				});
			this.spec_materials = {};
			this.widgetInfos = {}

		},
		setMaterial : function (a) {
			this.material = a;
			a = Object.keys(this.polyhedrons);
			for (var b = 0; b < a.length; ++b)
				this.polyhedrons[a[b]].material = this.material;
			this.requireRender()
		},
		setSpecificMaterial : function (a, b, c) {
			skim.utils.assert(void 0 !== b && null !== b || void 0 !== c && null !== c, "Error : name and id or not defined, at least one of them must be specified");
			if (void 0 !== b && null !== b)
				var d = skim.engine.getPrimitiveByName(b);
			else
				void 0 !== c && null !== c && (d = skim.engine.getPrimitiveById(c));
			this.spec_materials[d.id] = a;
			this.polyhedrons[d.id].material = a;
			this.requireRender()
		},
		computeHit : function (a, b) {
			var c = new THREE.Vector3,
			d = new THREE.Vector3,
			e = new THREE.Vector3,
			f = {
				hit : !1,
				t : 0
			},
			g = {};
			g.depth = this.get("cameraMan").camera.far + this.get("cameraMan").camera.near;
			g.hit = !1;
			g.w = this;
			g.p = null;
			if (!this.get("visible"))
				return g;
			var h = this.get("cameraMan").getRay(a, b);
			h.normalizeDirection();
			for (var k = Object.keys(this.get("skel").prims), l =
					k.length, m = 0; m < l; ++m) {
				var n = this.get("skel").prims[k[m]];
				if (n.getType() === skim.skel.typeMesh) {
					var p = n.getMesh();
					n.getMesh();
					for (var q = 0; q < n.getMesh().n_faces; ++q) {
						var r = p.getFA(q);
						c.set(p.getVX(r), p.getVY(r), p.getVZ(r));
						r = p.getFB(q);
						d.set(p.getVX(r), p.getVY(r), p.getVZ(r));
						r = p.getFC(q);
						e.set(p.getVX(r), p.getVY(r), p.getVZ(r));
						h.getTriangleIntersection(c, d, e, f);
						f.hit && f.t < g.depth && (g.hit = !0, g.depth = f.t, g.p = n)
					}
				}
			}
			g.hit && (g.point = new THREE.Vector3(h.origin.x + g.depth * h.direction.x, h.origin.y + g.depth * h.direction.y,
						h.origin.z + g.depth * h.direction.z));
			return g
		},
		requireRender : function () {
			this.render_required = !0
		},
		renderRequired : function () {
			return this.render_required || 0 !== Object.keys(this.geometries).length
		},
		renderDone : function () {
			this.render_required = !1
		},
		updateGeometry : function () {
			for (var a = Object.keys(this.bufferEvents.changed), b = !1, c = 0; c < a.length; ++c)
				b = b = !0;
			if (this.bufferEvents.all || 0 !== Object.keys(this.bufferEvents.added).length || b)
				this.buildGeometry();
			else {
				b = a = 0;
				a = Object.keys(this.bufferEvents.removed);
				b = Object.keys(this.bufferEvents.removed).length;
				for (c = 0; c < b; ++c)
					delete this.geometries[a[c]], this.get("scene").remove(this.polyhedrons[a[c]]), delete this.polyhedrons[a[c]], delete this.spec_materials[a[c]], this.requireRender();
				a = Object.keys(this.bufferEvents.added);
				b = Object.keys(this.bufferEvents.added).length;
				for (c = 0; c < b; ++c) {
					var d = this.bufferEvents.added[a[c]].p,
					e = d.getMesh();
					this.get("scene").remove(this.polyhedrons[d.id]);
					this.geometries[d.id] = e.convertToTHREEBufferGeometry();
					this.polyhedrons[d.id] = new THREE.Mesh(this.geometries[d.id], void 0 !==
							this.spec_materials[d.id] ? this.spec_materials[d.id] : this.material);
					this.get("scene").add(this.polyhedrons[d.id]);
					this.geometries[d.id].computeBoundingSphere();
					this.geometries[d.id].computeBoundingBox();
					this.requireRender()
				}
				a = Object.keys(this.bufferEvents.changed);
				b = Object.keys(this.bufferEvents.changed).length;
				for (c = 0; c < b; ++c)
					d = this.bufferEvents.changed[a[c]].p, e = d.getMesh(), this.get("scene").remove(this.polyhedrons[d.id]), this.geometries[d.id] = e.convertToTHREEBufferGeometry(), this.polyhedrons[d.id] =
						new THREE.Mesh(this.geometries[d.id], void 0 !== this.spec_materials[d.id] ? this.spec_materials[d.id] : this.material), this.get("scene").add(this.polyhedrons[d.id]), this.geometries[d.id].computeBoundingSphere(), this.geometries[d.id].computeBoundingBox(), this.requireRender()
			}
		},
		buildGeometry : function () {
			for (var a = Object.keys(this.polyhedrons), b = 0; b < a.length; ++b)
				this.get("scene").remove(this.polyhedrons[a[b]]);
			this.polyhedrons = {};
			this.widgetInfos = {};
			this.geometries = {};
			for (var a = Object.keys(this.get("skel").prims),
				c = Object.keys(this.get("skel").prims).length, b = 0; b < c; ++b) {
				var d = this.get("skel").prims[a[b]];
				if (d.getType() === skim.skel.typeMesh) {
					var e = d.getMesh();
					this.geometries[d.id] = e.convertToTHREEBufferGeometry();
					this.geometries[d.id].verticesNeedUpdate = !0;
					this.geometries[d.id].elementsNeedUpdate = !0;
					this.geometries[d.id].normalsNeedUpdate = !0;
					this.polyhedrons[d.id] = new THREE.Mesh(this.geometries[d.id], void 0 !== this.spec_materials[d.id] ? this.spec_materials[d.id] : this.material);
					this.polyhedrons[d.id].doubleSided =
						!0;
					this.get("scene").add(this.polyhedrons[d.id]);
					this.geometries[d.id].computeBoundingBox();
					this.geometries[d.id].computeBoundingSphere()
				}
			}
			this.updateVisibility()
		},
		updateVisibility : function () {
			for (var a = Object.keys(this.polyhedrons), b = 0; b < a.length; ++b)
				this.get("visible") ? this.polyhedrons[a[b]].visible = !0 : this.polyhedrons[a[b]].visible = !1;
			this.requireRender()
		},
		update : function () {
			var a = this.bufferEvents;
			!a.all && skim.utils.isEmpty(a.added) && skim.utils.isEmpty(a.changed) && skim.utils.isEmpty(a.removed) &&
			skim.utils.isEmpty(a.colored) || (this.updateGeometry(), this.bufferEvents = {
					all : !1,
					added : {},
					changed : {},
					removed : {},
					colored : {}

				})
		},
		updateWidgetInfo : function (a, b, c, d, e) {
			this.widgetInfos[a.id] = {
				v0_idx : b,
				v1_idx : c,
				f0_idx : d,
				f1_idx : e
			}
		},
		changeAll : function () {
			this.bufferEvents.all = !0
		},
		primAdded : function (a) {
			a.p.type === skim.skel.typeMesh && (this.bufferEvents.added[a.p.id] = a.p, a.p.on("change", this.primChanged, this))
		},
		primChanged : function (a) {
			a.p.type === skim.skel.typeMesh && void 0 === this.bufferEvents.added[a.p.id] && (this.bufferEvents.changed[a.p.id] = {
					p : a.p,
					added_or_removed : a.data.added_or_removed,
					mvv : a.data.mvv
				})
		},
		primRemoved : function (a) {
			a.p.type === skim.skel.typeMesh && (a.p.off("change", this.primChanged, this), void 0 !== this.bufferEvents.added[a.p.id] ? delete this.bufferEvents.added[a.p.id] : this.bufferEvents.removed[a.p.id] = a.p, void 0 !== this.bufferEvents.changed[a.p.id] && delete this.bufferEvents.changed[a.p.id], void 0 !== this.bufferEvents.colored[a.p.id] && delete this.bufferEvents.colored[a.p.id])
		},
		dispose : function () {
			this.stopListening();
			this.get("scene").remove(this.polyhedrons);
			this.polyhedrons = null;
			for (var a = Object.keys(this.geometries), b = 0; b < this.geometries.length; ++b)
				null !== this.geometries[a[b]] && (this.geometries[a[b]].dispose(), delete this.geometries[a[b]]);
			null !== this.material && this.material.dispose();
			a = Object.keys(this.spec_materials);
			for (b = 0; b < a.length; ++b)
				null !== this.spec_materials[a[b]] && (this.spec_materials[a[b]].dispose(), delete this.spec_materials[a[b]]);
			this.bufferEvents = {
				all : !1,
				added : {},
				changed : {},
				removed : {},
				colored : {}

			}
		}
	});
skim.exporters.Exporter = function (a, b, c, d, e) {
	this.vertices = a;
	this.normals = b;
	this.faces = c;
	this.n_vertices = d;
	this.n_faces = e;
	this.file = null
};
skim.exporters.Exporter.prototype.getBlob = function (a, b, c) {
	console.error("cannot call getBlob() on base exporter class");
	return new Blob
};
skim.exporters.ExporterOBJ = function (a, b, c, d, e) {
	skim.exporters.Exporter.call(this, a, b, c, d, e)
};
skim.exporters.ExporterOBJ.prototype = Object.create(skim.exporters.Exporter.prototype);
skim.exporters.ExporterOBJ.prototype.constructor = skim.exporters.ExporterOBJ;
skim.exporters.ExporterOBJ.prototype.getOBJString = function (a, b, c) {
	var d = "";
	skim.utils.assert(void 0 !== b, "Error (debug) : call to ExporterOBJ with no orientation matrix");
	null === b && (b = new THREE.Matrix4, b.identity());
	var e = new THREE.Vector3;
	console.log("-- Exporting vertices...");
	for (var f = 0; f < 3 * this.n_vertices; f += 3)
		e.set(this.vertices[f] * c, this.vertices[f + 1] * c, this.vertices[f + 2] * c), e.applyMatrix4(b), d += "v " + e.x.toFixed(3) + " " + e.y.toFixed(3) + " " + e.z.toFixed(3) + "\n";
	console.log("-- Exporting normals...");
	if (a)
		for (f = 0; f < 3 * this.n_vertices; f += 3)
			e.set(this.normals[f], this.normals[f + 1], this.normals[f + 2]), e.applyMatrix4(b), d += "vn " + e.x.toFixed(6) + " " + e.y.toFixed(6) + " " + e.z.toFixed(6) + "\n";
	else
		console.log(" Canceled : object is requested without normals.");
	console.log("-- Exporting faces...");
	a = 3 * this.n_faces;
	for (f = 0; f < a; f += 3)
		d += "f " + (this.faces[f] + 1) + " " + (this.faces[f + 1] + 1) + " " + (this.faces[f + 2] + 1), d += "\n";
	return d
};
skim.exporters.ExporterOBJ.prototype.getBlob = function (a, b, c) {
	a = this.getOBJString(a, b, c);
	return new Blob([a], {
		type : "application/octet-stream"
	})
};
skim.exporters.ExporterOBJ.prototype.getCompressedBlob = function (a, b, c) {
	a = this.getOBJString(a, b, c);
	console.log("-- Compressing .Obj data --");
	skim.utils.assert(LZString, "Exporter - LZString lib has not been loaded");
	a = LZString.compressToBase64(a);
	console.log("-- .Obj data is compressed --");
	return new Blob([a], {
		type : "application/zip"
	})
};
skim.views.MainDocView = Backbone.View.extend({
		el : $(document),
		events : {
			mousemove : "mousemove",
			mouseup : "mouseup",
			keyup : "keyup",
			keydown : "keydown"
		},
		initialize : function () {},
		fillMouseEvent : function (a) {
			var b = skim.utils.getElOffset(skim.instances.modeler.canvas);
			a.canvasX = a.pageX - b.left;
			a.canvasY = a.pageY - b.top
		},
		mousemove : function (a) {
			a.complexType = "mousemove";
			this.fillMouseEvent(a);
			this.trigger(a.complexType, a)
		},
		mouseup : function (a) {
			this.fillMouseEvent(a);
			a.complexType = "mouse" + a.which.toString() + ":up";
			this.trigger(a.complexType,
				a)
		},
		getKeyCode : function (a) {
			switch (a.which) {
			case 8:
				return "backspace";
			case 13:
				return "enter";
			case 16:
				return "shift";
			case 27:
				return "esc";
			case 32:
				return "space";
			case 33:
				return "pgup";
			case 34:
				return "pgdown";
			case 37:
				return "arrowleft";
			case 38:
				return "arrowup";
			case 39:
				return "arrowright";
			case 40:
				return "arrowdown";
			case 46:
				return "del";
			default:
				if (65 <= a.which && 90 >= a.which || 48 <= a.which && 57 >= a.which)
					return String.fromCharCode(a.which).toLowerCase();
				if (97 <= a.which && 105 >= a.which)
					return "num" + (a.which - 96)
			}
			return ""
		},
		keyup : function (a) {
			var b =
				this.getKeyCode(a);
			a.complexType = b + ":up";
			"" !== b && this.trigger(a.complexType, a)
		},
		keydown : function (a) {
			var b = this.getKeyCode(a);
			a.complexType = b + ":down";
			"" !== b && this.trigger(a.complexType, a)
		}
	});
skim.views.MainCanvasView = Backbone.View.extend({
		el : $(document),
		events : {
			mousedown : "mousedwn",
			mousewheel : "mousewheel",
			DOMMouseScroll : "DOMMouseScroll",
			mouseup : "mouseup",
			contextmenu : "contextmenu",
			mousemove : "mousemove",
			mouseenter : "mouseenterleave",
			mouseleave : "mouseenterleave",
			keydown : "keydown",
			keyup : "keyup",
			dblclick : "dblclick"
		},
		initialize : function (a, b) {
			this.setElement(a.canvas);
			this.widgets3DManager = a.widgets3DManager
		},
		fillMouseEvent : function (a) {
			var b = skim.utils.getElOffset(this.el);
			a.canvasX = a.pageX -
				b.left;
			a.canvasY = a.pageY - b.top
		},
		getKeyModifier : function (a) {
			var b = "";
			a.ctrlKey ? b = "ctrl" : a.altKey && (b += "alt");
			return b
		},
		mousemove : function (a) {
			this.fillMouseEvent(a);
			a.complexType = "mousemove";
			this.trigger(a.complexType, a)
		},
		mouseenterleave : function (a) {
			this.fillMouseEvent(a);
			a.complexType = this.getKeyModifier(a) + a.type;
			this.trigger(a.complexType, a)
		},
		mouseup : function (a) {
			this.fillMouseEvent(a);
			a.complexType = "mouse" + a.which.toString() + ":up";
			this.trigger(a.complexType, a)
		},
		mousedwn : function (a) {
			this.fillMouseEvent(a);
			a.complexType = "mouse" + a.which.toString() + ":down";
			this.trigger(a.complexType, a)
		},
		dblclick : function (a) {
			this.fillMouseEvent(a);
			a.complexType = "dblclick";
			this.trigger(a.complexType, a)
		},
		mousewheel : function (a) {
			a.preventDefault();
			a.complexType = "scroll:" + (0 < a.originalEvent.wheelDelta ? "up" : "down");
			this.trigger(a.complexType, a)
		},
		DOMMouseScroll : function (a) {
			a.preventDefault();
			a.complexType = "scroll:" + (0 < a.originalEvent.detail ? "down" : "up");
			this.trigger(a.complexType, a)
		},
		contextmenu : function (a) {
			a.preventDefault();
			return !1
		},
		getKeyCode : function (a) {
			switch (a.which) {
			case 8:
				return "backspace";
			case 13:
				return "enter";
			case 16:
				return "shift";
			case 27:
				return "esc";
			case 32:
				return "space";
			case 33:
				return "pgup";
			case 34:
				return "pgdown";
			case 37:
				return "arrowleft";
			case 38:
				return "arrowup";
			case 39:
				return "arrowright";
			case 40:
				return "arrowdown";
			case 46:
				return "del";
			case 107:
				return "+";
			case 109:
				return "-";
			default:
				if (65 <= a.which && 90 >= a.which || 48 <= a.which && 57 >= a.which)
					return String.fromCharCode(a.which).toLowerCase();
				if (97 <= a.which && 105 >= a.which)
					return "num" +
					(a.which - 96)
			}
			return ""
		},
		keyup : function (a) {
			var b = this.getKeyCode(a);
			a.complexType = b + ":up";
			"" !== b && this.trigger(a.complexType, a)
		},
		keydown : function (a) {
			var b = this.getKeyModifier(a);
			"" !== b && (b += "+");
			b += this.getKeyCode(a);
			a.complexType = b + ":down";
			"" !== b && this.trigger(a.complexType, a)
		}
	});
window.skim = skim;
