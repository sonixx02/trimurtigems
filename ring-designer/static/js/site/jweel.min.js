var site = site || {};
site.toolModes = {
	edit : "edit",
	view : "view"
};
site.mats = {};
site.fillMatsMap = function () {
	site.mats = {
		silver : {
			"default" : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(16250089),
					vRoughness : 0.1,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			},
			hg : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(16250089),
					vRoughness : 0.1,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			},
			sb : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(16250089),
					vRoughness : 0.79,
					vMetallic : 0.85,
					lightIntensity : 3,
					saturation : 0.3
				}
			},
			antique : {
				name : "Physical Material uRoughness uMetallic",
				uniforms : {
					vRoughness : 0.2,
					vMetallic : 0.85,
					lightIntensity : 5.5
				}
			}
		},
		gold : {
			"default" : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(15187304),
					vRoughness : 0.1,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			},
			yellow : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(15255687),
					vRoughness : 0.15,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			},
			red : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(15051917),
					vRoughness : 0.15,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			},
			white : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(16250089),
					vRoughness : 0.15,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			},
			yellow18 : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(15255687),
					vRoughness : 0.1,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			},
			red18 : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(15051917),
					vRoughness : 0.1,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			},
			white18 : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(16250089),
					vRoughness : 0.1,
					vMetallic : 0.85,
					lightIntensity : 6,
					saturation : 0.3
				}
			}
		},
		hdss : {
			"default" : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(10395545),
					vRoughness : 0.85,
					vMetallic : 0.9,
					lightIntensity : 3,
					saturation : 0.3
				}
			},
			matt : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(10395545),
					vRoughness : 0.85,
					vMetallic : 0.9,
					lightIntensity : 3,
					saturation : 0.3
				}
			},
			satin : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(14343638),
					vRoughness : 0.7,
					vMetallic : 0.9,
					lightIntensity : 3,
					saturation : 0.3
				}
			},
			gloss : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(10395545),
					vRoughness : 0.6,
					vMetallic : 0.9,
					lightIntensity : 3,
					saturation : 0.3
				}
			}
		},
		brass : {
			"default" : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(14528619),
					vRoughness : 0.45,
					vMetallic : 0.85,
					lightIntensity : 1.5,
					saturation : 0.3
				}
			},
			npuc : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(14528619),
					vRoughness : 0.45,
					vMetallic : 0.85,
					lightIntensity : 1.5,
					saturation : 0.3
				}
			}
		},
		bronze : {
			"default" : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(11503709),
					vRoughness : 0.45,
					vMetallic : 0.85,
					lightIntensity : 3,
					saturation : 0.3
				}
			},
			nu : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(11503709),
					vRoughness : 0.7,
					vMetallic : 0.85,
					lightIntensity : 3,
					saturation : 0.3
				}
			},
			npuc : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(11503709),
					vRoughness : 0.7,
					vMetallic : 0.85,
					lightIntensity : 3,
					saturation : 0.3
				}
			},
			ppuc : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(11503709),
					vRoughness : 0.45,
					vMetallic : 0.85,
					lightIntensity : 3,
					saturation : 0.3
				}
			}
		},
		titanium : {
			"default" : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(10525840),
					vRoughness : 0.45,
					vMetallic : 0.85,
					lightIntensity : 1.5,
					saturation : 0.3
				}
			},
			lgp : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(10525840),
					vRoughness : 0.45,
					vMetallic : 0.85,
					lightIntensity : 1.5,
					saturation : 0.3
				}
			},
			lg : {
				name : "Uniform Physical Material",
				uniforms : {
					baseColor : new THREE.Color(10525840),
					vRoughness : 0.7,
					vMetallic : 0.85,
					lightIntensity : 1.5,
					saturation : 0.3
				}
			}
		}
	}
};
site.LoaderNode = function (a, b, c) {
	null === a ? console.error("Jweel - Tool creation can't occur without a canvas or a mode") : (this.canvas = a, this.showCanvas = !0, this.mode = b || site.toolModes.view, a = c || {}, a.updateToolMenu || (a.updateToolMenu = function () {}), a.donePostInit || (a.donePostInit = function () {}), a.doneSurface || (a.doneSurface = function () {}), a.surfaceShown || (a.surfaceShown = function () {}), a.surfaceHidden || (a.surfaceHidden = function () {}), a.helperUpdate || (a.helperUpdate = function () {}), a.showSymmetries || (a.showSymmetries =
			function () {}), a.updateObjectData || (a.updateObjectData = function () {}), a.startSurface || (a.startSurface = function () {}), this.pageInterface = a, this.promptOnStart = !0, this.loadingGif = $("<img/>", {
				"class" : "button-loading",
				src : window.media + "/static/img/elt/loading.gif"
			}), this.computeWarning = this.progress = null, this.defaultParams = {}, this.defaultParams.jsonInfo = {}, this.defaultParams.toolInfo = {}, this.defaultParams.init = {
			canvas : this.canvas,
			ressourcesPath : window.media + "/static/js/skim",
			colorFront : 15921647,
			colorBack : 15921647,
			shading : "exp",
			colors : {
				verticesColors : {
					defaultColor : 2394508,
					highlight : 16158348,
					symHighlight : 16158348,
					selected : 16667989,
					merged : 16711680,
					onSymPlane : 2394508
				},
				primitivesColors : {
					defaultColor : 2394508,
					highlight : 16158348,
					symHighlight : 16158348,
					selected : 16667989,
					merged : 16711680,
					onSymPlane : 2394508
				}
			},
			rotcamSpeed : -0.3,
			initCamPos : {
				rotNode : {
					px : 0,
					py : 0,
					pz : 0,
					rx : -1.5,
					ry : 0.5,
					rz : 3
				},
				distToTarget : 700
			},
			symPlaneXColor : 16354701,
			symPlaneYColor : 16354701,
			symPlaneZColor : 16354701
		}, this.initParams = {}, this.setDefaultParams(), this.filesToLoad =
			"/static/js/backbone/underscore-min.js /static/js/backbone/backbone.js /static/js/threejs/build/three.js /static/js/threejs/examples/js/libs/dat.gui.min.js /static/js/site/tools/base/SMDef.js /static/js/site/bootbox.min.js /static/js/site/objmtloader.js /static/js/skim/skim.min.js".split(" "), this.loadFiles(), this.storageKey = "skimlab-code")
};
site.LoaderNode.prototype.loadFiles = function () {
	window.imgmedia = window.media + "/static/img/cubeMaps";
	window.imgmediaEnv = window.media + "/static/img/envMaps";
	window.shader = window.media + "/static/shaders";
	for (var a = [], b = 0; b < this.filesToLoad.length; b++)
		a.push(window.media + this.filesToLoad[b]);
	head.js.apply(head.js, a);
	var c = this;
	head.ready(function () {
		c.specializeFunctors();
		c.specializeTransformer();
		c.buildInitParams();
		site.fillMatsMap()
	})
};
site.LoaderNode.prototype.buildInitParams = function () {
	$.extend(this.initParams, this.defaultParams.init);
	this.initParams.postInit = this.getPostInit();
	this.initParams.pageInterface = {
		renderProgress : this.getUpdateRenderStatus(),
		onError : this.getOnError(),
		doneSurface : this.getDoneSurface(),
		startSurface : this.getStartSurface(),
		surfaceShown : this.getSurfaceShown(),
		surfaceHidden : this.getSurfaceHidden(),
		helperUpdate : this.getHelperUpdate(),
		showSymmetries : this.getShowSymmetries(),
		updateObjectData : this.getUpdateObjectData()
	};
	this.initParams.statemachine = viewCamStateMachine;
	this.initParams.cameraTarget = skim.CAMERA_TARGET_0
};
site.LoaderNode.prototype.getDoneSurface = function () {
	var a = this;
	return function () {
		$(".surface-show-hook").prop("disabled", !1);
		null !== a.progress && a.progress.done();
		a.qualityWarning && a.qualityWarning.show();
		a.computeWarning.stopTimer();
		a.pageInterface.doneSurface()
	}
};
site.LoaderNode.prototype.getStartSurface = function () {
	var a = this;
	return function () {
		$(".surface-show-hook").prop("disabled", !0);
		a.progress.show();
		a.pageInterface.startSurface();
		a.computeWarning.startTimer()
	}
};
site.LoaderNode.prototype.getSurfaceShown = function () {
	var a = this;
	return function () {
		a.pageInterface.surfaceShown()
	}
};
site.LoaderNode.prototype.getSurfaceHidden = function () {
	var a = this;
	return function () {
		a.pageInterface.surfaceHidden()
	}
};
site.LoaderNode.prototype.getHelperUpdate = function () {
	var a = this;
	return function (b, c) {
		a.pageInterface.helperUpdate(b, c)
	}
};
site.LoaderNode.prototype.getShowSymmetries = function () {
	var a = this;
	return function (b) {
		a.pageInterface.showSymmetries(b)
	}
};
site.LoaderNode.prototype.getUpdateObjectData = function () {
	var a = this;
	return function (b, c, d) {
		a.pageInterface.updateObjectData(b, c, d)
	}
};
site.LoaderNode.prototype.getToolType = function () {
	return this.toolType
};
site.LoaderNode.prototype.savejsonInfo = function () {
	return JSON.stringify(skim.engine.getJSON())
};
site.LoaderNode.prototype.saveToolInfo = function () {
	return JSON.stringify(this.toolInfo)
};
site.LoaderNode.prototype.loadjsonInfo = function (a) {
	this.promptOnStart = !1;
	this.setjsonInfo(a)
};
site.LoaderNode.prototype.loadToolInfo = function (a) {
	this.promptOnStart = !1;
	this.toolInfo = JSON.parse(a)
};
site.LoaderNode.prototype.setjsonInfo = function (a) {
    if(typeof a === "string"){
        console.warn("jsonInfo should be a js object, not a string, parsing...");
        a = JSON.parse(a);
    }
	this.jsonInfo = a
};
site.LoaderNode.prototype.setToolInfo = function (a) {
	for (var b = Object.keys(a), c = {}, d = 0; d < b.length; ++d)
		c[b[d]] = a[b[d]];
	this.toolInfo = c
};
site.LoaderNode.prototype.getToolInfo = function () {
	return this.toolInfo
};
site.LoaderNode.prototype.init = function () {
	var a = this;
	head.ready(function () {
		skim.init(a.initParams) || (_track.evt("webGLError"), bootbox.alert("<b>" + gettext("Votre navigateur ne supporte pas") + " <a target='_blank' href='" + gettext("http://get.webgl.org/") + "'>" + gettext("le contenu 3D") + "</a>.</b> " + gettext("Pour activer la 3D (webGL) sur votre navigateur, consultez notre") + " <a target='_blank' href='" + window.base_lang_url + "/acc/browser/error/'>" + gettext("page d'assistance") + "</a>."))
	})
};
site.LoaderNode.prototype.setCanvasVisible = function (a) {
	a && $(this.canvas).css("visibility", "visible")
};
site.LoaderNode.prototype.getOnError = function () {
	var a = this;
	return function () {
		console.warn("JweelTool - Recomputing surface on error from worker");
		a.recomputeSurface()
	}
};
site.LoaderNode.prototype.loadObject = function () {
	console.assert(!1, "LoaderNode - tool should define a loadObject function");
	return !1
};
site.LoaderNode.prototype.utilsInit = function () {};
site.LoaderNode.prototype.saveStateAndNotify = function () {
	skim.file.saveState();
	skim.file.notifySave()
};
site.LoaderNode.prototype.startingLoad = function () {
	var a = this;
	this.promptOnStart ? skim.file.promptLocalStorage(gettext("Nous avons trouvé une sauvegarde d'un objet. Voulez vous le charger?"), bootbox.confirm, function () {
		a.loadObject();
		a.saveStateAndNotify()
	}, function (b) {
		a.setjsonInfo(b);
		a.loadObject();
		a.saveStateAndNotify()
	}) : (this.loadObject(), this.saveStateAndNotify())
};
site.LoaderNode.prototype.getPostInit = function () {
	var a = this;
	return function () {
		skim.file.localStorageFileKey = a.storageKey;
		a.utilsInit();
		a.startingLoad();
		skim.file.manageUnloadEvents(gettext("Vous n'avez pas sauvé votre fichier"));
		window.onresize = function (b) {
			skim.instances.modeler.webGLResize(a.canvas)
		};
		$(".action-on-click").each(function () {
			var b = $(this);
			b.attr("data-action-on-click") && b.click(a.getClickTrigger());
			b.attr("data-action-on-hover") && (b.mouseleave(a.getHoverTrigger()), b.mouseenter(a.getHoverTrigger()))
		});
		$(".action-on-click").each(function () {
			$(this).hasClass("surface-show-hook") || $(this).prop("disabled", !1)
		});
		$("select.action-on-click").selectpicker("refresh");
		a.pageInterface.donePostInit(a);
		a.setCanvasVisible(a.showCanvas)
	}
};
site.LoaderNode.prototype.resetEverything = function () {
	skim.engine.reset();
	this.setDefaultParams();
	this.loadObject();
	window.history.replaceState("Object", "Title", window.base_lang_url + "/tools/" + this.toolType + "/")
};
site.LoaderNode.prototype.triggerEvent = function (a) {
	void 0 !== a && (null !== a && "" !== a) && (a = {
			complexType : a,
			preventDefault : function () {},
			stopPropagation : function () {}

		}, skim.instances.modeler.viewManager.mainCanvasView.trigger(a.complexType, a))
};
site.LoaderNode.prototype.getClickTrigger = function () {
	var a = this;
	return function () {
		a.triggerEvent($(this).attr("data-action-on-click"))
	}
};
site.LoaderNode.prototype.getHoverTrigger = function () {
	var a = this;
	return function () {
		a.triggerEvent($(this).attr("data-action-on-hover"))
	}
};
site.LoaderNode.prototype.loadMaterial = function (a, b) {
	var c = site.mats,
	d = a || "silver",
	e = void 0 !== c[d][b] ? c[d][b] : c[d]["default"];
	skim.gl_materials[e.name].get(function (a) {
		if (void 0 !== e.uniforms)
			for (var b = Object.keys(e.uniforms), c = 0; c < b.length; ++c)
				a.mat.uniforms[b[c]].value = e.uniforms[b[c]];
		skim.instances.modeler.sceneManager.setSurfaceMaterial(a.mat)
	})
};
site.LoaderNode.prototype.loadSkimObj = function (a) {
	var b = this;
	$.ajax({
		type : "GET",
		url : "http://www.skimlab.com/file/" + a + "/",
		success : function (a) {
			b.setjsonInfo(a);
			b.loadObject()
		}
	})
};
site.LoaderNode.prototype.notifySave = function (a) {
	skim.file.notifySave()
};
site.LoaderNode.prototype.engineIsEmpty = function () {
	var a = Object.keys(skim.engine.vars.vertices),
	b = Object.keys(skim.engine.vars.primitives);
	return 0 === a.length && 0 === b.length
};
site.LoaderNode.prototype.showSurface = function () {
	skim.instances.modeler.sceneManager.setShowSurface(!0)
};
site.LoaderNode.prototype.hideSurface = function () {
	skim.instances.modeler.sceneManager.setShowSurface(!1)
};
site.LoaderNode.prototype.getCamPos = function () {
	return JSON.stringify(skim.instances.modeler.cameraMan.getPosition())
};
site.LoaderNode.prototype.setCamPos = function (a) {
	a && "None" !== a && (a = JSON.parse(a), a.distToTarget = this.defaultParams.init.initCamPos.distToTarget, skim.instances.modeler.cameraMan.setPosition(a), skim.instances.modeler.cameraMan.setTarget(0, 0, 0))
};
site.LoaderNode.prototype.setZoom = function (a) {
	skim.instances.modeler.cameraMan.setTarget(0, 0, 0);
	skim.instances.modeler.cameraMan.setDistToTarget(this.defaultParams.init.initCamPos.distToTarget * a / 100)
};
site.LoaderNode.prototype.takeScreenshots = function (a, b) {
	var c = Math.min($(a).width(), $(a).height());
	skim.instances.modeler.save_object_img([c, c], {
		basic : {
			full : !0,
			thumb : !0
		},
		normal_map : {
			full : !0,
			thumb : !0
		}
	}, b)
};
site.LoaderNode.prototype.exportMesh = function (a, mat) {
	var b = new THREE.Matrix4;
	if (mat) {
		b.copy(mat);
	} else {
		b.identity();
	}
	skim.instances.modeler.exportMesh(a, function (a) {
		console.log("Computing mesh... " + a + "%")
	}, !0, !1, b, 3)
};
site.LoaderNode.prototype.isSurfaceReady = function () {
	return skim.instances.modeler.sceneManager.isReady()
};
site.LoaderNode.prototype.getSurfaceGeometry = function () {
	if (skim.instances.modeler.sceneManager.isReady())
		return skim.instances.modeler.sceneManager.surface_mesh.geometry
};
site.LoaderNode.prototype.specializeTransformer = function () {
	var a = this;
	Transformer.vertex.thick.vertexThickIncreaseAdjustThickness = function (a, c, d, e) {
		Transformer.prim.translate.magnetOnAxis(a, c, d, e)
	};
	Transformer.vertex.translate.vertexTranslateRunAdjustPos = function (a, c, d, e) {
		Transformer.prim.translate.magnetOnAxis(a, c, d, e)
	};
	Transformer.prim.translate.magnetOnAxis = function (a, c, d, e) {
		a = !1;
		if (0 != Object.keys(c.getOwnersRings()).length && void 0 !== skim.engine.getVertexSymmetries(c).z) {
			a = !0;
			var f = 0.5 * c.getThickness();
			if (c.getPos().z <= -f && d.z >= -f || c.getPos().z >= f && d.z <= f) {
				var g = c.getPos().z < -f ? -1 : 1;
				d.z = g * f
			}
			c.getPos().z > -f && c.getPos().z < f && (g = 0 > c.getPos().z ? -1 : 1, d.z = g * f)
		}
		c = ["x", "y", "z"];
		for (f = 0; f < c.length; ++f)
			("z" != c[f] || !a) && (Math.abs(d[c[f]]) < 0.5 * e.t && Math.abs(d[c[f]]) > skim.engine.functorPrecision) && (d[c[f]] = 0)
	};
	Transformer.step = {
		prev : function () {
			skim.file.restoreLastState();
			a.recomputeSurface()
		},
		next : function () {
			skim.file.restoreNextState();
			a.recomputeSurface()
		}
	}
};
site.LoaderNode.prototype.specializeFunctors = function () {};
site.LoaderNode.prototype.recomputeSurface = function () {
	this.setjsonInfo(skim.engine.getJSON());
	skim.instances.modeler.meshManager.resetMeshesComputation();
	skim.instances.modeler.sceneManager.setShowSurface(!1);
	this.loadObject()
};
site.LoaderNode.prototype.addPrimInfo = function (a) {
	var b = Object.keys(skim.engine.vars.vertices),
	c = Object.keys(skim.engine.vars.primitives);
	a.prims = 0 !== c.length ? skim.engine.vars.primitives[c[0]].getVolType() === skim.VolType.Orga ? "orga" : "mecha" : 0 !== b.length ? skim.engine.vars.vertices[b[0]].getVolType() === skim.VolType.Orga ? "orga" : "mecha" : Transformer.creation.mode.type === skim.VolType.Orga ? "orga" : "mecha"
};
site.LoaderNode.prototype.cloneToolInfo = function () {
	return $.extend({}, this.toolInfo)
};
site.LoaderNode.prototype.switchBlend = function (a) {
	var b = a || "orga";
	a = skim.VolType.Orga;
	switch (b) {
	case "orga":
		this.toolInfo.prims = "orga";
		a = skim.VolType.Orga;
		break;
	case "mecha":
		this.toolInfo.prims = "mecha";
		a = skim.VolType.Mech;
		break;
	default:
		console.error("JweelLoader - switchBlend does not know of this '" + b + "' you be talking about.")
	}
	Transformer.creation.setModeVolType(a);
	for (var c = Object.keys(skim.engine.vars.vertices), b = 0; b < c.length; ++b)
		skim.engine.vars.vertices[c[b]].setVolType(a);
	c = Object.keys(skim.engine.vars.primitives);
	for (b = 0; b < c.length; ++b)
		skim.engine.vars.primitives[c[b]].setVolType(a);
	Transformer.creation.setModeVolType(a);
	skim.file.saveState();
	skim.engine.update_skeleton();
	skim.engine.update_parametrics();
	skim.engine.update_blobtree();
	this.recomputeSurface()
};
site.LoaderNode.prototype.getUpdateRenderStatus = function () {
	var a = this;
	return function (b, c) {
		a.progress.update(c);
		a.computeWarning.pingTimer()
	}
};
site.LoaderNode.prototype.setDefaultParams = function () {
	this.setjsonInfo(this.defaultParams.jsonInfo);
	this.toolInfo = {};
	$.extend(this.toolInfo, this.defaultParams.toolInfo)
};
site.LoaderNode.prototype.prepToolForSave = function (a) {
	a(function () {})
};
site.JweelProgress = function (a) {};
site.JweelProgress.prototype.update = function (a) {
	console.log("ImplementationError")
};
site.JweelProgress.prototype.hide = function (a) {
	console.log("ImplementationError")
};
site.JweelProgress.prototype.show = function (a) {
	console.log("ImplementationError")
};
site.JweelProgress2D = function (a) {
	this.canvas = a;
	this.box = $("<div/>", {
			"class" : "box-generating no-select",
			css : {
				display : "none"
			}
		}).append($("<a/>", {
				id : "box-generating",
				href : "#",
				"class" : "error",
				css : {
					display : "none"
				}
			}), $("<img/>", {
				alt : "jweel",
				"class" : "img-circle",
				src : window.media + "/static/img/logo/transparent_j_trimmed.png"
			}), $("<input/>", {
				id : "generating-progress",
				"data-width" : "100",
				"data-height" : "100",
				type : "text",
				value : "0",
				"class" : "progress-knob"
			}));
	$(this.canvas).parent().append(this.box);
	$(".progress-knob").knob({
		min : 0,
		max : 100,
		fgColor : "#002E32",
		skin : "tron",
		thickness : ".2",
		readOnly : !0,
		bgcolor : "#444"
	})
};
site.JweelProgress2D.prototype = Object.create(site.JweelProgress.prototype);
site.JweelProgress2D.constructor = site.JweelProgress;
site.JweelProgress2D.prototype.update = function (a) {
	$("#generating-progress").val(a).trigger("change")
};
site.JweelProgress2D.prototype.hide = function (a) {
	this.box.fadeOut(100, a)
};
site.JweelProgress2D.prototype.show = function (a) {
	this.box.fadeIn(100, a)
};
site.JweelProgress2D.prototype.done = function (a) {
	this.hide()
};
site.JweelProgress3D = function (a) {
	this.j_textures = {
		colored : THREE.ImageUtils.loadTexture(window.media + "/static/img/logo/J_logotype_512_color.png"),
		grey : THREE.ImageUtils.loadTexture(window.media + "/static/img/logo/J_logotype_512_grey.png")
	};
	var b = new THREE.Mesh(new THREE.CircleGeometry(0.6, 80), new THREE.MeshBasicMaterial({
				map : this.j_textures.grey,
				opacity : 0.7,
				transparent : !0,
				side : THREE.DoubleSide
			})),
	c = new THREE.Mesh(new THREE.Geometry, new THREE.MeshBasicMaterial({
				color : 14079183,
				opacity : 0.7,
				transparent : !0,
				side : THREE.DoubleSide
			})),
	d = new THREE.Line(new THREE.Geometry, new THREE.LineBasicMaterial({
				color : 12236979,
				opacity : 1,
				transparent : !0
			})),
	e = c.geometry.vertices,
	f = c.geometry.faces;
	this.subdiv = 80;
	for (var g = 0; g < this.subdiv; ++g) {
		var h = -2 * Math.PI * (g / this.subdiv) - Math.PI / 2;
		e.push(new THREE.Vector3(0.8 * Math.cos(h), 0.8 * Math.sin(h), 0));
		e.push(e[e.length - 1].clone().multiplyScalar(1.25))
	}
	for (g = 0; g < this.subdiv - 1; ++g)
		f.push(new THREE.Face3(2 * g, 2 * g + 3, 2 * g + 1)), f.push(new THREE.Face3(2 * g, 2 * g + 2, 2 * g + 3));
	f.push(new THREE.Face3(2 *
			this.subdiv - 2, 1, 2 * this.subdiv - 1));
	for (g = f = this.subdiv - this.subdiv / 20; g < f + this.subdiv / 20; ++g)
		h = (g - f) / (this.subdiv / 20), e[2 * g].set(e[2 * f].x * (1 - h) + e[1].x * h, e[2 * f].y * (1 - h) + e[1].y * h, e[2 * f].z * (1 - h) + e[1].z * h);
	d.geometry.vertices.push(e[0].clone());
	for (g = 1; g < e.length; g += 2)
		d.geometry.vertices.push(e[g].clone());
	d.geometry.vertices.push(e[1].clone());
	for (g = e.length - 2; 0 <= g; g -= 2)
		d.geometry.vertices.push(e[g].clone());
	d.geometry.vertices.push(e[0].clone());
	b.rotation.copy(a.rotation);
	b.position.copy(a.position);
	b.scale.copy(a.scale);
	c.rotation.copy(a.rotation);
	c.position.copy(a.position);
	c.scale.copy(a.scale);
	d.rotation.copy(a.rotation);
	d.position.copy(a.position);
	d.scale.copy(a.scale);
	skim.instances.modeler.sceneManager.addNeutralMesh("jweel_logo_3D_frame", d);
	skim.instances.modeler.sceneManager.addNeutralMesh("jweel_logo_3D_J", b);
	skim.instances.modeler.sceneManager.addNeutralMesh("jweel_logo_3D_around", c)
};
site.JweelProgress3D.prototype = Object.create(site.JweelProgress.prototype);
site.JweelProgress3D.constructor = site.JweelProgress;
site.JweelProgress3D.prototype.update = function (a) {
	var b = skim.instances.modeler.sceneManager.getNeutralMesh("jweel_logo_3D_around"),
	c = b.geometry.faces;
	a = Math.round(0.01 * a * this.subdiv);
	for (var d = 0; d < a - 1; ++d)
		c[2 * d] = new THREE.Face3(2 * d, 2 * d + 3, 2 * d + 1), c[2 * d + 1] = new THREE.Face3(2 * d, 2 * d + 2, 2 * d + 3);
	0 == a && (a = 1, d = skim.instances.modeler.sceneManager.getNeutralMesh("jweel_logo_3D_J"), d.material.map = this.j_textures.grey, skim.instances.modeler.sceneManager.setNeutralMeshMaterial("jweel_logo_3D_J", d.material), skim.instances.modeler.sceneManager.setNeutralMeshVisible("jweel_logo_3D_frame",
			!0));
	for (d = a - 1; d < this.subdiv - 1; ++d)
		c[2 * d] = new THREE.Face3(0, 0, 0), c[2 * d + 1] = new THREE.Face3(0, 0, 0);
	a == this.subdiv ? (c[2 * this.subdiv - 2] = new THREE.Face3(2 * this.subdiv - 2, 1, 2 * this.subdiv - 1), d = skim.instances.modeler.sceneManager.getNeutralMesh("jweel_logo_3D_J"), skim.instances.modeler.sceneManager.setNeutralMeshMaterial("jweel_logo_3D_J", d.material), skim.instances.modeler.sceneManager.setNeutralMeshVisible("jweel_logo_3D_frame", !1)) : c[2 * this.subdiv - 2] = new THREE.Face3(0, 0, 0);
	b.geometry.verticesNeedUpdate =
		!0;
	skim.instances.modeler.sceneManager.neutralMeshUpdated("jweel_logo_3D_around")
};
site.JweelProgress3D.prototype.hide = function () {
	skim.instances.modeler.sceneManager.setNeutralMeshVisible("jweel_logo_3D_frame", !1);
	skim.instances.modeler.sceneManager.setNeutralMeshVisible("jweel_logo_3D_J", !1);
	skim.instances.modeler.sceneManager.setNeutralMeshVisible("jweel_logo_3D_around", !1)
};
site.JweelProgress3D.prototype.show = function () {
	skim.instances.modeler.sceneManager.setNeutralMeshVisible("jweel_logo_3D_frame", !0);
	skim.instances.modeler.sceneManager.setNeutralMeshVisible("jweel_logo_3D_J", !0);
	skim.instances.modeler.sceneManager.setNeutralMeshVisible("jweel_logo_3D_around", !0)
};
site.JweelProgress3D.prototype.done = function (a) {};
site.ForbiddenCylinder = function (a) {
	this.meshName = "ForbiddenCylinder";
	this.radiusSegments = 32;
	this.systemAllows = this.userWants = !0;
	var b = new THREE.CylinderGeometry(1, 1, 2 * a.zLimit, this.radiusSegments),
	c = new THREE.MeshBasicMaterial({
			color : 16354701,
			opacity : 0.2,
			transparent : !0,
			side : THREE.FrontSide
		}),
	b = new THREE.Mesh(b, c),
	c = a.XPlane ? new THREE.Euler(0, 0, -Math.PI / 2) : new THREE.Euler(0, Math.PI / 2, -Math.PI / 2);
	b.rotation.copy(c);
	b.position.setY(a.yCenterPos);
	b.scale.set(a.innerRadius, 1, a.innerRadius);
	skim.instances.modeler.sceneManager.addNeutralMesh(this.meshName,
		b);
	this.askedHidden = !1
};
site.ForbiddenCylinder.prototype.update = function (a) {
	if (a.isPresent) {
		this.systemAllows = !0;
		var b = skim.instances.modeler.sceneManager.getNeutralMesh(this.meshName),
		c = a.XPlane ? new THREE.Euler(0, 0, -Math.PI / 2) : new THREE.Euler(0, Math.PI / 2, -Math.PI / 2);
		b.rotation.copy(c);
		b.position.setY(a.yCenterPos);
		b.scale.set(a.innerRadius, 1, a.innerRadius);
		skim.instances.modeler.sceneManager.neutralMeshUpdated(this.meshName);
		this.show()
	} else
		this.systemAllows = !1, this.hide()
};
site.ForbiddenCylinder.prototype.setUserWants = function (a) {
	this.userWants = a
};
site.ForbiddenCylinder.prototype.setSystemAllows = function (a) {
	this.systemAllows = a
};
site.ForbiddenCylinder.prototype.hide = function () {
	skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.meshName, !1);
	this.askedHidden = !0
};
site.ForbiddenCylinder.prototype.show = function () {
	this.userWants && this.systemAllows ? skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.meshName, !0) : skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.meshName, !1)
};
site.PlaneGrid = function () {
	this.meshName = "zPlaneGrid";
	this.textNameFront = "zPlaneGridTextFront";
	this.textNameBack = "zPlaneGridTextBack";
	this.showable = !0;
	var a = new THREE.GridHelper(250, 50);
	a.rotation.x = Math.PI / 2;
	a.setColors(new THREE.Color(10724259), new THREE.Color(14079183));
	skim.instances.modeler.sceneManager.addNeutralMesh(this.meshName, a);
	a = this.getMeshText(!0);
	skim.instances.modeler.sceneManager.addNeutralMesh(this.textNameFront, a);
	a = this.getMeshText(!1);
	skim.instances.modeler.sceneManager.addNeutralMesh(this.textNameBack,
		a)
};
site.PlaneGrid.prototype.getMeshText = function (a) {
	var b = document.createElement("canvas"),
	c = b.getContext("2d");
	b.width = 250;
	b.height = 125;
	c = b.getContext("2d");
	c.font = "20px Arial";
	c.textAlign = "bottom";
	c.textBaseline = "middle";
	a || (c.translate(b.width, 0), c.scale(-1, 1));
	var d = c.measureText("0.5cm").width;
	c.fillStyle = "#A3A3A3";
	var e = b.width / (2 * d);
	c.scale(e, e);
	c.fillText("0.5cm", (b.width / 2 - d) / e, (b.height / 2 + 18) / e);
	c.scale(1 / e, 1 / e);
	var d = 0.08 * b.height,
	e = 0.08 * b.height,
	f = 0.9 * b.height;
	c.beginPath();
	c.moveTo(d, f);
	c.lineTo(b.width - d, f);
	c.lineWidth = 0.05 * b.height;
	c.strokeStyle = "#A3A3A3";
	c.stroke();
	c.beginPath();
	c.moveTo(0, f);
	c.lineTo(d, f + e);
	c.lineTo(d, f - e);
	c.closePath();
	c.fill();
	c.beginPath();
	c.moveTo(b.width, f);
	c.lineTo(b.width - d, f + e);
	c.lineTo(b.width - d, f - e);
	c.closePath();
	c.fill();
	c = new THREE.Texture(b);
	c.needsUpdate = !0;
	a = new THREE.MeshBasicMaterial({
			map : c,
			transparent : !0,
			side : a ? THREE.FrontSide : THREE.BackSide
		});
	a = new THREE.Mesh(new THREE.PlaneGeometry(b.width, b.height), a);
	a.position.x = 225;
	a.position.y = 260;
	b =
		50 / b.width;
	a.scale.x = b;
	a.scale.y = b;
	return a
};
site.PlaneGrid.prototype.hide = function () {
	skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.textNameFront, !1);
	skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.textNameBack, !1);
	skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.meshName, !1)
};
site.PlaneGrid.prototype.show = function () {
	this.showable ? (skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.textNameFront, !0), skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.textNameBack, !0), skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.meshName, !0)) : (skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.textNameFront, !1), skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.textNameBack, !1), skim.instances.modeler.sceneManager.setNeutralMeshVisible(this.meshName,
			!1))
};
site.PlaneGrid.prototype.toggle = function () {
	(this.showable = !this.showable) ? this.show() : this.hide()
};
site.JweelComputationWarning = function (a) {
	this.box = null;
	this.toolOwner = a;
	a = a.canvas.parentNode;
	if (null !== a) {
		this.box = $("<div/>", {
				"class" : "alert alert-warning alert-bottom alert-surfacestopped alert-dismissable",
				css : {
					display : "none"
				}
			}).append($("<p/>", {
					text : gettext("Calcul anormalement lent") + "...",
					css : {
						"text-align" : "center"
					}
				}).append($("<a/>", {
						href : "#",
						"class" : "recompute-surface-trigger alert-link",
						text : gettext(" Relancer"),
						css : {
							"margin-left" : "10px"
						}
					})));
		$(a).append(this.box);
		var b = this;
		$(".recompute-surface-trigger").click(function () {
			b.toolOwner.computeWarning.hide();
			b.toolOwner.recomputeSurface()
		})
	}
	this.timer = null
};
site.JweelComputationWarning.prototype.hide = function () {
	this.box && this.box.fadeOut()
};
site.JweelComputationWarning.prototype.show = function () {
	this.box && this.box.fadeIn()
};
site.JweelComputationWarning.prototype.stopTimer = function () {
	this.hide();
	window.clearTimeout(this.timer)
};
site.JweelComputationWarning.prototype.startTimer = function () {
	this.stopTimer();
	var a = this;
	this.timer = window.setTimeout(function () {
			a.toolOwner.computeWarning.show()
		}, 3E3)
};
site.JweelComputationWarning.prototype.pingTimer = site.JweelComputationWarning.prototype.startTimer;
site.qualityWarning = function (a, b) {
	this.toolOwner = a;
	this.fastMode = "LQ" === b;
	this.qualBox = this.fastBox = null;
	this.fastButton = $("<button/>", {
			type : "button",
			"class" : "btn",
			"aria-hidden" : "true",
			text : gettext("Générer en HD")
		});
	this.fastBox = $("<div/>", {
			"class" : "alert alert-bottom alert-warning alert-fastqual"
		}).append($("<button/>", {
				type : "button",
				"class" : "close boxClose",
				"aria-hidden" : "true",
				text : "x"
			}), $("<p/>", {
				text : gettext("Objet généré en mode rapide. Pour augmenter la qualité du visuel, vous pouvez activer le mode HD (Rendu plus lent).")
			}));
	this.qualButton = $("<button/>", {
			type : "button",
			"class" : "btn",
			"aria-hidden" : "true",
			text : gettext("Activer la génération rapide")
		});
	this.qualBox = $("<div/>", {
			"class" : "alert alert-bottom alert-warning alert-highqual"
		}).append($("<button/>", {
				type : "button",
				"class" : "close boxClose",
				"aria-hidden" : "true",
				text : "x"
			}), $("<p/>", {
				text : gettext("Le calcul de votre objet est en mode haute précision. Si vous le désirez, vous pouvez diminuer le temps de calcul au prix d'une perte de précision sur l'aperçu du modèle...")
			}));
	this.fastBox.append(this.fastButton);
	this.qualBox.append(this.qualButton);
	$(this.toolOwner.canvas).parent().append(this.fastBox);
	$(this.toolOwner.canvas).parent().append(this.qualBox);
	var c = this;
	$(".boxClose").click(function () {
		c.hide()
	});
	this.fastButton.click(function () {
		c.setHigh()
	});
	this.qualButton.click(function () {
		c.setFast()
	})
};
site.qualityWarning.prototype.hide = function () {
	this.fastBox.fadeOut();
	this.qualBox.fadeOut()
};
site.qualityWarning.prototype.show = function () {
	this.fastMode ? this.fastBox.fadeIn() : this.qualBox.fadeIn()
};
site.qualityWarning.prototype.setHigh = function () {
	this.hide();
	this.toolOwner.setNiceGeneration();
	this.toolOwner.loadObject();
	this.fastMode = !1
};
site.qualityWarning.prototype.setFast = function () {
	this.hide();
	this.toolOwner.setFastGeneration();
	this.toolOwner.loadObject();
	this.fastMode = !0
};
site.Geometry = {};
site.Geometry.RadialCoordExtractor = function (a, b, c) {
	this.radius = a;
	this.yOffset = b;
	this.XPlane = c
};
site.Geometry.RadialCoordExtractor.prototype.get3DFrom2D = function (a, b) {
	var c = b || 0;
	return {
		x : this.XPlane ? c : a.x,
		y : a.y + this.yOffset,
		z : this.XPlane ? a.x : c
	}
};
site.Geometry.RadialCoordExtractor.prototype.get2DFrom3D = function (a) {
	return {
		x : this.XPlane ? a.z : a.x,
		y : a.y - this.yOffset
	}
};
site.Geometry.RadialCoordExtractor.prototype.getZFrom3D = function (a) {
	return this.XPlane ? a.x : a.z
};
site.Geometry.RadialCoordExtractor.prototype.get2DFromAngle = function (a, b) {
	return {
		x : this.radius * Math.cos(a),
		y : this.radius * b * Math.sin(a)
	}
};
site.Geometry.RadialCoordExtractor.prototype.getAngleFrom2D = function (a) {
	return skim.geometry.GetXAngleFromPoint(new THREE.Vector3(a.x, a.y, 0))
};
site.debugObj = function (a, b) {
	console.log("%c" + a + ": " + JSON.stringify(b, function (a) {
			var b = 0;
			return function (e, f) {
				if (0 !== b && "object" === typeof a && "object" == typeof f && a == f)
					return "[Circular]";
				if (0 !== b && "object" == typeof f)
					return "[Object]";
				if (29 <= b)
					return "[Unknown]";
				++b;
				return f
			}
		}
			(b), 2), "color:#16520B")
};
site.SelectRange = function (a, b) {
	this.select = a;
	this.floatingPoint = 1E4;
	this.params = b;
	for (var c = b.postOptionText ? " " + b.postOptionText : "cm", d = b.preOptionText ? b.preOptionText + " " : "", e = (b.max - b.min) / b.step, f = 0; f <= e; f++) {
		var g = Math.round((b.min + f * b.step) * this.floatingPoint) / this.floatingPoint,
		h = g;
		b.visu && (b.visu.min && b.visu.step) && (h = b.visu.min + f * b.visu.step);
		h = 0 === b.step % 1 && 0 === b.min % 1 ? h.toFixed() : h.toFixed(2);
		this.select.append($("<option/>", {
				value : g
			}).text(d + " " + h + c))
	}
	this.select.selectpicker();
	this.select.prop("disabled",
		b.disabled);
	this.select.val(b.value);
	var l = this,
	k = b.change || function () {};
	this.select.change(function () {
		k("customEvent", {
			value : l.select.selectpicker("val")
		})
	});
	this.select.selectpicker("refresh")
};
site.SelectRange.prototype.getNear = function (a) {
	a = this.params.min + this.params.step * Math.round((a - this.params.min) / this.params.step);
	a = Math.round(a * this.floatingPoint) / this.floatingPoint;
	return a = Math.max(Math.min(a, this.params.max), this.params.min)
};
site.SelectRange.prototype.getNext = function (a) {
	return Math.min((a * this.floatingPoint + this.params.step * this.floatingPoint) / this.floatingPoint, this.params.max)
};
site.SelectRange.prototype.getPrevious = function (a) {
	return Math.max((a * this.floatingPoint - this.params.step * this.floatingPoint) / this.floatingPoint, this.params.min)
};
site.JweelEditor = function (a) {
	this.params = a;
	this.toolInfo = {};
	this.pannelManager = null;
	this.createPannelManager({
		ui : a.ui.pannel,
		callbacks : a.callbacks
	})
};
site.JweelEditor.prototype.createPannelManager = function (a) {
	this.pannelManager = new site.EditorPannelManager(a)
};
site.JweelEditor.prototype.getToolInfo = function () {
	console.error("JweelEditor - getToolInfo is virtual and should be redefined");
	return !1
};
site.JweelEditor.prototype.setToolInfo = function (a) {
	console.error("JweelEditor - getToolInfo is virtual and should be redefined");
	return !1
};
site.TextMenu = {};
site.TextMenu.fontList = {
	Norican : "Norican",
	Neon : "Neon",
	Warnes : "Warnes",
	Hardman : "Hardman",
	Alewis : "Alewis",
	Flatline : "Flatline",
	Handlee : "Handlee",
	Rochester : "Rochester",
	Remarcle : "Remarcle",
	MrBedfort : "Mr Bedfort",
	Pacifico : "Pacifico",
	Parisienne : "Parisienne",
	Yesteryear : "Yesteryear",
	AmaticsSC : "Amatics SC",
	BerkshireSwash : "Berkshire Swash",
	ClickerScript : "Clicker Script",
	Damion : "Damion",
	Engagement : "Engagement",
	IndieFlower : "Indie Flower",
	LeagueScript : "League Script",
	LovedByTheKing : "Loved By The King",
	Molle : "Molle",
	Qwigley : "Qwigley",
	ReenieBeanie : "Reeni eBeanie",
	RockSalt : "Rock Salt",
	TheGirlNextDoor : "The Girl Next Door",
	Yellowtail : "Yellowtail"
};
site.TextMenu.ItalicButton = function (a) {
	this.italic = !1;
	this.params = a;
	this.params.callback = a.callback || function () {};
	var b = this;
	a.trigger.click(function () {
		b.italic = !b.italic;
		b.set(b.italic);
		b.params.callback()
	})
};
site.TextMenu.ItalicButton.prototype.set = function (a) {
	this.params.input.css("font-style", a ? "italic" : "normal");
	a ? this.params.trigger.addClass("active") : this.params.trigger.removeClass("active")
};
site.TextMenu.BoldButton = function (a) {
	this.bold = !1;
	this.params = a;
	var b = this;
	a.trigger.click(function () {
		b.bold = !b.bold;
		b.set(b.bold);
		b.params.callback()
	})
};
site.TextMenu.BoldButton.prototype.set = function (a) {
	this.params.input.css("font-weight", a ? "bold" : "normal");
	a ? this.params.trigger.addClass("active") : this.params.trigger.removeClass("active")
};
site.JweelToggleButton = function (a) {
	this.toggled = !1;
	this.params = a;
	this.params.callback = a.callback || function () {};
	void 0 !== a.state && (this.toggled = a.state, this.setButtonLook());
	var b = this;
	a.trigger.click(function () {
		b.toggle()
	})
};
site.JweelToggleButton.prototype.setButtonLook = function () {
	this.toggled ? (this.params.trigger.addClass("active"), this.params.text && this.params.trigger.text(this.params.text.active)) : (this.params.trigger.removeClass("active"), this.params.text && this.params.trigger.text(this.params.text.inactive))
};
site.JweelToggleButton.prototype.toggle = function () {
	this.toggled = !this.toggled;
	this.setButtonLook();
	this.params.callback(this.toggled)
};
site.TextMenu.FontSelect = function (a) {
	this.defaultSelectPreview = "Jweel";
	this.fontList = a.fontList || site.TextMenu.fontList;
	this.params = a;
	this.params.callback = a.callback || function () {};
	this.fontSelect = this.params.select;
	this.buildFontOptions();
	this.fontSelect.change(this.instanciateSelectFont());
	this.params.clickContainer.click(this.instanciateRefresh());
	var b = this;
	this.fontSelect.data("selectpicker").$newElement.on("hidden.bs.dropdown", function () {
		b.fontSelect.find("option:selected")[0].text = b.fontList[b.fontSelect.val()];
		b.fontSelect.selectpicker("refresh")
	});
	this.params.keyEventContainer.keydown(function (a) {
		"13" == a.keyCode ? window.skimGenerateRing() : "38" == a.keyCode ? (a = $("#select-font > option:selected").prev("option"), void 0 !== a.attr("value") && b.fontSelect.selectpicker("val", a.attr("value"))) : "40" == a.keyCode && (a = $("#select-font > option:selected").next("option"), void 0 !== a.attr("value") && b.fontSelect.selectpicker("val", a.attr("value")))
	})
};
site.TextMenu.FontSelect.prototype.buildFontOptions = function () {
	for (var a = Object.keys(this.fontList), b = 0; b < a.length; b++)
		this.fontSelect.append($("<option/>", {
				value : a[b],
				text : this.fontList[a[b]]
			}));
	this.fontSelect.selectpicker()
};
site.TextMenu.FontSelect.prototype.applyFont = function () {
	var a = this.fontSelect.val() + ", Symbols";
	this.params.input.css("font-family", a);
	var b = this.fontSelect.find("option:selected");
	b.attr("fs") && this.params.input.css("font-size", b.attr("fs"));
	b.attr("lh") && this.params.input.css("line-height", b.attr("lh"));
	window.capsOK = "1" === b.attr("caps");
	this.setFontSelectName();
	return a
};
site.TextMenu.FontSelect.prototype.setFontSelectName = function () {
	this.fontSelect.find("option:selected")[0] && (this.fontSelect.find("option:selected")[0].text = this.fontList[this.fontSelect.val()], this.fontSelect.selectpicker("render"))
};
site.TextMenu.FontSelect.prototype.instanciateSelectFont = function () {
	var a = this;
	return function () {
		var b = a.applyFont();
		a.params.callback(b)
	}
};
site.TextMenu.FontSelect.prototype.instanciateRefresh = function () {
	var a = this;
	return function () {
		var b = a.params.input.val().slice(0, 6);
		"" === b && (b = a.defaultSelectPreview);
		a.fontSelect.find("option").each(function () {
			var c = $(this),
			d = c.attr("value");
			c.data("subtext", a.fontList[d]);
			c.css("font-family", c.attr("value") + ", Symbols");
			c.text(b)
		});
		a.fontSelect.selectpicker("refresh")
	}
};
site.SymbolsUtils = {};
site.SymbolsUtils.symbolList = [];
site.SymbolsUtils.symbolList.push({
	id : "miscSymbols",
	range : "\\u0384-\\u03fe",
	name : "Divers"
});
site.SymbolsUtils.symbolList.push({
	id : "geometry",
	range : "\\u1000-\\u1071",
	name : "Géometrie"
});
site.SymbolsUtils.symbolList.push({
	id : "arrows",
	range : "\\u1100-\\u11a2",
	name : "Flèches"
});
site.SymbolsUtils.symbolList.push({
	id : "maths",
	range : "\\u1200-\\u1276",
	name : "Maths"
});
site.SymbolsUtils.symbolList.push({
	id : "numbers",
	range : "\\u1300-\\u1320",
	name : "Nombres"
});
site.SymbolsUtils.symbolList.push({
	id : "game",
	range : "\\u1600-\\u1625",
	name : "Jeux"
});
site.SymbolsUtils.symbolList.push({
	id : "crossandstars",
	range : "\\u1700-\\u172a",
	name : "Etoiles et Croix"
});
site.SymbolsUtils.symbolList.push({
	id : "zodiac",
	range : "\\u1900-\\u1922",
	name : "Zodiac"
});
site.SymbolsUtils.symbolList.push({
	id : "tatooLike",
	range : "\\u1b00-\\u1b0a",
	name : "Tatouages"
});
site.SymbolsUtils.symbolList.push({
	id : "medievalBeasts",
	range : "\\u0d00-\\u0d32",
	name : "Blasons"
});
site.SymbolsUtils.symbolList.push({
	id : "celtical",
	range : "\\u1a00-\\u1a0f",
	name : "Celtique"
});
site.SymbolsUtils.symbolList.push({
	id : "ornaments",
	range : "\\u1c00-\\u1c2e",
	name : "Ornements"
});
site.SymbolsUtils.SymbolsManager = function (a) {
	this.symbolList = a.symbolList || site.SymbolsUtils.symbolList;
	this.input = a.input;
	this.callback = a.callback || function (a) {};
	this.shown = !1;
	this.box = this.navBar = null;
	this.defaultList = "miscSymbols";
	this.listContainer = null;
	this.listPanels = {};
	this.listMenus = {};
	this.buildDOM(a)
};
site.SymbolsUtils.SymbolsManager.prototype.buildDOM = function (a) {
	this.listContainer = $("<div/>", {
			id : "symbol-list-display"
		});
	this.buildAllTabs();
	var b = this.buildCloseButton();
	this.box = $("<div/>", {
			id : "symbol-display",
			"data-container" : "body",
			css : {
				visibility : "hidden"
			}
		}).append($("<div/>", {
				"class" : "row"
			}).append(this.navBar, b), this.listContainer);
	a.container.append(this.box);
	a.trigger.click(this.instanciateToggle());
	this.offset = a.offset || {
		x : 100,
		y : -120
	}
};
site.SymbolsUtils.SymbolsManager.prototype.buildCloseButton = function () {
	var a = $("<button/>", {
			type : "button",
			"aria-hidden" : "true",
			text : "x",
			"class" : "close-symbols-trigger navbar-link"
		}),
	b = this;
	$(a).click(function () {
		b.close()
	});
	return a
};
site.SymbolsUtils.SymbolsManager.prototype.buildAllTabs = function () {
	this.navBar = $("<ul/>", {
			"class" : "col-md-11 nav nav-tabs"
		});
	for (var a = 0; a < this.symbolList.length; a++)
		this.buildTabMenu(this.symbolList[a]), this.buildTab(this.symbolList[a]);
	this.showTab(this.listMenus[this.defaultList])
};
site.SymbolsUtils.SymbolsManager.prototype.buildTabMenu = function (a) {
	var b = $("<li/>"),
	c = $("<a/>", {
			"data-symbolList" : a.id,
			title : gettext(a.name),
			href : "#",
			text : gettext(a.name),
			"data-toggle" : "tab",
			"class" : "symbol-list-trigger"
		});
	b.append(c);
	var d = this;
	c.click(function () {
		d.showTab($(this))
	});
	this.listMenus[a.id] = c;
	this.navBar.append(b)
};
site.SymbolsUtils.SymbolsManager.prototype.buildTab = function (a) {
	var b = this.extractSymbols(a);
	if ("" !== b) {
		for (var c = document.createElement("ul"), d = 0, e = null, f = null; d < b.length; d++) {
			var g = b[d],
			e = document.createElement("li");
			e.setAttribute("class", "symbol-button-trigger");
			f = document.createElement("div");
			f.innerHTML = g;
			f.setAttribute("title", g);
			var h = this;
			f.onclick = function () {
				var a = h.input,
				b = document.getElementById(a.attr("id")).selectionStart,
				c = a.val(),
				c = c.substring(0, b) + this.title + c.substring(b);
				a.val(c);
				a.change();
				a.focus();
				a[0].setSelectionRange(b + 1, b + 1);
				h.close();
				h.callback(c)
			};
			e.appendChild(f);
			c.appendChild(e)
		}
		this.listContainer.append(c);
		this.listPanels[a.id] = $(c)
	}
};
site.SymbolsUtils.SymbolsManager.prototype.extractSymbols = function (a) {
	a = a.range;
	var b = parseInt(a.slice(2, 6), 16);
	a = parseInt(a.slice(9, 14), 16);
	for (var c = ""; b <= a; b++)
		c += String.fromCharCode(b);
	return c
};
site.SymbolsUtils.SymbolsManager.prototype.close = function () {
	this.shown = !1;
	this.box.css("visibility", "hidden");
	this.input.removeClass("active")
};
site.SymbolsUtils.SymbolsManager.prototype.open = function (a) {
	this.shown = !0;
	this.box.offset(a).css("visibility", "visible");
	this.input.addClass("active")
};
site.SymbolsUtils.SymbolsManager.prototype.instanciateToggle = function () {
	var a = this;
	return function (b) {
		a.shown ? a.close() : a.open({
			left : b.pageX + a.offset.x,
			top : b.pageY + a.offset.y
		})
	}
};
site.SymbolsUtils.SymbolsManager.prototype.hideAllTabs = function () {
	$("#symbol-display li.active").removeClass("active");
	for (var a = Object.keys(this.listPanels), b = 0; b < a.length; b++)
		this.listPanels[a[b]].hide()
};
site.SymbolsUtils.SymbolsManager.prototype.showTab = function (a) {
	this.hideAllTabs();
	this.listPanels[a.attr("data-symbolList")].show();
	a.parent().addClass("active");
	return !1
};
site.SymbolsUtils.blackList = "?!%:;,.°\"' ";
site.SymbolsUtils.whiteList = "\\u0000-\\u0370";
site.SymbolsUtils.SymbolsFilter = function (a) {
	this.blackList = this.whiteList = null;
	this.buildRegExps(a.blacklist || site.SymbolsUtils.blackList, a.whitelist || site.SymbolsUtils.whiteList, a.symbolList || site.SymbolsUtils.symbolList);
	a.input.bind("input", this.instanciateInputFilter())
};
site.SymbolsUtils.SymbolsFilter.prototype.instanciateInputFilter = function () {
	var a = this;
	return function () {
		a.applyFilterToInput($(this))
	}
};
site.SymbolsUtils.SymbolsFilter.prototype.applyFilterToInput = function (a) {
	var b = a[0].selectionStart,
	c = a[0].selectionEnd,
	d = a.val().length;
	a.val(this.applyTextFilter(a.val()));
	var e = a.val().length,
	d = d - e;
	0 <= d && (b -= d, c -= d);
	a[0].setSelectionRange(b, c)
};
site.SymbolsUtils.SymbolsFilter.prototype.applyTextFilter = function (a) {
	return a.replace(this.whiteList, "").replace(this.blackList, "")
};
site.SymbolsUtils.SymbolsFilter.prototype.buildRegExps = function (a, b, c) {
	b = "[^" + b;
	for (var d = 0; d < c.length; d++)
		b += c[d].range;
	this.whiteList = RegExp(b + "]", "g");
	b = "[";
	for (c = 0; c < a.length; c++) {
		for (d = a.charCodeAt(c).toString(16).toUpperCase(); 4 > d.length; )
			d = "0" + d;
		b += "\\u" + d
	}
	b += "]";
	this.blackList = RegExp(b, "g")
};
site.EditorPannelManager = function (a) {
	this.shown = !1;
	this.ui = a.ui;
	this.callbacks = {};
	this.storeCallbacks(a.callbacks);
	this.ui.opener.click(this.instanciateOpen());
	this.ui.closer.click(this.instanciateClose())
};
site.EditorPannelManager.prototype.storeCallbacks = function (a) {
	var b = function () {},
	c = function () {};
	a && a.onOpen && (b = a.onOpen);
	a && a.onClose && (c = a.onClose);
	this.callbacks = {
		onOpen : b,
		onClose : c
	}
};
site.EditorPannelManager.prototype.close = function () {
	this.shown = !1;
	this.ui.container.fadeOut();
	this.callbacks.onClose()
};
site.EditorPannelManager.prototype.open = function () {
	this.shown = !0;
	this.ui.container.fadeIn();
	this.callbacks.onOpen()
};
site.EditorPannelManager.prototype.toggle = function () {
	this.shown ? this.close() : this.open();
	return !1
};
site.EditorPannelManager.prototype.instanciateOpen = function () {
	var a = this;
	return function () {
		a.open()
	}
};
site.EditorPannelManager.prototype.instanciateClose = function () {
	var a = this;
	return function () {
		a.close()
	}
};
site.EditorPannelManager.prototype.instanciateToggle = function () {
	var a = this;
	return function () {
		a.toggle()
	}
};
site.SVGUtils = {};
site.SVGUtils.SVGToCanvas = function (a, b) {
	var c = document.createElement("canvas"),
	d = c.getContext("2d");
	c.width = b.width;
	c.height = b.height;
	d.fillStyle = "#FFFFFF";
	d.fillRect(0, 0, b.width, b.height);
	canvg(c, a, {
		ignoreMouse : !0,
		ignoreAnimation : !0,
		ignoreClear : !0
	});
	return c
};
site.SVGUtils.getDimsFromSnapPaper = function (a) {
	return {
		width : $(a.node).width(),
		height : $(a.node).height()
	}
};
site.SVGUtils.setSnapViewBox = function (a, b) {
	var c = site.SVGUtils.getDimsFromSnapPaper(a);
	if (0 !== c.width && 0 !== c.height) {
		var d = {
			x : 0,
			y : 0,
			width : 0,
			height : 0
		},
		e = Math.max(b.width / c.width, b.height / c.height);
		d.width = c.width * e;
		d.height = c.height * e;
		c = -Math.abs(b.width - d.width) / 2;
		d.x = c;
		c = -Math.abs(b.height - d.height) / 2;
		d.y = c;
		a.attr({
			viewBox : d.x + " " + d.y + " " + d.width + " " + d.height
		});
		c = a.select("#viewBackground") || a.rect();
		c.attr({
			x : d.x,
			y : d.y,
			width : d.width,
			height : d.height,
			fill : "r(0.5,0.5,0.5)#b0b0b0-#6a6a6a",
			id : "viewBackground",
			zIndex : 1
		});
		e = a.select("#areaBackground") || a.rect();
		e.attr({
			x : 0,
			y : 0,
			width : b.width,
			height : b.height,
			fill : "#FFFFFF",
			id : "areaBackground",
			zIndex : 2
		});
		e.prependTo(a);
		c.prependTo(a);
		return d
	}
	console.warn("site.SVGUtils.setSnapViewBox - Can not set up a snap paper on startup")
};
site.SVGUtils.moveToBottom = function (a) {
	var b = a.parentNode.firstChild;
	"title" == b.tagName && (b = b.nextSibling);
	a.parentNode.insertBefore(a, b)
};
site.Draw2DUtils = {};
site.Draw2DUtils.isChannelColorBlack = function (a) {
	return 255 !== a
};
site.Draw2DUtils.isBlackPixel = function (a, b) {
	return site.Draw2DUtils.isChannelColorBlack(a[b]) && site.Draw2DUtils.isChannelColorBlack(a[b + 1]) && site.Draw2DUtils.isChannelColorBlack(a[b + 2])
};
site.Draw2DUtils.getNiceVerticalCrop = function (a) {
	var b = a.getImageData(0, 0, a.canvas.width, a.canvas.height),
	c = a.canvas.width,
	d = a.canvas.height,
	e = [0, b.height],
	f = Math.ceil(0.5 * a.canvas.width / 100);
	a = Math.ceil(0.5 * a.canvas.height / 100);
	for (var g = 0, h = !1; g < d && !h; g += a)
		for (var l = 0; l < c && !h; l += f) {
			var k = 4 * (g * c + l);
			site.Draw2DUtils.isBlackPixel(b.data, k) && (h = !0)
		}
	g -= 2 * a;
	for (h = !1; g < d && !h; g++)
		for (l = 0; l < c && !h; l++)
			k = 4 * (g * c + l), site.Draw2DUtils.isBlackPixel(b.data, k) && (h = !0);
	e[0] = g - 1;
	g = d - 1;
	for (h = !1; 0 <= g && !h; g -= a)
		for (l =
				0; l < c && !h; l += f)
			k = 4 * (g * c + l), site.Draw2DUtils.isBlackPixel(b.data, k) && (h = !0);
	g += 2 * a;
	for (h = !1; 0 <= g && !h; g--)
		for (l = 0; l < c && !h; l++)
			k = 4 * (g * c + l), site.Draw2DUtils.isBlackPixel(b.data, k) && (h = !0);
	e[1] = g + 1 - e[0];
	return e
};
site.Draw2DUtils.getNiceHorizontalCrop = function (a) {
	var b = a.getImageData(0, 0, a.canvas.width, a.canvas.height),
	c = a.canvas.width,
	d = a.canvas.height,
	e = [0, b.width],
	f = Math.ceil(0.5 * a.canvas.width / 100);
	a = Math.ceil(0.5 * a.canvas.height / 100);
	for (var g = 0, h = !1; g < c && !h; g += f)
		for (var l = 0; l < d && !h; l += a) {
			var k = 4 * (l * c + g);
			site.Draw2DUtils.isBlackPixel(b.data, k) && (h = !0)
		}
	g -= 2 * f;
	for (h = !1; g < c && !h; g++)
		for (l = 0; l < d && !h; l++)
			k = 4 * (l * c + g), site.Draw2DUtils.isBlackPixel(b.data, k) && (h = !0);
	e[0] = g - 1;
	g = c - 1;
	for (h = !1; 0 <= g && !h; g -= f)
		for (l =
				0; l < d && !h; l += a)
			k = 4 * (l * c + g), site.Draw2DUtils.isBlackPixel(b.data, k) && (h = !0);
	g += 2 * f;
	for (h = !1; 0 <= g && !h; g--)
		for (l = 0; l < d && !h; l++)
			k = 4 * (l * c + g), site.Draw2DUtils.isBlackPixel(b.data, k) && (h = !0);
	e[1] = g + 1 - e[0];
	return e
};
site.Draw2DUtils.getCropRect = function (a) {
	var b = {
		x : 0,
		y : 0,
		width : 0,
		height : 0
	};
	console.time("Horizontal Cropping");
	var c = site.Draw2DUtils.getNiceHorizontalCrop(a);
	console.timeEnd("Horizontal Cropping");
	b.x = c[0];
	b.width = c[1];
	console.log("cropRect.x: " + b.x + " and cropRect.width: " + b.width);
	console.time("Vertical Cropping");
	c = site.Draw2DUtils.getNiceVerticalCrop(a);
	console.timeEnd("Vertical Cropping");
	b.y = c[0];
	b.height = c[1];
	return b
};
site.Draw2DUtils.appendTestCanvas = function (a, b) {
	var c = document.createElement("canvas"),
	d = c.getContext("2d"),
	e = $(a);
	c.width = b.width;
	c.height = b.height;
	d.putImageData(b, 0, 0);
	c.style.position = "absolute";
	c.style.display = "block";
	c.style.visibility = "visible";
	c.style.zIndex = "55";
	e.append(c)
};
site.Draw2DUtils.getIndexAtPos = function (a, b, c) {
	return 4 * (b * c + a)
};
site.DisjointSet = function (a) {
	this.parent = [];
	this.parent.length = a;
	for (a = 0; a < this.parent.length; a++)
		this.parent[a] = a
};
site.DisjointSet.prototype.find = function (a) {
	return this.parent[a] === a ? a : this.find(this.parent[a])
};
site.DisjointSet.prototype.union = function (a, b) {
	var c = this.find(a),
	d = this.find(b);
	this.parent[c > d ? c : d] = c > d ? d : c
};
site.Draw2DUtils.labelConnectedComponent = function (a, b) {
	for (var c = a.getImageData(0, 0, a.canvas.width, a.canvas.height), d = a.canvas.width, e = a.canvas.height, f = [], g = -1, h = new site.DisjointSet(b), l = b - 1, k = 0; k < e; k++)
		for (var m = 0; m < d; m++) {
			var n = site.Draw2DUtils.getIndexAtPos(m, k, d);
			if (site.Draw2DUtils.isBlackPixel(c.data, n)) {
				var p = site.Draw2DUtils.getIndexAtPos(m, k - 1, d),
				q = site.Draw2DUtils.getIndexAtPos(m - 1, k, d),
				r = [];
				site.Draw2DUtils.isBlackPixel(c.data, p) && r.push(f[p / 4]);
				site.Draw2DUtils.isBlackPixel(c.data, q) &&
				r.push(f[q / 4]);
				0 !== r.length ? (r.sort(function (a, b) {
						return a - b
					}), f[n / 4] = r[0], 2 == r.length && h.union(r[0], r[1])) : (g++, f[n / 4] = g)
			} else
				f[n / 4] = l
		}
	c = {};
	for (k = 0; k < e; k++)
		for (m = 0; m < d; m++)
			g = k * d + m, f[g] !== l && (n = h.find(f[g]), f[g] = n, c[n] = void 0 !== c[n] ? c[n] + 1 : 1);
	return {
		labelledData : f,
		labelCounter : c,
		backgroundLabel : l
	}
};
site.Draw2DUtils.getLabelOfMainComponent = function (a) {
	for (var b = Object.keys(a), c = {
			counter : -999999,
			label : 999999
		}, d = 0; d < b.length; d++) {
		var e = {
			counter : a[b[d]],
			label : b[d]
		};
		e.counter > c.counter && (c = e)
	}
	return parseInt(c.label, 10)
};
site.Draw2DUtils.setPixelColor = function (a, b, c) {
	a[b] = c.r;
	a[b + 1] = c.g;
	a[b + 2] = c.b
};
site.Draw2DUtils.setPixelInArea = function (a, b, c, d) {
	for (var e = 0; e < b.length; e++)
		site.Draw2DUtils.setPixelColor(a, site.Draw2DUtils.getIndexAtPos(b[e].x, b[e].y, c), d)
};
site.Draw2DUtils.getDilationArea = function (a, b, c) {
	for (var d = [], e = -c; e < c + 1; e++)
		for (var f = -c; f < c + 1; f++)
			e * e + f * f < c * c && d.push({
				x : a + e,
				y : b + f
			});
	return d
};
site.Draw2DUtils.colorAndDilateComponents = function (a, b, c, d, e) {
	for (var f = a.getImageData(0, 0, a.canvas.width, a.canvas.height), g = a.canvas.width, h = a.canvas.height, l = {
			r : 0,
			g : 255,
			b : 0
		}, k = {
			r : 255,
			g : 0,
			b : 0
		}, m = 0, n; m < h; m++)
		for (var p = 0; p < g; p++)
			if (n = m * g + p, b[n] !== d) {
				n = b[n];
				var q = site.Draw2DUtils.getDilationArea(p, m, e);
				n === c ? site.Draw2DUtils.setPixelInArea(f.data, q, g, l) : site.Draw2DUtils.setPixelInArea(f.data, q, g, k)
			}
	a.fillStyle = "white";
	a.fillRect(0, 0, a.canvas.width, a.canvas.height);
	a.putImageData(f, 0, 0)
};
site.Draw2DUtils.colorConnectedComponent = function (a, b) {
	var c = site.Draw2DUtils.labelConnectedComponent(a, 99999),
	d = site.Draw2DUtils.getLabelOfMainComponent(c.labelCounter);
	site.Draw2DUtils.colorAndDilateComponents(a, c.labelledData, d, c.backgroundLabel, b);
	return 1 === Object.keys(c.labelCounter).length
};
site.Draw2DUtils.drawCircle = function (a, b, c) {
	a.beginPath();
	a.arc(b.cx, b.cy, b.radius, 0, 2 * Math.PI);
	a.fillStyle = "white";
	a.fill();
	a.lineWidth = 25;
	a.strokeStyle = c;
	a.stroke()
};
site.Draw2DUtils.drawLine = function (a, b, c, d, e, f) {
	a.beginPath();
	a.moveTo(b, c);
	a.lineTo(d, e);
	a.strokeStyle = f;
	a.lineWidth = 5;
	a.stroke()
};
site.Draw2DUtils.getCenterOfMass = function (a) {
	var b = a.getImageData(0, 0, a.canvas.width, a.canvas.height),
	c = a.canvas.width;
	a = a.canvas.height;
	for (var d = {
			x : null,
			y : null
		}, e = 0, f = 5; f < a - 5; f++)
		for (var g = 5; g < c - 5; g++) {
			var h = site.Draw2DUtils.getIndexAtPos(g, f, c);
			site.Draw2DUtils.isBlackPixel(b.data, h) && (null === d.x ? (d.x = g, d.y = f, e = 1) : (d.x += g, d.y += f, e++))
		}
	d.x /= e;
	d.y /= e;
	return d
};
site.Draw2DUtils.drawGravityLine = function (a, b) {
	var c = site.Draw2DUtils.getCenterOfMass(a);
	site.Draw2DUtils.drawCircle(a, b, "red");
	site.Draw2DUtils.drawLine(a, b.cx, b.cy, c.x, c.y, "red")
};
site.JweelSVGEditAnchorManager = function (a) {
	this.defaultParams = {
		className : "jweelSVGEditorAnchors",
		classNameVertical : "jweelSVGEditorVerticalAnchors",
		fill : "#FFFFFF",
		stroke : "#000000",
		diameter : {
			value : 20,
			min : 20,
			max : 100,
			step : 10
		},
		rLength : {
			value : 15,
			min : 15,
			max : 35,
			step : 5
		}
	};
	this.thickness = 3;
	this.diameterSelectRange = this.thicknessSelectRange = null;
	this.ui = a;
	this.buildAnchorUI();
	this.verticalManager = null
};
site.JweelSVGEditAnchorManager.prototype.buildAnchorUI = function () {
	var a = this,
	b = this.defaultParams.rLength;
	this.thicknessSelectRange = new site.SelectRange(this.ui.thicknessSelect, {
			disabled : !1,
			min : b.min / 10,
			max : b.max / 10,
			step : b.step / 10,
			value : b.value / 10,
			postOptionText : gettext("mm"),
			preOptionText : gettext("Epaisseur:"),
			change : function (b, d) {
				a.setAnchorAttr(10 * d.value, "rLength")
			}
		});
	b = this.defaultParams.diameter;
	this.diameterSelectRange = new site.SelectRange(this.ui.diameterSelect, {
			disabled : !1,
			min : b.min / 100,
			max : b.max / 100,
			step : b.step / 100,
			value : b.value / 100,
			postOptionText : gettext("cm"),
			preOptionText : gettext("Diamètre:"),
			change : function (b, d) {
				a.setAnchorAttr(100 * d.value, "diameter")
			}
		});
	new site.JweelToggleButton({
		trigger : $("#jweelAnchorSwitcher"),
		callback : function () {
			a.switchVerticalAnchor()
		}
	})
};
site.JweelSVGEditAnchorManager.prototype.setThickness = function (a) {
	this.thickness !== a && (this.thickness = a, console.error("Changing editor thickness is bad: Anchors are now wrong."))
};
site.JweelSVGEditAnchorManager.prototype.getThickness = function () {
	return this.thickness
};
site.JweelSVGEditAnchorManager.prototype.getDefaultParams = function () {
	return this.defaultParams
};
site.JweelSVGEditAnchorManager.prototype.realWorldToAnchorParams = function (a) {
	return {
		strokeW : a.rLength - 2 * this.thickness,
		rad : (a.diameter + a.rLength) / 2
	}
};
site.JweelSVGEditAnchorManager.prototype.anchorParamstoRealWorld = function (a) {
	var b = a.strokeW + 2 * this.thickness;
	return {
		rLength : b,
		diameter : 2 * a.rad - b
	}
};
site.JweelSVGEditAnchorManager.prototype.updateAnchorInfoVisu = function (a) {
	var b = null,
	b = this.isVerticalAnchor(a) ? this.extractRectAnchorParams(a) : this.extractAnchorParams(a, "r");
	a = this.anchorParamstoRealWorld(b);
	b = this.thicknessSelectRange.getNear(a.rLength / 10);
	this.thicknessSelectRange.select.val(b.toString());
	this.thicknessSelectRange.select.selectpicker("render");
	b = this.diameterSelectRange.getNear(a.diameter / 100);
	this.diameterSelectRange.select.val(b.toString());
	this.diameterSelectRange.select.selectpicker("render")
};
site.JweelSVGEditAnchorManager.prototype.fixAnchor = function (a) {
	svgedit.recalculate.recalculateDimensions(a);
	this.isVerticalAnchor(a) ? this.fixRectangleAnchor(a) : this.fixEllipseAnchor(a);
	(a = svgCanvas.selectorManager.requestSelector(a)) && a.resize()
};
site.JweelSVGEditAnchorManager.prototype.fixRectangleAnchor = function (a) {
	var b = this.clampRectAnchorParams(a);
	this.setRectAnchorParams(a, b);
	a = svgCanvas.getSelectedElems()[0];
	this.isVerticalAnchor(a) && svgCanvas.setRotationAngle(0, !0)
};
site.JweelSVGEditAnchorManager.prototype.fixEllipseAnchor = function (a) {
	var b = this.getClampedStrokeW(a),
	c = this.getClampedRad(a, "rx"),
	d = this.getClampedRad(a, "ry");
	this.anchorIsCircle(c, d) && (c = d = Math.min(c, d));
	$(a).attr("stroke-width", b + "px");
	$(a).attr("rx", c);
	$(a).attr("ry", d)
};
site.JweelSVGEditAnchorManager.prototype.anchorIsCircle = function (a, b) {
	return 0.1 > Math.abs(1 - a / b)
};
site.JweelSVGEditAnchorManager.prototype.extractAnchorParams = function (a, b) {
	var c = parseFloat($(a).attr("stroke-width")),
	d = 0,
	d = "rx" === b ? parseFloat($(a).attr("rx")) : "ry" === b ? parseFloat($(a).attr("ry")) : Math.min(parseFloat($(a).attr("rx")), parseFloat($(a).attr("ry")));
	return {
		strokeW : c,
		rad : d
	}
};
site.JweelSVGEditAnchorManager.prototype.setAnchorParams = function (a, b) {
	$(a).attr("stroke-width", b.strokeW + "px");
	var c = $(a).attr("rx"),
	d = $(a).attr("ry");
	this.anchorIsCircle(c, d) ? ($(a).attr("rx", b.rad), $(a).attr("ry", b.rad)) : c < d ? $(a).attr("rx", b.rad) : $(a).attr("ry", b.rad)
};
site.JweelSVGEditAnchorManager.prototype.extractRectAnchorParams = function (a) {
	var b = parseFloat($(a).attr("width"));
	a = (parseFloat($(a).attr("height")) - b) / 2;
	return {
		strokeW : b,
		rad : a
	}
};
site.JweelSVGEditAnchorManager.prototype.globalExtractAnchorParams = function (a) {
	if (this.isVerticalAnchor(a)) {
		var b = this.extractRectAnchorParams(a);
		b.cx = parseFloat($(a).attr("x")) + parseFloat($(a).attr("width")) / 2;
		b.cy = parseFloat($(a).attr("y")) + parseFloat($(a).attr("height")) / 2
	} else
		b = this.extractAnchorParams(a, "r"), b.cx = parseFloat($(a).attr("cx")), b.cy = parseFloat($(a).attr("cy"));
	return b
};
site.JweelSVGEditAnchorManager.prototype.setRectAnchorParams = function (a, b) {
	$(a).attr("width", b.strokeW);
	$(a).attr("height", 2 * b.rad + b.strokeW)
};
site.JweelSVGEditAnchorManager.prototype.switchVerticalAnchor = function () {
	var a = svgCanvas.getSelectedElems()[0];
	this.isValidJweelAnchor(a) && (this.isVerticalAnchor(a) ? this.switchToEllipseAnchor(a) : this.switchToRectAnchor(a))
};
site.JweelSVGEditAnchorManager.prototype.switchToEllipseAnchor = function (a) {
	var b = this.extractRectAnchorParams(a),
	c = parseFloat($(a).attr("x")) + parseFloat($(a).attr("width")) / 2;
	a = parseFloat($(a).attr("y")) + parseFloat($(a).attr("height")) / 2;
	svgCanvas.deleteSelectedElements();
	b = svgCanvas.addSvgElementFromJson({
			element : "ellipse",
			attr : {
				cx : c,
				cy : a,
				rx : b.rad,
				ry : b.rad,
				"stroke-width" : b.strokeW + "px",
				id : svgCanvas.getNextId(),
				fill : this.defaultParams.fill,
				stroke : this.defaultParams.stroke,
				"class" : this.defaultParams.className
			}
		});
	svgCanvas.addToSelection([b], !0)
};
site.JweelSVGEditAnchorManager.prototype.switchToRectAnchor = function (a) {
	var b = this.extractAnchorParams(a, "r"),
	c = parseFloat($(a).attr("cx"));
	a = parseFloat($(a).attr("cy"));
	svgCanvas.deleteSelectedElements();
	b = svgCanvas.addSvgElementFromJson({
			element : "rect",
			attr : {
				x : c - b.strokeW / 2,
				y : a - b.rad,
				width : b.strokeW,
				height : 2 * b.rad + b.strokeW,
				fill : "black",
				"class" : this.defaultParams.className + " " + this.defaultParams.classNameVertical
			}
		});
	svgCanvas.addToSelection([b], !0)
};
site.JweelSVGEditAnchorManager.prototype.setAnchorAttr = function (a, b) {
	if ("diameter" !== b && "rLength" !== b)
		console.error("jweel anchor extension - setAnchorAttr: can't process attr " + b);
	else {
		var c = svgCanvas.getSelectedElems()[0];
		this.isVerticalAnchor(c) ? this.setRectAnchorAttr(c, a, b) : this.setEllipseAnchorAttr(c, a, b);
		this.fixAnchor(c);
		svgCanvas.call("changed", c)
	}
};
site.JweelSVGEditAnchorManager.prototype.setRectAnchorAttr = function (a, b, c) {
	var d = this.extractRectAnchorParams(a),
	d = this.anchorParamstoRealWorld(d);
	d[c] = b;
	d[c] = this.clampAnchorAttr(d[c], c);
	d = this.realWorldToAnchorParams(d);
	this.setRectAnchorParams(a, d)
};
site.JweelSVGEditAnchorManager.prototype.setEllipseAnchorAttr = function (a, b, c) {
	var d = this.extractAnchorParams(a, "r"),
	d = this.anchorParamstoRealWorld(d);
	d[c] = b;
	d[c] = this.clampAnchorAttr(d[c], c);
	d = this.realWorldToAnchorParams(d);
	this.setAnchorParams(a, d)
};
site.JweelSVGEditAnchorManager.prototype.clampAnchorAttr = function (a, b) {
	var c = this.defaultParams[b];
	return Math.min(Math.max(c.min, a), c.max)
};
site.JweelSVGEditAnchorManager.prototype.getClampedRad = function (a, b) {
	var c = this.extractAnchorParams(a, b),
	c = this.anchorParamstoRealWorld(c);
	c.diameter = this.clampAnchorAttr(c.diameter, "diameter");
	c = this.realWorldToAnchorParams(c);
	return c.rad
};
site.JweelSVGEditAnchorManager.prototype.getClampedStrokeW = function (a) {
	a = this.extractAnchorParams(a, "r");
	a = this.anchorParamstoRealWorld(a);
	a.rLength = this.clampAnchorAttr(a.rLength, "rLength");
	a = this.realWorldToAnchorParams(a);
	return a.strokeW
};
site.JweelSVGEditAnchorManager.prototype.clampRectAnchorParams = function (a) {
	a = this.extractRectAnchorParams(a);
	a = this.anchorParamstoRealWorld(a);
	a.diameter = this.clampAnchorAttr(a.diameter, "diameter");
	a.rLength = this.clampAnchorAttr(a.rLength, "rLength");
	return a = this.realWorldToAnchorParams(a)
};
site.JweelSVGEditAnchorManager.prototype.hasClass = function (a, b) {
	var c = $(a).attr("class");
	if (c)
		for (var c = c.split(/\s+/), d = 0; d < c.length; d++)
			if (c[d] === b)
				return !0;
	return !1
};
site.JweelSVGEditAnchorManager.prototype.isVerticalAnchor = function (a) {
	return a && this.hasClass(a, this.defaultParams.classNameVertical)
};
site.JweelSVGEditAnchorManager.prototype.isValidJweelAnchor = function (a) {
	return a && this.hasClass(a, this.defaultParams.className)
};
site.JweelSVGEditAnchorManager.prototype.sendAnchorsToFront = function () {
	for (var a = svgCanvas.getVisibleElements(), b = 0; b < a.length; b++) {
		var c = a[b];
		this.isValidJweelAnchor(c) || site.SVGUtils.moveToBottom(c)
	}
};
site.JweelSVGEditWrapper = function (a) {
	site.JweelEditor.call(this, a);
	this.canvasHeight = this.canvasWidth = 600;
	this.fontSelect = this.symbolsManager = null;
	this.anchorManager = new site.JweelSVGEditAnchorManager(a.ui.menu.anchor);
	this.initSVGEditor();
	this.buildMenu()
};
site.JweelSVGEditWrapper.prototype = Object.create(site.JweelEditor.prototype);
site.JweelSVGEditWrapper.prototype.constructor = site.JweelSVGEditWrapper;
site.JweelSVGEditWrapper.prototype.initSVGEditor = function () {
	this.params.ui.pannel.container.css("visibility", "visible");
	$("input").bind("keydown", function (a) {
		a.stopPropagation()
	})
};
site.JweelSVGEditWrapper.prototype.correctContextMenu = function (a, b) {
	var c = {
		x : a,
		y : b
	};
	if (0 < $("#svg-edit").length) {
		var d = $("#svg-edit").offset();
		c.x -= d.left;
		c.y -= d.top
	}
	return c
};
site.JweelSVGEditWrapper.prototype.buildMenu = function () {
	var a = this.params.ui.menu.text,
	b = this;
	this.symbolsManager = new site.SymbolsUtils.SymbolsManager({
			container : a.symbol.container,
			input : a.input,
			trigger : a.symbol.trigger,
			offset : {
				x : -25,
				y : 40
			},
			callback : function (a) {
				svgCanvas.setTextContent(a)
			}
		});
	new site.SymbolsUtils.SymbolsFilter({
		input : a.input
	});
	this.fontSelect = new site.TextMenu.FontSelect({
			input : a.input,
			keyEventContainer : a.font.keyEventContainer,
			select : a.font.select,
			clickContainer : a.font.clickContainer,
			callback : function (a) {
				svgCanvas.setFontFamily(a + ", Symbols")
			}
		});
	var c = function () {
		b.pannelManager.close();
		b.params.callbacks.loadObject()
	};
	this.params.ui.menu.buttons.generate3D.click(function () {
		b.testConnectedComponents(c)
	});
	new site.JweelToggleButton({
		trigger : $("#jweel_tool_select"),
		callback : function () {
			svgCanvas.setMode("select");
			$("#styleoverrides").text("#svgcanvas svg *{cursor:move;pointer-events:all}, #svgcanvas svg{cursor:default}")
		}
	});
	new site.JweelToggleButton({
		trigger : $("#jweel_tool_text"),
		callback : function () {
			svgCanvas.setMode("text")
		}
	});
	new site.JweelToggleButton({
		trigger : $("#jweel_tool_anchor"),
		callback : function () {
			svgCanvas.setMode("anchors")
		}
	});
	new site.JweelToggleButton({
		trigger : $("#jweel_tool_undo"),
		callback : function () {
			0 < svgCanvas.undoMgr.getUndoStackSize() && svgCanvas.undoMgr.undo()
		}
	});
	new site.JweelToggleButton({
		trigger : $("#jweel_tool_redo"),
		callback : function () {
			0 < svgCanvas.undoMgr.getRedoStackSize() && svgCanvas.undoMgr.redo()
		}
	})
};
site.JweelSVGEditWrapper.prototype.updateTextFontSelect = function (a) {
	this.selectionIsText() && (this.fontSelect.fontSelect.val(a.split(",")[0]), this.fontSelect.applyFont())
};
site.JweelSVGEditWrapper.prototype.setToolInfo = function (a) {
	this.toolInfo = $.extend({}, a);
	this.setSVG(this.toolInfo.svg)
};
site.JweelSVGEditWrapper.prototype.getToolInfo = function () {
	svgCanvas.setBackground("#FFF");
	this.setContentToFit();
	this.anchorManager.sendAnchorsToFront();
	svgEditor.updateCanvas();
	this.toolInfo.svg = svgCanvas.svgCanvasToString();
	var a = svgCanvas.getResolution();
	this.toolInfo.width = a.w;
	this.toolInfo.height = a.h;
	return this.toolInfo
};
site.JweelSVGEditWrapper.prototype.setThickness = function (a) {
	this.anchorManager.setThickness(a)
};
site.JweelSVGEditWrapper.prototype.setContentToFit = function () {
	var a = this.convertSVGToCanvas(),
	a = site.Draw2DUtils.getCropRect(a);
	a.x -= 5;
	a.y -= 5;
	a.width += 10;
	a.height += 10;
	this.fitInRect(a)
};
site.JweelSVGEditWrapper.prototype.convertSVGToCanvas = function () {
	var a = svgCanvas.getResolution(),
	b = svgCanvas.addSvgElementFromJson({
			element : "rect",
			attr : {
				fill : "white",
				x : 0,
				y : 0,
				width : a.w,
				height : a.h
			}
		});
	site.SVGUtils.moveToBottom(b);
	a = site.SVGUtils.SVGToCanvas(svgCanvas.svgCanvasToString(), {
			width : a.w,
			height : a.h
		}).getContext("2d");
	b.parentNode.removeChild(b);
	return a
};
site.JweelSVGEditWrapper.prototype.testConnectedComponents = function (a) {
	var b = this.convertSVGToCanvas(),
	c = site.Draw2DUtils.colorConnectedComponent(b, this.anchorManager.getThickness());
	svgCanvas.setBackground("#FFF", b.canvas.toDataURL());
	c ? a() : this.launchConnectedComponentsAlert(a)
};
site.JweelSVGEditWrapper.prototype.testGravityLine = function () {
	var a = this.convertSVGToCanvas(),
	b = this.extractMainAnchorParams();
	b && b.isUnique && (site.Draw2DUtils.drawGravityLine(a, b), svgCanvas.setBackground("#FFF", a.canvas.toDataURL()))
};
site.JweelSVGEditWrapper.prototype.getFirstAnchor = function () {
	for (var a = svgCanvas.getVisibleElements(), b = 0; b < a.length; b++) {
		var c = a[b];
		if (this.anchorManager.isValidJweelAnchor(c))
			return c
	}
	return null
};
site.JweelSVGEditWrapper.prototype.extractMainAnchorParams = function () {
	var a = this.getFirstAnchor();
	return a ? (a = this.anchorManager.globalExtractAnchorParams(a), {
		cx : a.cx,
		cy : a.cy,
		radius : a.rad,
		isUnique : !0
	}) : null
};
site.JweelSVGEditWrapper.prototype.launchConnectedComponentsAlert = function (a) {
	bootbox.dialog({
		message : gettext("Votre dessin présente des parties qui ne sont pas inter-connectées. Celà risque de créer un objet non valide pour l'impression 3D, car composé de deux ou plusieurs parties.</br> </br> Nous vous conseillons de déplacer vos éléments de façon à ce qu'ils forment une pièce unique."),
		title : gettext("Votre objet n'est pas d'une seule pièce "),
		buttons : {
			createAnyway : {
				label : gettext("Créer l'objet non-valide"),
				className : "btn btn-invertdark",
				callback : function () {
					a()
				}
			},
			returnToDrawing : {
				label : gettext("Revenir à la zone de dessin"),
				className : "btn btn-blue",
				callback : function () {}

			}
		}
	})
};
site.JweelSVGEditWrapper.prototype.setScaleOnElem = function (a, b) {
	var c = svgroot.createSVGTransform();
	c.setScale(b, b);
	a.transform.baseVal.initialize(c)
};
site.JweelSVGEditWrapper.prototype.fitInRect = function (a) {
	var b = svgCanvas.getVisibleElements();
	svgCanvas.addToSelection(b);
	var c = [],
	d = [];
	$.each(b, function (b, e) {
		c.push(-1 * a.x);
		d.push(-1 * a.y)
	});
	svgCanvas.moveSelectedElements(c, d, !0);
	svgCanvas.clearSelection();
	var b = Math.round(a.width),
	e = Math.round(a.height);
	svgCanvas.setResolution(b, e)
};
site.JweelSVGEditWrapper.prototype.setSVG = function (a) {
	this.toolInfo.svg = a;
	svgEditor.loadFromString(a);
	svgCanvas.setResolution(this.canvasWidth, this.canvasHeight);
	this.centerSVGContent();
	svgEditor.updateCanvas(!0);
	svgCanvas.zoomChanged(window, "canvas");
	svgCanvas.undoMgr.resetUndoStack()
};
site.JweelSVGEditWrapper.prototype.centerSVGContent = function () {
	var a = this.toolInfo.width / 2,
	b = this.toolInfo.height / 2,
	c = svgCanvas.getVisibleElements();
	svgCanvas.addToSelection(c);
	var d = [],
	e = [];
	svgCanvas.getResolution();
	var f = this;
	$.each(c, function (c, h) {
		d.push(-a + f.canvasWidth / 2);
		e.push(-b + f.canvasHeight / 2)
	});
	svgCanvas.moveSelectedElements(d, e, !0);
	svgCanvas.clearSelection()
};
site.JweelSVGEditWrapper.prototype.hasSelection = function () {
	return svgCanvas.getSelectedElems()[0]
};
site.JweelSVGEditWrapper.prototype.selectionIsText = function () {
	return this.hasSelection() && "text" === svgCanvas.getSelectedElems()[0].tagName
};
site.JweelSVGEditWrapper.prototype.getTextDir = function (a) {
	return {
		x : 1,
		y : 0
	}
};
site.JweelSVGEditWrapper.prototype.getLetterPositions = function (a) {
	var b = this.getTextDir(a);
	a = a.textContent;
	for (var c = [], d = 0, e = 0; e < a.length; e++) {
		var f = {
			x : b.x * d,
			y : b.y * d
		},
		d = 50 * (e + 1);
		c.push(f)
	}
	return c
};
site.JweelSVGEditWrapper.prototype.dissociateSelectedText = function () {
	if (this.selectionIsText()) {
		var a = svgCanvas.getSelectedElems()[0],
		b = a.textContent;
		if (1 < b.length) {
			var c = new svgedit.history.BatchCommand("Dissociate"),
			d = this.getLetterPositions(a),
			e = svgCanvas.getPrivateMethods().copyElem;
			svgCanvas.clearSelection();
			for (var f = 0; f < b.length; f++) {
				var g = b[f],
				h = e(a);
				h.textContent = g;
				svgCanvas.getCurrentDrawing().getCurrentLayer().appendChild(h);
				c.addSubCommand(new svgedit.history.InsertElementCommand(h));
				svgCanvas.addToSelection([h]);
				svgCanvas.moveSelectedElements(d[f].x, d[f].y, !1);
				svgCanvas.selectorManager.requestSelector(h).resize();
				svgCanvas.removeFromSelection([h]);
				svgCanvas.recalculateDimensions(h)
			}
			a = this.svgCanvasDeleteElem(a);
			c.addSubCommand(a);
			c.isEmpty() || svgCanvas.getPrivateMethods().addCommandToHistory(c)
		}
	}
};
site.JweelSVGEditWrapper.prototype.svgCanvasDeleteElem = function (a) {
	if (null !== a) {
		var b = a.parentNode,
		c = a;
		svgCanvas.selectorManager.releaseSelector(c);
		svgedit.path.removePath_(c.id);
		"a" === b.tagName && 1 === b.childNodes.length && (c = b, b = b.parentNode);
		a = c.nextSibling;
		c = b.removeChild(c);
		return new svgedit.history.RemoveElementCommand(c, a, b)
	}
};
var ImageGreyLevelMapper = function () {
	this.img_data = this.img = null;
	this.map = [];
	this.mapper = new Int32Array(256);
	this.clearAllMapping()
};
ImageGreyLevelMapper.prototype.getMap = function () {
	this.sortMap();
	return this.map
};
ImageGreyLevelMapper.prototype.setImgFromDataURL = function (a) {
	var b = this,
	c = new Image;
	c.src = a;
	c.onload = function () {
		b.setImg(c)
	}
};
ImageGreyLevelMapper.prototype.setImg = function (a) {
	this.img = a;
	this.canvas = document.createElement("canvas");
	this.canvas.width = this.img.width;
	this.canvas.height = this.img.height;
	a = this.canvas.getContext("2d");
	a.drawImage(this.img, 0, 0, this.canvas.width, this.canvas.height);
	this.img_data = a.getImageData(0, 0, this.canvas.width, this.canvas.height)
};
ImageGreyLevelMapper.prototype.autoMappingFromImg = function () {
	for (var a = 255, b = 0, c = this.img_data.data, d = 0; d < c.length; d += 4)
		this.assert(c[d] === c[d + 1] && c[d] === c[d + 2], "Error : the image is not greyscaled"), 255 === c[d + 3] && (a > c[d] && (a = c[d]), b < c[d] && (b = c[d]));
	this.clearAllMapping();
	this.setLevelMapping(a, a);
	this.setLevelMapping(b, b)
};
ImageGreyLevelMapper.prototype.getLevels = function (a, b) {
	for (var c = 0, d = this.img_data.data, e = 0; e < d.length; e += 4)
		this.assert(d[e] === d[e + 1] && d[e] === d[e + 2], "Error : the image is not greyscaled"), d[e + 2] >= a && d[e + 2] <= b && (c += d[e + 2] * (d[e + 3] / 255));
	return 4 * c / d.length
};
ImageGreyLevelMapper.prototype.setLevelMapping = function (a, b) {
	for (var c = -1, d = 0; d < this.map.length; ++d)
		if (this.map[d].from === a) {
			c = d;
			break
		}
	-1 === c ? this.map.push({
		from : a,
		to : b
	}) : this.map[c].to = b;
	this.mapper_updated = !1
};
ImageGreyLevelMapper.prototype.clearLevelMapping = function (a) {
	for (var b = 0; b < this.map.length; ++b)
		if (this.map[b].from === a) {
			this.map[b] = this.map[this.map.length - 1];
			this.map.length -= 1;
			break
		}
	this.mapper_updated = !1
};
ImageGreyLevelMapper.prototype.clearAllMapping = function () {
	this.map = [];
	for (var a = 0; 255 >= a; ++a)
		this.mapper[a] = a;
	this.mapper_updated = !0
};
ImageGreyLevelMapper.prototype.updateMapper = function () {
	this.sortMap();
	if (1 > this.map.length)
		this.clearAllMapping();
	else {
		for (var a = 0; a <= this.map[0].from; ++a)
			this.mapper[a] = this.map[0].to;
		for (a = this.map[this.map.length - 1].from; 255 >= a; ++a)
			this.mapper[a] = this.map[this.map.length - 1].to;
		for (var b = 0; b < this.map.length - 1; ++b)
			for (a = this.map[b].from; a < this.map[b + 1].from; ++a)
				this.mapper[a] = this.map[b].to + (a - this.map[b].from) * (this.map[b + 1].to - this.map[b].to) / (this.map[b + 1].from - this.map[b].from)
	}
	this.mapper_updated =
		!0
};
ImageGreyLevelMapper.prototype.sortMap = function () {
	var a = function (a, c) {
		return a.from < c.from ? -1 : a.from > c.from ? 1 : 0
	};
	return function () {
		this.map.sort(a)
	}
}
();
ImageGreyLevelMapper.prototype.getProcessedDataURL = function () {
	this.mapper_updated || this.updateMapper();
	for (var a = this.canvas.getContext("2d"), b = a.getImageData(0, 0, this.canvas.width, this.canvas.height), c = b.data, d = 0; d < c.length; d += 4)
		c[d] = this.mapper[this.img_data.data[d]], c[d + 1] = this.mapper[this.img_data.data[d + 1]], c[d + 2] = this.mapper[this.img_data.data[d + 2]];
	a.putImageData(b, 0, 0);
	return this.canvas.toDataURL()
};
ImageGreyLevelMapper.prototype.getMapAsString = function () {
	for (var a = "", b = 0; b < this.map.length; ++b)
		a += "(" + this.map[b].from + "," + this.map[b].to + ")";
	return a
};
ImageGreyLevelMapper.prototype.loadMapFromString = function (a) {
	var b,
	c,
	d;
	for (d = 0; d < a.length; ) {
		b = a;
		this.assert("(" === b[d], "Parsing error, should be a (");
		c = 0;
		var e = d + 1;
		"," === b[d + 2] ? (c = parseInt(b[d + 1], 10), e = d + 2) : "," === b[d + 3] ? (c = parseInt(b[d + 1] + b[d + 2], 10), e = d + 3) : (this.assert("," === b[d + 4], "Parsing Error : should be a ,"), c = parseInt(b[d + 1] + b[d + 2] + b[d + 3], 10), e = d + 4);
		var f = 0;
		d = e;
		")" === b[e + 2] ? (f = parseInt(b[e + 1], 10), d = e + 3) : ")" === b[e + 3] ? (f = parseInt(b[e + 1] + b[e + 2], 10), d = e + 4) : (this.assert(")" === b[e + 4], "Parsing Error : should be a )"),
			f = parseInt(b[e + 1] + b[e + 2] + b[e + 3], 10), d = e + 5);
		b = c;
		c = f;
		this.setLevelMapping(b, c)
	}
};
ImageGreyLevelMapper.prototype.assert = function (a, b) {
	a || console.err("ImageGreyLevelMapper : " + b)
};
var ImageTransparencyManager = function (a) {
	this.assert(void 0 !== a, "Error : img can be null, but not undefined");
	this.img = null;
	null !== a && this.setImg(a);
	this.tolerance = 50;
	this.feather = 10
};
ImageTransparencyManager.prototype.setTolerance = function (a) {
	this.tolerance = a
};
ImageTransparencyManager.prototype.setFeather = function (a) {
	this.feather = a
};
ImageTransparencyManager.prototype.setImg = function (a) {
	this.img = a;
	this.canvas = document.createElement("canvas");
	this.canvas.width = this.img.width;
	this.canvas.height = this.img.height;
	a = this.canvas.getContext("2d");
	a.drawImage(this.img, 0, 0, this.canvas.width, this.canvas.height);
	this.img_data = a.getImageData(0, 0, this.canvas.width, this.canvas.height)
};
ImageTransparencyManager.prototype.clearColor = function (a, b, c) {
	c = this.img_data.data;
	for (var d = 0; d < c.length; d += 4)
		if (0 !== c[d + 3]) {
			var e = (Math.abs(a - c[d]) + Math.abs(b - c[d + 1]) + Math.abs(b - c[d + 2])) / (3 * (this.tolerance + this.feather)),
			e = 1 <= e ? 1 : e <= this.tolerance / (this.tolerance + this.feather) ? 0 : 4 * (e - this.tolerance / (this.tolerance + this.feather));
			c[d + 3] *= e
		}
	this.canvas.getContext("2d").putImageData(this.img_data, 0, 0)
};
ImageTransparencyManager.prototype.getImgAsDataURL = function () {
	return this.canvas.toDataURL()
};
ImageTransparencyManager.prototype.assert = function (a, b) {
	a || console.err("ImageTransparencyManager : " + b)
};
var GreyLevelsWidget = function (a) {
	this.paper = Snap(a.svg_tag);
	this.cvs_w = $(a.svg_tag).width();
	this.cvs_h = $(a.svg_tag).height();
	this.cvs_ratio = this.cvs_h / this.cvs_w;
	a = this.paper.gradient("l(0, 0, 1, 0)#000-#fff");
	this.slide_p = {
		m_x : 5,
		m_y : 5,
		w : this.cvs_w - 10,
		h : 10,
		r : 3
	};
	this.slidebar = this.paper.rect(this.slide_p.m_x, this.slide_p.m_y, this.slide_p.w, this.slide_p.h, this.slide_p.r, this.slide_p.r);
	this.slidebar.attr({
		stroke : "#999999",
		strokeWidth : "1px",
		fill : a
	});
	var b = this;
	this.slidebar.mousedown(function (a, d, e) {
		a =
			Math.round(255 * (a.offsetX - b.slide_p.m_x) / b.slide_p.w);
		d = Object.keys(b.pointers);
		e = null;
		for (var f = 256, g = 0; g < d.length; ++g) {
			var h = Math.abs(b.pointers[d[g]].to - a);
			h < f && (f = h, e = b.pointers[d[g]])
		}
		null !== e && (b.setPointer(e.from, a), b.slide(e), b.change(e))
	});
	this.pointers = {};
	this.paper.mousedown(function () {
		b.mousedown()
	})
};
GreyLevelsWidget.prototype.setPointer = function (a, b) {
	var c = null;
	void 0 === this.pointers[a] ? (c = {
			from : a,
			to : b,
			snap_el : this.paper.rect(0, 0, 1, 1, 1, 1)
		}, this.pointers[a] = c) : this.pointers[a].to = b;
	this.pointers[a].snap_el.attr({
		x : this.slide_p.m_x + b / 255 * this.slide_p.w - this.slide_p.r,
		y : this.slide_p.m_y - this.slide_p.r,
		width : 2 * this.slide_p.r,
		height : this.slide_p.h + 2 * this.slide_p.r,
		rx : this.slide_p.r,
		ry : this.slide_p.r,
		stroke : "#999999",
		strokeWidth : "1px",
		fill : this.paper.gradient("l(0, 0, 0, 1)" + this.convertNumberToColor(Math.min(a +
					4, 255)) + "-" + this.convertNumberToColor(a))
	});
	var d = 0,
	e = this,
	f = this.pointers[a];
	f.snap_el.drag(function (a, b, c, k, m) {
		a = {
			x : Math.max(Math.min(Math.round(d + a), e.slide_p.m_x + e.slide_p.w - e.slide_p.r), e.slide_p.m_x - e.slide_p.r)
		};
		f.snap_el.attr(a);
		f.to = Math.round(255 * (a.x + e.slide_p.r - e.slide_p.m_x) / e.slide_p.w);
		e.slide(f)
	}, function (a, b, c) {
		d = parseFloat(f.snap_el.attr("x"));
		parseFloat(f.snap_el.attr("y"))
	}, function () {
		e.change(f)
	})
};
GreyLevelsWidget.prototype.clearPointers = function () {
	for (var a = Object.keys(this.pointers), b = 0; b < a.length; ++b)
		this.pointers[a[b]].snap_el.remove(), delete this.pointers[a[b]]
};
GreyLevelsWidget.prototype.slide = function (a) {};
GreyLevelsWidget.prototype.change = function (a) {};
GreyLevelsWidget.prototype.mousedown = function () {};
GreyLevelsWidget.prototype.convertNumberToColor = function (a) {
	a = a.toString(16);
	1 === a.length && (a = "0" + a);
	return "#" + a + a + a
};
site.RingTool = function (a, b, c) {
	site.LoaderNode.call(this, a, b, c)
};
site.RingTool.prototype = Object.create(site.LoaderNode.prototype);
site.RingTool.prototype.constructor = site.RingTool;
site.RingTool.prototype.getSize = function () {
	return this.toolInfo.size
};
site.RingTool.prototype.setSize = function (a) {
	this.toolInfo.size = a
};
site.RingTool.prototype.loadHandMesh = function () {
	(new skim.utils.OBJMTLLoader).load(window.media + "/static/meshes/WomanHand_Obj/WomanHand_HD.obj", window.media + "/static/meshes/WomanHand_Obj/WomanHand_HD.mtl", function (a) {
		a.traverse(function (a) {
			a.visible = !1
		});
		a.scale.set(122, 122, 122);
		a.position.set(177, -232, 590);
		a.rotation.x = 0.33;
		a.rotation.y = 1.44;
		a.rotation.z = 0;
		var b = new THREE.Object3D;
		b.add(a);
		skim.instances.modeler.sceneManager.addNeutralObject("handHD", b)
	})
};
site.RingTool.prototype.utilsInit = function () {
	site.LoaderNode.prototype.utilsInit.call(this);
	this.loadHandMesh()
};
site.RingTool.prototype.prepToolForSave = function (a) {
	if (Transformer.jweel.isHandShown) {
		skim.instances.modeler.sceneManager.getNeutralObject("handHD").traverse(function (a) {
			a.visible = !1
		});
		skim.instances.modeler.sceneManager.neutralObjectUpdated("handHD");
		var b = skim.instances.modeler.cameraMan.getDistToTarget(),
		c = skim.instances.modeler.cameraMan.rotNode.rotation.clone();
		skim.instances.modeler.cameraMan.setDistToTarget(window.jweelTool.defaultParams.init.initCamPos.distToTarget);
		a(function () {
			skim.instances.modeler.sceneManager.getNeutralObject("handHD").traverse(function (a) {
				a.visible =
					!0
			});
			skim.instances.modeler.sceneManager.neutralObjectUpdated("handHD");
			skim.instances.modeler.cameraMan.rotNode.rotation.set(c.x, c.y, c.z);
			skim.instances.modeler.cameraMan.setDistToTarget(b)
		})
	} else
		a(function () {})
};
site.RingTool.prototype.specializeTransformer = function () {
	site.LoaderNode.prototype.specializeTransformer.call(this);
	Transformer.jweel = {
		cam_orig_dist : 0,
		cam_final_dist : 2E3,
		isHandShown : !1,
		move_interval : null,
		counter : 0,
		hand_orig_z : 3500,
		hand_euler : new THREE.Euler(-1.5691948051141857, -0.5264986926534203, -2.043890988569277),
		last_call : -1,
		t : 0,
		anim_duration : 1700,
		setHandAnimInterp : function (a) {
			skim.instances.modeler.cameraMan.rotNode.rotation.set(Transformer.jweel.cam_orig_rot.x * (1 - a) + a * Transformer.jweel.hand_euler.x,
				Transformer.jweel.cam_orig_rot.y * (1 - a) + a * Transformer.jweel.hand_euler.y, Transformer.jweel.cam_orig_rot.z * (1 - a) + a * Transformer.jweel.hand_euler.z);
			skim.instances.modeler.cameraMan.setDistToTarget(Transformer.jweel.cam_orig_dist + a * (1900 - Transformer.jweel.cam_orig_dist));
			skim.instances.modeler.sceneManager.getNeutralObject("handHD").position.z = Transformer.jweel.hand_orig_z * (1 - a);
			skim.instances.modeler.sceneManager.neutralObjectUpdated("handHD")
		},
		showHand : function () {
			skim.instances.modeler.sceneManager.getNeutralObject("handHD").traverse(function (a) {
				a.visible =
					!0
			});
			skim.instances.modeler.sceneManager.neutralObjectUpdated("handHD");
			null !== Transformer.jweel.move_interval && clearInterval(Transformer.jweel.move_interval);
			0 == Transformer.jweel.t && (Transformer.jweel.cam_orig_dist = skim.instances.modeler.cameraMan.getDistToTarget(), Transformer.jweel.cam_orig_rot = skim.instances.modeler.cameraMan.rotNode.rotation.clone(), skim.instances.modeler.sceneManager.getNeutralObject("handHD").position.z = Transformer.jweel.hand_orig_z, skim.instances.modeler.sceneManager.neutralObjectUpdated("handHD"),
				Transformer.jweel.hand_euler.set(-1.5691948051141857, -0.5264986926534203, -2.043890988569277), Transformer.jweel.last_call = (new Date).getTime());
			Transformer.jweel.move_interval = setInterval(function () {
					Transformer.jweel.t += (new Date).getTime() - Transformer.jweel.last_call;
					Transformer.jweel.last_call = (new Date).getTime();
					Transformer.jweel.t <= Transformer.jweel.anim_duration ? (Transformer.jweel.setHandAnimInterp(Transformer.jweel.t / Transformer.jweel.anim_duration), Transformer.jweel.isHandShown = !0) : (Transformer.jweel.setHandAnimInterp(1),
						clearInterval(Transformer.jweel.move_interval), Transformer.jweel.move_interval = null, Transformer.jweel.t = Transformer.jweel.anim_duration)
				}, 1 / 60)
		},
		hideHand : function (a, b) {
			null !== Transformer.jweel.move_interval && clearInterval(Transformer.jweel.move_interval);
			Transformer.jweel.t === Transformer.jweel.anim_duration && (Transformer.jweel.hand_euler.copy(skim.instances.modeler.cameraMan.rotNode.rotation), Transformer.jweel.last_call = (new Date).getTime());
			Transformer.jweel.move_interval = setInterval(function () {
					Transformer.jweel.t -=
					(new Date).getTime() - Transformer.jweel.last_call;
					Transformer.jweel.last_call = (new Date).getTime();
					0 <= Transformer.jweel.t ? Transformer.jweel.setHandAnimInterp(Transformer.jweel.t / Transformer.jweel.anim_duration) : (Transformer.jweel.setHandAnimInterp(0), skim.instances.modeler.sceneManager.getNeutralObject("handHD").traverse(function (a) {
							a.visible = !1
						}), skim.instances.modeler.sceneManager.neutralObjectUpdated("handHD"), clearInterval(Transformer.jweel.move_interval), Transformer.jweel.move_interval = null, Transformer.jweel.isHandShown =
							!1, b && b(), Transformer.jweel.t = 0)
				}, 1 / 60)
		},
		flipHandSide : function () {
			0 < skim.instances.modeler.sceneManager.getNeutralObject("handHD").scale.z ? Transformer.jweel.setHandSide("right") : Transformer.jweel.setHandSide("left")
		},
		setHandSide : function (a) {
			var b = skim.instances.modeler.sceneManager.getNeutralObject("handHD");
			switch (a) {
			case "right":
				b.scale.z = -Math.abs(b.scale.z);
				b.traverse(function (a) {
					a instanceof THREE.Mesh && a.material.setValues({
						side : THREE.BackSide
					})
				});
				Transformer.jweel.hand_orig_z = -Math.abs(Transformer.jweel.hand_orig_z);
				break;
			case "left":
				b.scale.z = Math.abs(b.scale.z);
				b.traverse(function (a) {
					a instanceof THREE.Mesh && a.material.setValues({
						side : THREE.FrontSide
					})
				});
				Transformer.jweel.hand_orig_z = Math.abs(Transformer.jweel.hand_orig_z);
				break;
			default:
				skim.utils.assert(!1, "Error, hand size unknown")
			}
		}
	}
};
site.StyleringTool = function (a, b, c) {
	site.RingTool.call(this, a, b, c);
	this.toolType = toolNames.stylering;
	this.defaultParams.jsonInfo = JSON.parse('{"primitives": {"rings": [{"v": [0, 1, 2, 3, 4, 5, 6, 7], "vt": 0}], "segments": [], "triangles": []}, "relations": {"p": {"spsa": []}, "r": {"rpsa": []}, "v": {"vpsa": [{"a": "x", "v0": 0, "v1": 4}, {"a": "x", "v0": 1, "v1": 5}, {"a": "x", "v0": 2, "v1": 6}, {"a": "x", "v0": 3, "v1": 7}, {"a": "z", "v0": 4, "v1": 7}, {"a": "z", "v0": 5, "v1": 6}, {"a": "z", "v0": 0, "v1": 3}, {"a": "z", "v0": 1, "v1": 2}]}}, "version": "1", "vertices": [{"n": "v0", "t": 5.0, "vt": 0, "x": -25.32103, "y": 91.93206, "z": 9.04216}, {"n": "v1", "t": 5.0, "vt": 0, "x": -24.14952, "y": 87.67869, "z": 9.04216}, {"n": "v2", "t": 5.0, "vt": 0, "x": -24.14952, "y": 87.67869, "z": -9.04216}, {"n": "v3", "t": 5.0, "vt": 0, "x": -25.32103, "y": 91.93206, "z": -9.04216}, {"n": "v4", "t": 5.0, "vt": 0, "x": 25.32103, "y": 91.93206, "z": 9.04216}, {"n": "v5", "t": 5.0, "vt": 0, "x": 24.14952, "y": 87.67869, "z": 9.04216}, {"n": "v6", "t": 5.0, "vt": 0, "x": 24.14952, "y": 87.67869, "z": -9.04216}, {"n": "v7", "t": 5.0, "vt": 0, "x": 25.32103, "y": 91.93206, "z": -9.04216}]}');
	this.defaultParams.toolInfo = {
		size : 54,
		symX : !0,
		symY : !1,
		symZ : !0
	};
	this.defaultParams.init.initCamPos = {
		rotNode : {
			px : 0,
			py : 0,
			pz : 0,
			rx : -0.8,
			ry : -0.7,
			rz : -0.5
		},
		distToTarget : 550
	};
	this.setDefaultParams();
	this.minRingVThick = 5;
	this.innerRadius = 90;
	this.minThickVRingFunctor = this.radialfixTanFunctorInt = null;
	this.styleRingDef = [];
	this.cylinderVisu = this.cylinderShowTimer = null;
	this.storageKey = "skimlab-code#styleringtool"
};
site.StyleringTool.prototype = Object.create(site.RingTool.prototype);
site.StyleringTool.prototype.constructor = site.StyleringTool;
site.StyleringTool.prototype.loadFiles = function () {
	this.mode === site.toolModes.edit && this.filesToLoad.push("/static/js/site/tools/ring/stylering/SMDef.js");
	site.RingTool.prototype.loadFiles.call(this)
};
site.StyleringTool.prototype.loadObject = function () {
	if (this.jsonInfo) {
		skim.engine.loadJSON(this.jsonInfo)
	}
	this.initFromObject(this.getSize());
	skim.engine.setSymmetries({
		x : this.toolInfo.symX,
		y : this.toolInfo.symY,
		z : this.toolInfo.symZ,
		rad : !1
	});
	a = this.cloneToolInfo();
	this.addPrimInfo(a);
	this.pageInterface.updateToolMenu(a);
	skim.instances.modeler.setAccuracyLevel(3)
};
site.StyleringTool.prototype.utilsInit = function () {
	site.RingTool.prototype.utilsInit.call(this);
	var a = {
		innerRadius : 540 / (2 * Math.PI),
		yCenterPos : 0,
		XPlane : !1,
		zLimit : 120
	};
	this.mode === site.toolModes.edit ? (this.progress = new site.JweelProgress3D({
				rotation : new THREE.Euler(-Math.PI / 2, 0, 0),
				position : new THREE.Vector3(0, -110, 0),
				scale : new THREE.Vector3(130, 130, 1)
			}), this.cylinderVisu = new site.ForbiddenCylinder(a), this.cylinderVisu.setSystemAllows(!0)) : (this.progress = new site.JweelProgress2D(this.canvas), this.cylinderVisu =
			new site.ForbiddenCylinder(a), this.cylinderVisu.setSystemAllows(!1));
	this.cylinderVisu.hide();
	this.computeWarning = new site.JweelComputationWarning(this)
};
site.StyleringTool.prototype.buildInitParams = function () {
	site.RingTool.prototype.buildInitParams.call(this);
	this.mode === site.toolModes.edit && (this.initParams.statemachine = StyleSM);
	this.initParams.pageInterface.rsqFunctorWorked = this.getRsqFunctorWorked();
	this.initParams.engine = {
		adjust_functors : {
			ringRadialLimit : new skim.engine.adjustAttrFunctors.RsqLimit,
			print_min_thick : new skim.engine.adjustAttrFunctors.VLimitMin(3),
			vert_max_thick : new skim.engine.adjustAttrFunctors.VLimitMax(150),
			sphere_pos_limit : new skim.engine.adjustAttrFunctors.SpherePosLimit(500)
		}
	}
};
site.StyleringTool.prototype.getRsqFunctorWorked = function () {
	var a = this;
	return function () {
		a.cylinderShowTimer && clearTimeout(a.cylinderShowTimer);
		a.cylinderVisu.show();
		a.cylinderShowTimer = setTimeout(function () {
				a.cylinderVisu.hide()
			}, 3E3)
	}
};
site.StyleringTool.prototype.computeCircumference = function () {
	for (var a = Object.keys(skim.engine.vars.primitives), b = {}, c = function (a) {
		var b = a.getPos();
		a = a.getThickness();
		return 2 * (Math.sqrt(b.x * b.x + b.y * b.y) - a) * Math.PI
	}, d = 0; d < a.length; d++) {
		var e = skim.engine.vars.primitives[a[d]];
		if (e instanceof skim.engine.RingDef)
			for (var f = 0; f < e.v.length; f += 4)
				b[e.v[f + 1].id] = c(e.v[f + 1]), b[e.v[f + 2].id] = c(e.v[f + 2])
	}
	a = Object.keys(b);
	for (c = d = 0; d < a.length; d++)
		c += b[a[d]];
	return {
		avgCirc : c / a.length,
		innerCircs : b
	}
};
site.StyleringTool.prototype.repairInnerCircum = function (a, b) {
	skim.engine.reset();
	skim.engine.loadJSON(b);
	for (var c = this.computeCircumference(), d = Object.keys(c.innerCircs), e = 0, f = 9999999; e < d.length; e++)
		var g = c.innerCircs[d[e]], f = g < f ? g : f;
	c = f / (2 * Math.PI);
	d = Object.keys(skim.engine.vars.primitives);
	for (e = 0; e < d.length; e++)
		if (f = skim.engine.vars.primitives[d[e]], f instanceof skim.engine.RingDef)
			for (g = 0; g < f.v.length; g += 4) {
				var h = f.v[g + 1].getPos();
				f.v[g + 1].setThickness(Math.max(this.minRingVThick, f.v[g + 1].getThickness()));
				var l = f.v[g + 1].getThickness(),
				h = skim.geometry.GetXAngleFromPoint(h);
				f.v[g + 1].setPos((c + l) * Math.cos(h), (c + l) * Math.sin(h), f.v[g + 1].getPos().z);
				f.v[g + 2].setThickness(Math.max(this.minRingVThick, f.v[g + 2].getThickness()));
				h = f.v[g + 2].getPos();
				l = f.v[g + 2].getThickness();
				h = skim.geometry.GetXAngleFromPoint(h);
				f.v[g + 2].setPos((c + l) * Math.cos(h), (c + l) * Math.sin(h), f.v[g + 2].getPos().z)
			}
	this.initFromObject(a)
};
site.StyleringTool.prototype.initFromObject = function (a) {
	a = a || 54;
	this.innerRadius = 1E6;
	for (var b = Object.keys(skim.engine.vars.vertices), c = 0; c < b.length; c++) {
		var d = skim.engine.vars.vertices[b[c]],
		d = Math.sqrt(d.getPos().x * d.getPos().x + d.getPos().y * d.getPos().y) - d.getThickness();
		this.innerRadius = Math.min(this.innerRadius, d)
	}
	1E6 == this.innerRadius && (this.innerRadius = 10 * a / (2 * Math.PI));
	this.radialfixTanFunctorInt = new skim.engine.adjustAttrFunctors.VFixedTanRadial(this.innerRadius, !0);
	this.minThickVRingFunctor =
		new skim.engine.adjustAttrFunctors.VLimitMin(this.minRingVThick);
	this.updateStyleRingDef();
	this.radialfixTanFunctorInt.setRadial(this.innerRadius);
	for (b = 0; b < this.styleRingDef.length; ++b)
		for (c = 0; c < this.styleRingDef[b].v.length; c += 4)
			d = this.styleRingDef[b].v.slice(c, c + 4), this.setFunctorsOnControlSet(d);
	skim.engine.adjust_functors.ringRadialLimit.setLimit(this.innerRadius);
	this.setRingParameters(a)
};
site.StyleringTool.prototype.setRingParameters = function (a) {
	a = 10 * a / (2 * Math.PI);
	var b = a / this.innerRadius;
	this.radialfixTanFunctorInt.setActive(!1);
	skim.engine.adjust_functors.ringRadialLimit.setActive(!1);
	skim.engine.processVertices(function (a) {
		a.setPos(b * a.getPos().x, b * a.getPos().y, b * a.getPos().z);
		a.setThickness(b * a.getThickness())
	});
	this.innerRadius = a;
	this.radialfixTanFunctorInt.setRadial(this.innerRadius);
	this.radialfixTanFunctorInt.setActive(!0);
	skim.engine.adjust_functors.ringRadialLimit.setLimit(this.innerRadius);
	skim.engine.adjust_functors.ringRadialLimit.setActive(!0);
	skim.engine.processVertices(function (a) {
		for (var b = 1E-4, e = a.getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.VLimitMin), f = 0; f < e.length; ++f)
			b = Math.max(e[f].limit, b);
		for (var g = 1E7, e = a.getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.VLimitMax), f = 0; f < e.length; ++f)
			g = Math.min(e[f].limit, g);
		a.setVertexAndPropagate(a.getPos().x, a.getPos().y, a.getPos().z, Math.min(g, Math.max(b, a.getThickness())), a.getMaterial(), a.getVolType())
	});
	skim.engine.update_skeleton();
	skim.engine.update_parametrics();
	skim.engine.update_blobtree()
};
site.StyleringTool.prototype.updateStyleRingDef = function () {
	this.styleRingDef = [];
	for (var a = Object.keys(skim.engine.vars.primitives), b = 0; b < a.length; b++) {
		var c = skim.engine.vars.primitives[a[b]];
		c instanceof skim.engine.RingDef && this.styleRingDef.push(c)
	}
};
site.StyleringTool.prototype.testSinusoidalRings = function () {
	this.addOneSinuRing(0);
	this.addOneSinuRing(1);
	this.addOneSinuRing(2);
	this.addOneSinuRing(3);
	this.addOneSinuRing(4);
	this.addOneSinuRing(5)
};
site.StyleringTool.prototype.addOneSinuRing = function (a) {
	a = 2 * (a || 0) * Math.PI / 18;
	for (var b = 0, c = []; 18 > b; b += 3) {
		for (var d = 0, e = 10, d = 540 / (2 * Math.PI) + 5 + e / 2, f = -20, d = skim.ringUtils.createVertControlSet(a + 2 * b * Math.PI / 18, d, e, 10, f, 5), c = c.concat(d.vert), e = 0; 4 > e; e++)
			d.vert[e].commit();
		e = 5;
		d = 540 / (2 * Math.PI) + 5 + e / 2;
		f = 0;
		d = skim.ringUtils.createVertControlSet(a + 2 * (b + 1) * Math.PI / 18, d, e, 10, f, 5);
		c = c.concat(d.vert);
		for (e = 0; 4 > e; e++)
			d.vert[e].commit();
		e = 10;
		d = 540 / (2 * Math.PI) + 5 + e / 2;
		f = 20;
		d = skim.ringUtils.createVertControlSet(a +
				2 * (b + 2) * Math.PI / 18, d, e, 10, f, 5);
		c = c.concat(d.vert);
		for (e = 0; 4 > e; e++)
			d.vert[e].commit()
	}
	(new skim.engine.RingDef(c, Transformer.creation.getModeVolType())).commit();
	skim.engine.update_skeleton();
	skim.engine.update_parametrics();
	skim.engine.update_blobtree()
};
site.StyleringTool.prototype.setFunctorsOnControlSet = function (a) {
	for (var b = 0; 4 > b; ++b)
		a[b].removeAdjustAttrFunctor(a[b].getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.RsqLimit)[0]), a[b].insertAdjustAttrFunctor(this.minThickVRingFunctor, -1);
	a[1].insertAdjustAttrFunctor(this.radialfixTanFunctorInt, -1);
	a[2].insertAdjustAttrFunctor(this.radialfixTanFunctorInt, -1)
};
site.StyleringTool.prototype.splitStyleRingDef = function (a, b) {
	for (var c = skim.engine.splitRingDef(a, b), d = 0; d < c.length; ++d)
		for (var e = Object.keys(c[d]), f = 0; f < e.length; f++)
			this.setFunctorsOnControlSet(c[d][e[f]].vdef);
	return c
};
site.StyleringTool.prototype.computeZOffset = function (a, b) {
	var c = 0;
	if (0 !== this.styleRingDef.length) {
		for (var c = new skim.geometry.AABBox(null, null, null, null, null, null), d = 0; d < this.styleRingDef.length; d++)
			void 0 !== skim.engine.vars.primitives[this.styleRingDef[d].id] && c.union(this.styleRingDef[d].getReactor().getAABB());
		b ? c = Math.max(c.max.z, Math.abs(c.min.z)) + 15 + a / 2 : (d = c.getCenter().z, c = c.size().z, c = d + (0 <= d ? -1 : 1) * ((c + a) / 2 + 15))
	} else
		b && (c = 15 + a / 2);
	return c
};
site.StyleringTool.prototype.specializeTransformer = function () {
	site.RingTool.prototype.specializeTransformer.call(this);
	var a = this;
	Transformer.ring.addRing = function (b) {
		var c = null,
		d = 2 * a.minRingVThick + 6,
		e = a.minRingVThick;
		a.updateStyleRingDef();
		b = a.computeZOffset(25, b || !1);
		d = skim.ringUtils.createVertControlSet(0, a.innerRadius + 0.5 * d, d - 2 * e, 25, b, e);
		for (e = 0; e < d.vert.length; e++)
			d.vert[e].commit();
		e = 0;
		for (b = !0; e < d.vert.length; e++) {
			var f = new THREE.Vector3(d.vert[e].pos.x, d.vert[e].pos.y, d.vert[e].pos.z),
			g = {
				t : d.vert[e].thickness
			};
			b = b && d.vert[e].checkFunctorList(f, g)
		}
		b ? (a.styleRingDef.push(new skim.engine.RingDef(d.vert, Transformer.creation.getModeVolType())), a.styleRingDef[a.styleRingDef.length - 1].commit(), c = a.styleRingDef[a.styleRingDef.length - 1], e = skim.engine.symmetry.z, skim.engine.symmetry.z = !1, a.splitStyleRingDef(a.styleRingDef[a.styleRingDef.length - 1], Math.PI / 2), skim.engine.symmetry.z = e) : console.warn("StyleRingTool - Trying to commit a ring in a non valid position.");
		for (e = 0; e < d.vert.length; e++)
			d.vert[e].destroy();
		return c
	};
	Transformer.ring.add = function () {
		skim.instances.modeler.sceneManager.setShowSurface(!1);
		Transformer.ring.addRing(!1);
		skim.file.saveState();
		skim.engine.update_skeleton();
		skim.engine.update_parametrics();
		skim.engine.update_blobtree()
	};
	Transformer.ring.addTwo = function () {
		skim.instances.modeler.sceneManager.setShowSurface(!1);
		var a = Transformer.ring.addRing(!0);
		null !== a && new skim.engine.linkFunctors.RingPlaneSymmetryAxis(a, null, "z");
		skim.file.saveState();
		skim.engine.update_skeleton();
		skim.engine.update_parametrics();
		skim.engine.update_blobtree()
	};
	Transformer.ring.splitRing = function (b, c) {
		var d = skim.engine.getPrimitiveById(b.id);
		skim.utils.assert(d instanceof skim.engine.RingDef, "Error : splitRing can only operate on a ring...");
		a.splitStyleRingDef(d, c)
	};
	Transformer.prim.translate.adjustPrimTranslation = function (a, c) {
		if ("ring" === a.p.type)
			if (c.x = 0, c.y = 0, 8 < Math.abs(c.z)) {
				var d = new THREE.Vector3(0, 0, a.hitZ);
				d.x = 2 * (a.canvasX / skim.instances.modeler.canvas.width) - 1;
				d.y = 2 *  - (a.canvasY / skim.instances.modeler.canvas.height) +
					1;
				d.unproject(skim.instances.modeler.cameraMan.camera);
				var d = d.clone(),
				e = skim.instances.modeler.cameraMan.getCameraWorldPosition(),
				f = (new THREE.Vector3).subVectors(d, e),
				d = {
					v : new THREE.Vector3(0, 0, 0),
					axis : new THREE.Vector3(0, 0, 1),
					r : Math.sqrt(a.prev_hit.x * a.prev_hit.x + a.prev_hit.y * a.prev_hit.y),
					inf : -1E7,
					sup : 1E7
				},
				g = {};
				switch (skim.geometry.RayCylinderIntersect(d, e, f, g)) {
				case 0:
					var g = f.dot(f),
					h = f.dot(d.axis),
					f = f.dot(e),
					e = d.axis.dot(e),
					l = g - h * h,
					k = 0;
					0 !== l && (k = d.axis.z * (g * e - h * f) / l);
					c.z = k - a.prev_hit.z;
					break;
				case 1:
					0 < g.inter_t[0] && (c.z = g.inter_p[0].z - a.prev_hit.z);
					break;
				case 2:
					0 > g.inter_t[0] ? 0 < g.inter_t[1] && (c.z = g.inter_p[1].z - a.prev_hit.z) : 0 > g.inter_t[1] ? c.z = g.inter_p[0].z - a.prev_hit.z : (d = (new THREE.Vector3).subVectors(g.inter_p[0], a.prev_hit).lengthSq(), h = (new THREE.Vector3).subVectors(g.inter_p[1], a.prev_hit).lengthSq(), c.z = d < h ? g.inter_p[0].z - a.prev_hit.z : g.inter_p[1].z - a.prev_hit.z);
					break;
				default:
					skim.utils.assert(!1, "Should never happen")
				}
			} else
				c.z = 0
	};
	Transformer.vertex.thick.vertexThickIncreaseAdjustThickness =
	function (b, c, d, e) {
		var f = skim.instances.skel.vertices[c.id],
		g = f.getOwners(skim.skel.tokenVRings);
		if (void 0 !== g) {
			var h = Object.keys(g);
			skim.utils.assert(1 >= h.length, "Error : this adjustment function utils.StyleRingTool.prototype.vertexTranslateRunAdjustPos has been designed for only 1 ring for a given vertex");
			for (var l = 0; l < h.length; ++l) {
				var k = g[h[l]],
				m = skim.ringUtils.getSetIdxFromId(k, f.id);
				skim.utils.assert(-1 != m, "Error : non coherent code, this idx should be present in the ring");
				var k = [k.v[m], k.v[m +
						1], k.v[m + 2], k.v[m + 3]],
				m = f === k[1] || f === k[2],
				n = (new THREE.Vector2(d.x, d.y)).length(),
				p = a.innerRadius + (m ? e.t : f === k[0] ? Math.max(e.t, Math.max(k[1].getThickness(), k[0].getThickness())) + 3 : Math.max(e.t, Math.max(k[2].getThickness(), k[3].getThickness())) + 3);
				n < p && d.set(p * d.x / n, p * d.y / n, d.z);
				m = m ? f === k[1] ? k[2].getPos().z : k[1].getPos().z : f === k[0] ? k[3].getPos().z : k[0].getPos().z;
				k = Math.max(Math.max(k[0].getThickness(), k[1].getThickness()), Math.max(k[2].getThickness(), k[3].getThickness()));
				Math.max(e.t, k);
				f.getPos().z >
				m ? d.z = Math.max(m + 3, d.z) : d.z = Math.min(m - 3, d.z)
			}
		}
		Transformer.prim.translate.magnetOnAxis(b, c, d, e)
	};
	Transformer.vertex.translate.vertexTranslateRunAdjustPos = function (b, c, d, e) {
		var f = b.v,
		g = b.v_origin,
		h = f.getOwners(skim.skel.tokenVRings);
		if (void 0 !== h) {
			var l = Object.keys(h);
			skim.utils.assert(1 >= l.length, "Error : this adjustment function utils.StyleRingTool.prototype.vertexTranslateRunAdjustPos has been designed for only 1 ring for a given vertex");
			for (var k = 0; k < l.length; ++k) {
				var m = h[l[k]],
				n = skim.ringUtils.getSetIdxFromId(m,
						f.id);
				skim.utils.assert(-1 != n, "Error : non coherent code, this idx should be present in the ring");
				var m = [m.v[n], m.v[n + 1], m.v[n + 2], m.v[n + 3]],
				n = f === m[1] || f === m[2],
				p = (new THREE.Vector2(d.x, d.y)).length(),
				q = a.innerRadius + (n ? f.getThickness() : f === m[0] ? Math.max(m[1].getThickness(), m[0].getThickness()) + 3 : Math.max(m[2].getThickness(), m[3].getThickness()) + 3);
				if (p < q) {
					skim.instances.modeler.cameraMan.getCameraWorldPosition();
					var p = skim.instances.modeler.cameraMan.getCameraWorldPosition(),
					r = (new THREE.Vector3).subVectors(d,
						skim.instances.modeler.cameraMan.getCameraWorldPosition()),
					s = {
						v : new THREE.Vector3(0, 0, 0),
						axis : new THREE.Vector3(0, 0, 1),
						r : q,
						inf : -1E7,
						sup : 1E7
					},
					q = {};
					switch (skim.geometry.RayCylinderIntersect(s, p, r, q)) {
					case 0:
						skim.utils.assert(!1, "Error: the cylinder should be hit at least once");
						break;
					case 1:
						0 < q.inter_t[0] && d.copy(q.inter_p[0]);
						break;
					case 2:
						0 > q.inter_t[0] ? 0 < q.inter_t[1] && d.copy(q.inter_p[1]) : 0 > q.inter_t[1] ? d.copy(q.inter_p[0]) : (p = (new THREE.Vector3).subVectors(q.inter_p[0], g).lengthSq(), r = (new THREE.Vector3).subVectors(q.inter_p[1],
								g).lengthSq(), p < r ? d.copy(q.inter_p[0]) : d.copy(q.inter_p[1]));
						break;
					default:
						skim.utils.assert(!1, "Should never happen")
					}
				}
				n = n ? f === m[1] ? m[2].getPos().z : m[1].getPos().z : f === m[0] ? m[3].getPos().z : m[0].getPos().z;
				Math.max(Math.max(m[0].getThickness(), m[1].getThickness()), Math.max(m[2].getThickness(), m[3].getThickness()));
				f.getPos().z > n ? d.z = Math.max(n + 3, d.z) : d.z = Math.min(n - 3, d.z)
			}
		}
		Transformer.prim.translate.magnetOnAxis(b, c, d, e)
	};
	Transformer.step = {
		prev : function () {
			skim.file.restoreLastState();
			a.initFromObject(a.getSize())
		},
		next : function () {
			skim.file.restoreNextState();
			a.initFromObject(a.getSize())
		}
	};
	Transformer.translate.finalize = function () {
		a.cylinderVisu.hide()
	};
	Transformer.creation.x_symmetry_activate_toggle = function () {
		a.toolInfo.symX = !skim.engine.symmetry.x;
		skim.engine.setSymmetries({
			x : !skim.engine.symmetry.x
		})
	};
	Transformer.creation.y_symmetry_activate_toggle = function () {
		a.toolInfo.symY = !skim.engine.symmetry.y;
		skim.engine.setSymmetries({
			y : !skim.engine.symmetry.y
		})
	};
	Transformer.creation.z_symmetry_activate_toggle = function () {
		a.toolInfo.symZ =
			!skim.engine.symmetry.z;
		skim.engine.setSymmetries({
			z : !skim.engine.symmetry.z
		})
	};
	void 0 === Transformer.vertex.infos && (Transformer.vertex.infos = {});
	Transformer.vertex.infos.displayInfos = function () {
		document.getElementById("infos-line").style.display = "block"
	};
	Transformer.vertex.infos.updateInfos = function () {
		document.getElementById("infos-line").innerHTML = "ø " + (Math.round(20 * this.hit.getThickness()) / 100).toString() + " mm"
	};
	Transformer.vertex.infos.removeInfos = function () {
		document.getElementById("infos-line").style.display =
			"none"
	};
	Transformer.vertex.styleWrap = {};
	Transformer.vertex.styleWrap.thickIncrease = function () {
		Transformer.vertex.thick.increase.call(this);
		Transformer.vertex.infos.updateInfos.call(this)
	};
	Transformer.vertex.styleWrap.thickDecrease = function () {
		Transformer.vertex.thick.decrease.call(this);
		Transformer.vertex.infos.updateInfos.call(this)
	};
	Transformer.vertex.styleWrap.highlight = function () {
		Transformer.vertex.highlight.call(this);
		Transformer.vertex.infos.updateInfos.call(this)
	}
};
site.TextringTool = function (a, b, c) {
	site.RingTool.call(this, a, b, c);
	this.toolType = toolNames.textring;
	this.defaultParams.toolInfo = {
		text : gettext("---Jweel---"),
		fontFamily : "Norican",
		fontWeight : 400,
		fontStyle : "",
		size : 54
	};
	this.toolInfo = this.defaultParams.toolInfo;
	this.genMethod = "LQ";
	this.defaultParams.init.initCamPos = {
		rotNode : {
			px : 0,
			py : 0,
			pz : 0,
			rx : -1.5,
			ry : 0.5,
			rz : 3
		},
		distToTarget : 700
	};
	this.initParams.trackballHelper = !1;
	this.canvasTextTool = null
};
site.TextringTool.prototype = Object.create(site.RingTool.prototype);
site.TextringTool.prototype.constructor = site.TextringTool;
site.TextringTool.prototype.loadFiles = function () {
	this.filesToLoad.push("/static/js/fontdetect/fontdetect.2.2.min.js");
	site.RingTool.prototype.loadFiles.call(this)
};
site.TextringTool.prototype.loadObject = function () {
	0 !== this.jsonInfo.length && skim.engine.loadJSON(this.jsonInfo);
	skim.instances.modeler.sceneManager.showWidgets(!1);
	for (var a = Object.keys(skim.engine.vars.vertices), b = 0; b < a.length; ++b)
		void 0 !== skim.engine.vars.vertices[a[b]] && skim.engine.vars.vertices[a[b]].destroy();
	a = Object.keys(skim.engine.vars.primitives);
	for (b = 0; b < a.length; ++b)
		void 0 !== skim.engine.vars.primitives[a[b]] && skim.engine.vars.primitives[a[b]].destroy();
	this.cyclicTextGen();
	this.pageInterface.updateToolMenu(this.toolInfo)
};
site.TextringTool.prototype.cyclicTextGen = function () {
	this.canvasTextTool.setText(this.toolInfo.text);
	this.canvasTextTool.setFont(this.toolInfo.fontFamily);
	this.canvasTextTool.setStyle(this.toolInfo.fontStyle);
	this.canvasTextTool.setWeight(this.toolInfo.fontWeight);
	this.canvasTextTool.setCircumference(10 * this.toolInfo.size);
	this.canvasTextTool.setTextType(site.textTypeFillCropTotal);
	site.debugObj("toolInfo", this.toolInfo);
	site.debugObj("canvasTextTools", this.canvasTextTool);
	this.canvasTextTool.generateTextRing()
};
site.TextringTool.prototype.onRingTextGen = function () {
	var a = null,
	b = null,
	a = 2,
	b = 10 * this.toolInfo.size / (2 * Math.PI) + a / 2 + 4;
	this.canvasTextTool.text = "الحب";
	this.canvasTextTool.setFont(this.toolInfo.fontFamily);
	this.canvasTextTool.setStyle(this.toolInfo.fontStyle);
	this.canvasTextTool.setWeight(this.toolInfo.fontWeight);
	this.canvasTextTool.setRLengthTotal(10);
	this.canvasTextTool.setCircumference(10 * this.toolInfo.size);
	this.canvasTextTool.setRadius(this.canvasTextTool.radius + ((10 + this.canvasTextTool.totalRLength) /
			2 - 3));
	this.canvasTextTool.setTextType(site.textTypeFill);
	this.canvasTextTool.setOpening(40);
	this.canvasTextTool.setHeight(100);
	this.canvasTextTool.generateTextRing();
	a = skim.ringUtils.createVertControlSet(0, b, a, this.canvasTextTool.height, 5, 4);
	for (b = 0; b < a.vert.length; b++)
		a.vert[b].commit();
	(new skim.engine.RingDef(a.vert, Transformer.creation.getModeVolType())).commit();
	skim.engine.update_skeleton();
	skim.engine.update_parametrics();
	skim.engine.update_blobtree()
};
site.TextringTool.prototype.utilsInit = function () {
	site.RingTool.prototype.utilsInit.call(this);
	this.progress = new site.JweelProgress2D(this.canvas);
	this.computeWarning = new site.JweelComputationWarning(this);
	"LQ" === this.genMethod ? this.setFastGeneration() : this.setNiceGeneration();
	this.canvasTextTool = new site.CanvasTextTool
};
site.TextringTool.prototype.startingLoad = function () {
	this.loadObject()
};
site.TextringTool.prototype.setGenMethod = function (a) {
	this.genMethod = a
};
site.TextringTool.prototype.setNiceGeneration = function () {
	skim.instances.modeler.setAccuracyLevel(4);
	skim.textUtils.canvasCompression = 1
};
site.TextringTool.prototype.setFastGeneration = function () {
	skim.instances.modeler.setAccuracyLevel(2);
	skim.textUtils.canvasCompression = 2
};
site.textTypeFillCrop = "fillcrop";
site.textTypeFillCropTotal = "fillcroptotal";
site.textTypeFill = "canvasfill";
site.ringMethodManual = "manual";
site.ringMethodAutom = "autom";
site.CanvasTextTool = function () {
	this.text = "";
	this.symbolsFont = "Symbols";
	this.fontSize = 12;
	this.fontFamily = "arial";
	this.fontStyle = this.fontWeight = "";
	this.textType = site.textTypeFillCropTotal;
	this.ringMethod = site.ringMethodAutom;
	this.opening = 0;
	this.radius = 80.152;
	this.totalRLength = 15;
	this.thickness = this.totalRLength / 5;
	this.rLength = 3 * this.thickness;
	this.ringMaxHeight = 150;
	this.ringMinHeight = 40;
	this.height = this.clamp(95, this.ringMinHeight, this.ringMaxHeight);
	this.defaultwidth = 450;
	this.defaultHeight = 750;
	this.defaultpadding =
		20;
	this.textColor = "black";
	this.backgroundColor = "white";
	this.internalCanvas = document.createElement("canvas");
	this.ctx = this.internalCanvas.getContext("2d");
	this.hasBeenComputed = !1;
	this.canvasRingCreator = new skim.textUtils.CanvasRingCreator;
	this.testSpan = document.createElement("span")
};
site.CanvasTextTool.prototype.displayParams = function () {
	console.log("ring parameters: " + {
		rlength : this.rLength,
		height : this.height,
		thickness : this.thickness,
		radius : this.radius
	})
};
site.CanvasTextTool.prototype.setOpening = function (a) {
	this.opening !== a && (this.hasBeenComputed = !1);
	this.opening = a
};
site.CanvasTextTool.prototype.setFont = function (a) {
	this.fontFamily !== a && (this.hasBeenComputed = !1);
	this.fontFamily = a
};
site.CanvasTextTool.prototype.setWeight = function (a) {
	this.fontWeight !== a && (this.hasBeenComputed = !1);
	this.fontWeight = a
};
site.CanvasTextTool.prototype.setRingMaxHeight = function (a) {
	this.ringMaxHeight !== a && (this.hasBeenComputed = !1);
	this.ringMaxHeight = a
};
site.CanvasTextTool.prototype.setHeight = function (a) {
	this.height !== this.clamp(a, this.ringMinHeight, this.ringMaxHeight) && (this.hasBeenComputed = !1);
	this.height = this.clamp(a, this.ringMinHeight, this.ringMaxHeight);
	this.ringMethod === site.ringMethodAutom && console.warn("Setting a manual height has change the ring generation method. Height won't be computed automatically anymore for your text");
	this.ringMethod = site.ringMethodManual
};
site.CanvasTextTool.prototype.setStyle = function (a) {
	this.fontStyle !== a && (this.hasBeenComputed = !1);
	this.fontStyle = a
};
site.CanvasTextTool.prototype.setText = function (a) {
	this.text !== a && (this.hasBeenComputed = !1);
	this.text = a
};
site.CanvasTextTool.prototype.setRadius = function (a) {
	this.radius !== a && (this.hasBeenComputed = !1);
	this.radius = a
};
site.CanvasTextTool.prototype.setSymbolsFont = function (a) {
	this.symbolsFont !== a && (this.hasBeenComputed = !1);
	this.symbolsFont = a
};
site.CanvasTextTool.prototype.setCircumference = function (a) {
	this.setRadius(a / (2 * Math.PI))
};
site.CanvasTextTool.prototype.setRLength = function (a) {
	this.rLength !== a && (this.hasBeenComputed = !1);
	this.rLength = a
};
site.CanvasTextTool.prototype.setRLengthTotal = function (a) {
	this.totalRLength !== a && (this.hasBeenComputed = !1);
	this.totalRLength = a;
	this.setThickness(this.thickness)
};
site.CanvasTextTool.prototype.setThickness = function (a) {
	this.thickness !== a && (this.hasBeenComputed = !1);
	this.thickness = Math.min(a, this.totalRLength / 2);
	this.rLength = this.totalRLength - 2 * this.thickness
};
site.CanvasTextTool.prototype.setHeight = function (a) {
	if (this.ringMinHeight !== a || this.ringMaxHeight !== a)
		this.hasBeenComputed = !1;
	this.ringMaxHeight = this.ringMinHeight = a
};
site.CanvasTextTool.prototype.setTextType = function (a) {
	this.textType !== a && (this.hasBeenComputed = !1);
	this.textType = a
};
site.CanvasTextTool.prototype.getFormatedFont = function (a) {
	return 0 == a ? this.fontWeight + " " + this.fontStyle + " " + this.fontSize + "px " + this.fontFamily + ", " + this.symbolsFont : this.fontWeight + " " + this.fontStyle + " " + a + "px " + this.fontFamily + ", " + this.symbolsFont
};
site.CanvasTextTool.prototype.getHeight = function () {
	switch (this.ringMethod) {
	case site.ringMethodAutom:
		return this.hasBeenComputed ? this.height : -1;
	case site.ringMethodManual:
		return this.height;
	default:
		return -1
	}
};
site.CanvasTextTool.prototype.updateFontStyle = function () {
	this.ctx.font = this.getFormatedFont(this.fontSize)
};
site.CanvasTextTool.prototype.updateCanvasTextTool = function () {
	0 === this.opening && this.textType !== site.textTypeFill && (this.text = this.text[this.text.length - 1] + this.text);
	var a = Math.floor(7E5 / (100 + this.opening)),
	b = this.computeFontSizeFromWidth(1E3),
	c = this.getHeightFromFontSize(this.text, b) * (100 + this.defaultpadding) / 100;
	console.log("first dimensions: width=1000, height=" + c + ", fontSize=" + b);
	a /= 1E3 > c ? 1E3 : c;
	this.internalCanvas.width = 1E3 * a;
	this.internalCanvas.height = c * a;
	this.fontSize = Math.min(this.computeFontSizeFromWidth(this.internalCanvas.width),
			1E3);
	skim.utils.assert(1E3 !== this.fontSize, "font size has been clamped to 1000");
	console.log("internalCanvas dimensions: width=" + this.internalCanvas.width + ", height=" + this.internalCanvas.height + ", fontSize=" + this.fontSize);
	skim.utils.assert(8E3 >= this.internalCanvas.height, "Canvas height might be too high for some computers");
	this.updateFontStyle();
	this.clearCanvas()
};
site.CanvasTextTool.prototype.clearCanvas = function () {
	this.ctx.fillStyle = this.backgroundColor;
	0 === this.internalCanvas.width && (this.internalCanvas.width = this.defaultwidth, this.internalCanvas.height = this.defaultHeight);
	this.ctx.fillRect(0, 0, this.internalCanvas.width, this.internalCanvas.height)
};
site.CanvasTextTool.prototype.getHeightFromFontSize = function (a, b) {
	this.testSpan.innerHTML = a;
	this.testSpan.style.font = this.getFormatedFont(b);
	document.body.appendChild(this.testSpan);
	var c = this.testSpan.getBoundingClientRect(),
	c = Math.ceil(c.height);
	document.body.removeChild(this.testSpan);
	return c
};
site.CanvasTextTool.prototype.getWidthFromText = function (a, b) {
	this.testSpan.innerHTML = a;
	this.testSpan.style.font = this.getFormatedFont(b);
	document.body.appendChild(this.testSpan);
	var c = this.testSpan.getBoundingClientRect().width;
	document.body.removeChild(this.testSpan);
	return c
};
site.CanvasTextTool.prototype.computeFontSizeFromWidth = function (a) {
	console.time("Computing size from width");
	var b = 25,
	c = 0,
	d = new skim.utils.Security(skim.utils.maxSec);
	for (d.init(skim.utils.maxSec, "CTT: First pass on font"); d.valid() && c < a - 4 * b; d.inc())
		b += 75, this.ctx.font = this.getFormatedFont(b), c = this.ctx.measureText(this.text).width;
	d = new skim.utils.Security(skim.utils.maxSec);
	for (d.init(skim.utils.maxSec, "CTT: Second pass on font"); d.valid() && c > a - 4 * b; d.inc())
		b -= 3, this.ctx.font = this.getFormatedFont(b),
		c = this.ctx.measureText(this.text).width;
	skim.utils.assert(c < a, "FontSize will be too big for this canvas width");
	console.timeEnd("Computing size from width");
	return b
};
site.CanvasTextTool.prototype.computeXofText = function () {
	return 2 * this.fontSize
};
site.CanvasTextTool.prototype.computeYofText = function () {
	return this.internalCanvas.height / 2
};
site.CanvasTextTool.prototype.clamp = function (a, b, c) {
	b = a < c ? a > b ? a : b : c;
	a !== b && console.warn("height has been clamped");
	return b
};
site.CanvasTextTool.prototype.generateTextRing = function () {
	var a = this;
	fontdetect.onFontLoaded(a.symbolsFont, function () {
		fontdetect.onFontLoaded(a.fontFamily, function () {
			a.computeVariables();
			a.canvasRingCreator.setParams({
				rLength : a.totalRLength,
				zLength : a.height,
				radius : a.radius,
				thickness : a.thickness
			});
			a.canvasRingCreator.create(a.internalCanvas)
		}, function () {
			console.error("CanvasTextTool - failed to get " + a.fontFamily + " font.")
		}, {
			msTimeout : 3E3
		})
	}, function () {
		console.error("CanvasTextTool - failed to get " +
			a.symbolsFont + " font.")
	}, {
		testString : "ഀഁംഃഄഅആഇഈഉഊഋഌ഍എഏഐ഑ഒഓഔകഖഗഘങചഛജഝഞടഠഡഢണതഥദധനഩപഫബഭമയരറലΆ·ΈΉΉΊ΋"
	})
};
site.CanvasTextTool.prototype.computeVariables = function () {
	if (!this.hasBeenComputed) {
		console.time("Compute variables");
		this.updateCanvasTextTool();
		console.time("Adding text");
		this.ctx.fillStyle = this.textColor;
		this.ctx.textBaseline = "middle";
		"" !== this.text ? this.textType !== site.textTypeFill ? 0 === this.opening ? this.renderTotalCropText(this.text, this.computeXofText(), this.computeYofText()) : this.renderCropText(this.text, this.computeXofText(), this.computeYofText()) : this.ctx.fillText(this.text, this.computeXofText(),
			this.computeYofText()) : console.error("Error : cannot add text if there is no text!");
		console.timeEnd("Adding text");
		console.time("Cropping all the canvas");
		var a = site.Draw2DUtils.getCropRect(this.ctx);
		console.timeEnd("Cropping all the canvas");
		this.ringMethod === site.ringMethodAutom && (this.height = this.clamp(2 * Math.PI * this.radius * a.height / a.width, this.ringMinHeight, this.ringMaxHeight));
		var b = document.createElement("canvas"),
		c = b.getContext("2d");
		b.width = a.width;
		b.height = a.height;
		console.log("Drawing internalCanvas width: " +
			a.width + " and height: " + a.height);
		var d = this.opening * a.width / 200,
		e = a.width * (100 - this.opening) / 100,
		f = {
			x : 0,
			y : 0,
			width : 0,
			height : 0
		},
		g = {
			x : 0,
			y : 0,
			width : 0,
			height : 0
		};
		f.x = a.x;
		f.y = a.y;
		f.width = a.width;
		f.height = a.height;
		g.x = d;
		g.y = 0;
		g.width = e;
		g.height = b.height;
		skim.canvasUtils.safeDrawImage(c, this.internalCanvas, f, g);
		this.internalCanvas = b;
		this.ctx = c;
		console.timeEnd("Compute variables");
		this.hasBeenComputed = !0
	}
};
site.CanvasTextTool.prototype.resetCtxCanvas = function (a, b, c) {
	a.fillStyle = this.backgroundColor;
	a.fillRect(0, 0, a.canvas.width, a.canvas.height);
	a.fillStyle = c;
	a.font = this.getFormatedFont(b)
};
site.CanvasTextTool.prototype.renderTotalCropText = function (a, b, c) {
	if (a && "string" === typeof a && 0 !== a.length) {
		var d = String.prototype.split.call(a, ""),
		e = 0,
		f,
		g = b,
		e = 1E3 * (100 * this.ctx.measureText(a).width / (100 - this.opening)) / (2 * Math.PI * this.radius * this.fontSize);
		a = this.computeCropColPos(d, e, 250);
		console.time("Drawing Letters");
		var e = 0,
		h = 1,
		l = 1,
		k = new skim.utils.Security(skim.utils.maxSec);
		for (k.init(skim.utils.maxSec, "CTT: Prestep on total crop"); k.valid() && 0 < h; l++, k.inc())
			if (1 < d.length) {
				var m = d.length - l -
					1;
				f = d[m];
				g -= a.positionning[a.positionning.length - l] * this.fontSize / 250;
				this.ctx.fillText(f, g, c);
				h -= (a.xDetected[m - 1] + a.boundingBoxes[m][1]) * this.fontSize / 250
			}
		g = b;
		k = new skim.utils.Security(skim.utils.maxSec);
		for (k.init(skim.utils.maxSec, "CTT: Total crop writing"); k.valid() && e < d.length; k.inc())
			f = d[e], this.ctx.fillText(f, g, c), e < d.length - 1 && (g += a.positionning[e] * this.fontSize / 250), e++;
		console.timeEnd("Drawing Letters");
		this.ctx.fillStyle = this.backgroundColor;
		b += Math.ceil(a.firstLetterCrop * this.fontSize /
			250);
		this.ctx.fillRect(0, 0, b, this.ctx.canvas.height);
		g += Math.ceil(a.firstLetterCrop * this.fontSize / 250);
		skim.utils.assert(0 < this.ctx.canvas.width - g, "crop ending for total closure is false");
		this.ctx.fillRect(g, 0, this.ctx.canvas.width - g, this.ctx.canvas.height)
	} else
		console.log("Can't render an empty text")
};
site.CanvasTextTool.prototype.renderCropText = function (a, b, c) {
	if (a && "string" === typeof a && 0 !== a.length) {
		var d = String.prototype.split.call(a, ""),
		e = 0,
		f,
		e = 600 * (100 * this.ctx.measureText(a).width / (100 - this.opening)) / (2 * Math.PI * this.radius * this.fontSize),
		g = this.computeCropColPos(d, e, 150);
		console.time("Drawing Letters");
		var e = 0,
		h = new skim.utils.Security(skim.utils.maxSec);
		for (h.init(skim.utils.maxSec, "CTT: Normal crop writing"); h.valid() && e < a.length; h.inc())
			f = d[e], this.ctx.fillText(f, b, c), b += g.positionning[e] *
			this.fontSize / 150, e++;
		console.timeEnd("Drawing Letters")
	} else
		console.log("Can't render an empty text")
};
site.CanvasTextTool.prototype.computeCropColPos = function (a, b, c) {
	var d = document.createElement("canvas"),
	e = d.getContext("2d");
	e.fillStyle = this.textColor;
	e.font = this.getFormatedFont(c);
	var f = 0,
	g,
	h = e.measureText(a[f++]).width,
	l = new skim.utils.Security(skim.utils.maxSec);
	for (l.init(skim.utils.maxSec, "CTT: Looking for wider letter"); l.valid() && f < a.length; l.inc())
		var k = e.measureText(a[f++]).width, h = k > h ? k : h;
	d.height = this.getHeightFromFontSize(a.join(""), c);
	d.width = h + 4 * c;
	var k = [],
	f = 0,
	m = 2 * c;
	console.time("Computing BBoxes for all letters");
	l = new skim.utils.Security(skim.utils.maxSec);
	for (l.init(skim.utils.maxSec, "CTT: Computing Bounding Boxes"); l.valid() && f < a.length; l.inc())
		g = a[f++], this.resetCtxCanvas(e, c, this.textColor), e.textBaseline = "top", e.fillText(g, m, 0), k.push(site.Draw2DUtils.getNiceHorizontalCrop(e)), k[k.length - 1][1] >= h && (k[k.length - 1][1] + k[k.length - 1][0] === d.width ? console.error("Letters has been cropped for this font") : console.warn("canvasMeasureText is not accurate enough"));
	console.timeEnd("Computing BBoxes for all letters");
	console.time("Detecting crop for each letters");
	f = 0;
	e = [];
	h = [];
	l = new skim.utils.Security(skim.utils.maxSec);
	for (l.init(skim.utils.maxSec, "CTT: Detecting collision"); l.valid() && f < a.length - 1; l.inc())
		console.time("Letter collision detection"), e.push(this.detectCollision(a[f], a[f + 1], k[f], k[f + 1], m, d.height, c, b)), console.timeEnd("Letter collision detection"), h.push(k[f][0] + k[f][1] - k[f + 1][0] - e[e.length - 1]), f++;
	console.timeEnd("Detecting crop for each letters");
	c = b = 0;
	1 < a.length && (b = h[0] + k[1][0] - m, c = b - k[0][0] +
			m);
	return {
		positionning : h,
		firstLetterCrop : b,
		lastLetterCrop : c,
		xDetected : e,
		boundingBoxes : k
	}
};
site.CanvasTextTool.prototype.detectCollision = function (a, b, c, d, e, f, g, h) {
	var l = document.createElement("canvas"),
	k = l.getContext("2d"),
	m = 0,
	n = !1,
	p = 0;
	h = Math.floor(h);
	console.log("Asking for a " + h + " collision");
	l.height = f;
	l.width = c[1];
	console.log("collisionCanvas.height: " + l.height);
	console.log("collisionCanvas.width: " + l.width);
	var q = c[1] > d[1] ? c[1] : d[1];
	f = this.getTextBoundingBox(a + b, e, f, g);
	var l = f[1] - d[1] + e - d[0],
	r = c[1] - (f[1] - d[1]),
	s = new skim.utils.Security(skim.utils.maxSec);
	for (s.init(Math.max(q + (c[0] -
					e), l + (c[0] - e)), "CTT: Collision drawing"); s.valid() && !n; s.inc(), m++) {
		this.resetCtxCanvas(k, g, this.textColor);
		k.textBaseline = "top";
		k.fillText(a,  - (c[0] - e), 0);
		q = k.getImageData(0, 0, k.canvas.width, k.canvas.height);
		this.resetCtxCanvas(k, g, this.textColor);
		k.textBaseline = "top";
		k.fillText(b, l - m, 0);
		for (var t = k.getImageData(0, 0, k.canvas.width, k.canvas.height), u = p = 0; u < q.height && !n; u++)
			for (var v = Math.max(0, q.width - r - m); v < q.width && !n; v++) {
				var w = 4 * (u * q.width + v);
				site.Draw2DUtils.isBlackPixel(q.data, w) && site.Draw2DUtils.isBlackPixel(t.data,
					w) && (p++, p >= h && (n = !0))
			}
	}
	skim.utils.assert(p >= h, "collision detection for letters did not work between letters '" + a + "' and '" + b + "'");
	console.log("collision detection for letters '" + a + "' and '" + b + "': " + m);
	m--;
	skim.utils.assert(-1 !== m, "Should not have a backward collision!");
	m = m + c[1] - (f[1] - d[1]);
	return n ? m : 0
};
site.CanvasTextTool.prototype.getTextBoundingBox = function (a, b, c, d) {
	var e = document.createElement("canvas"),
	f = e.getContext("2d");
	f.fillStyle = this.textColor;
	f.font = this.getFormatedFont(d);
	var g = f.measureText(a).width;
	e.width = g + 4 * d;
	e.height = c;
	c = [];
	this.resetCtxCanvas(f, d, this.textColor);
	f.textBaseline = "top";
	f.fillText(a, b, 0);
	c = site.Draw2DUtils.getNiceHorizontalCrop(f);
	c[1] >= e.width && (c[1] + c[0] === e.width ? console.error("Letters has been cropped for this font") : console.warn("canvasMeasureText is not accurate enough"));
	return c
};
site.EmbossedRingTool = function (a, b, c) {
	site.RingTool.call(this, a, b, c);
	this.toolType = toolNames.embossedring;
	this.defaultParams.toolInfo = {
		size : 54,
		rlength : 1.1,
		zlength : 7,
		round : 0.5,
		bump : 0.6,
		lambda : 1.1,
		uniform_zlength : !0,
		dataurl : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYMAAAA0CAYAAABo3FRrAAAgAElEQVR4Xu3dBXPDuNYG4OxdZmZmZmac/V37txZmmZmZmZnx3sff93a0Wrtx06RNu/KMJ2ljy9KB94CO5B1uueWWvybtaBRoFGgUaBT4V1Ngh2YM/tX8b4NvFGgUaBToKNCMQROERoFGgUaBRoFmDJoMNAo0CjQKNAq0yKDJQKNAo0CjQKNASxM1GWgUaBRoFGgUaHMGTQa2LAV22GGHlb77nvOvv/6a/PHHH1t2XK3jjQKbRYE2gbxZlG/PHUUBIL/jjjtOdtppp+7Tueuuu3affvP/3XfffbLbbrt137/++uvJ+++/P/n1119Htd8uahRoFPg/CjRj0CRh6SgA5HfZZZfJnnvuOdlnn30me++992SPPfboAN//fe68886dQfDdb/4vKnjllVcmjzzyyOTbb79dunG1DjUKLDMFmjFYZu78C/sG1A866KDJUUcdNTn44INXQP6XX36Z/Pnnn1008J///KeLAg488MDJIYcc0kUK/v/bb79Nnn/++cm9997bRQjtaBRoFBhPgWYMxtOqXblgCogEjjvuuMkpp5zSRQNffvnl5MMPP+w+f/jhhw7sc4gGzjzzzMk555zTRRCMwe+//z558cUXJ3fffffkq6++WnBvW/ONAtuLAs0YbC9+btnR7LXXXp0ROOOMM7r0z2uvvTZ5/fXXOw+fEZACyiEyOPLIIycXXXTR5Nhjj+2MgUjBxPFLL73UGYMvvvhiy9KidbxRYDMo0IzBZlC9PfNvFJD3ZwguuOCCLuXz3HPPTV544YUu718agdwkajj33HO7VJKI4IgjjpgwJozBq6++2hmDTz/9tFG5UWAqBaQeFRt8//333ae/HSlc4JiYnyKXUpgckbKSbeoDttAFczUGUVyfOSmoM3+HNv6X/C8CO3wifggeom9X4i9KTkray7UTcmdKLiPohJyAO1OdkxLNRfWtbhevjz766Mnll1/eeftvvPHG5KGHHurAvM8QiABOOOGEyVlnndWlgkQN5513Xjd/YHyiiXvuuWfy0UcfbdQQ2nO2KAXI188//zx58803u8IDzkdpDKIfqtX233//zvk49NBDu6KF7YhJ6zIGJejI1wKcn376qSOw74DI306KmglA91HiVI0EgIASwudkjRHeZ0oLNxqstpKc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",
		svg : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="52" width="387"><image xmlns="http://www.w3.org/2000/svg" href="data:image/png;base64,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" preserveAspectRatio="none" x="1.778611697289578" y="14.1602390321031" width="139.81324292666437" height="25.43813853617382" jweel_original="data:image/png;base64,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"/><image xmlns="http://www.w3.org/2000/svg" href="data:image/png;base64,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" preserveAspectRatio="none" x="148.80758682976725" y="7.31796939159634" width="88.17881147225192" height="37.029360907745705" jweel_original="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAABFCAYAAADNRu0cAAAPzElEQVR4Xu2dCaxt1xjHXTULoeaaqjVHjCWlipTqoEVKB6m2KH2EIijVGB5RlAZpq2hrag3lEUMrhraosWiRNjV7iHl85ojp+f+utU7WWWfNe+9zzr1372Tlnnv2t741/fe3vmnts3KVdXht3779YRrWfczQDtbfbSsrK3uvw6Gu+SGtrLURCFwviPR5F31/TOTehSMAl3OllxKADshSoKqZ0a0C4K41FUba+czAUgBQgGObBGyvHmjYIwAHmtiubBcKQCPp2FJvGBjINn13UsEAY/XdqiMACyZyESQLAaAxEt5ipJ477jP0D/raltLJEC/Ae2mA1xQL8VzIWEvHsVHp5r4oRur5Wy3AO14YQepVXRF+MzxGAFZN69yI5wpAgQWp51qqAO4QgePClhGLH3rjD0vqjgAsmaX508wNgAHwbdVw9xYw+Nt0ief7VREDhgsQ4/+LXTu2SNimjo2VimdgLgAUUNhyff/dbgLEZcU99QiN5QwAudjCAXLKit61C9hb+znWS8/A4AD0gGJ7g75XYuFGey++bL1swWzj+PiQhGzxsWsE4BI+DYMC0FioAMV1sxAW27HLXHiGxyqYjWV9QYJvJ4nbpb9j3fgMDA1A3+igJ52knzE8cLsA6ol/T98T++X72IW+2WTsjAAabgYGA2DCQu0kiTxjZgKqAot4kwCIrjheSzQDQwIwJP06bb/eNrtFgDrEnUvd356Y206Sd4nWbF11ZRAARnQ/Jq5TVopjeMBrxqjQ/T94+qa7WCMAlxC6QwEQi9S6SNxhnyGptallHkKGh8/HA6h/u7ntlv6utTqBNLeSGLs7TFxqbggVYZN1sw0FwJDfj86epE4dX7s4nkTF34ceORO2Ex1WcMwZPbNl1/ZjvdAbVQajjblKOe/7GDKGHwUBMLNmQwEQa9RmJNtB8DSwDVZbop7hETUmvMiIP3mdtv8+VmKRPAzoAFssobeke5dp/XZzCY2fF39sCZhnYv69A9BIK3QxF3hIvuIMF2+ADMz695IgCoT7XFYbMiVLc0LsnRISCKtr4gYFMg9xcgczaw/AUyCfiv8PAUDrj7Nitwl4FjkalCtNky4cT0+ceaI3UkKCkXioQj7wUIGC2yET1ochZ3yyCI1Qnqddl9W1HAKAiONdWrZaHzHm6bXhtawR4dGHtpQNkZCgeQjp4NmUt8Du5c9hsQ/XgDAVGFjdkXoHYIkiUULjGR6r8d5cNovRR0LWt21yXceDzZwxft+wIOUtuxMVzF/VA5zbkdTPTcsMQPcpLopimG0nFQ9et+E4Az7G7m65PLiMOesOMdsvulsso2jGAMkJEvUpl6+5ZSkB6Inv4oEXDLhIEuQmdhnvR1xQVQ9cxgBpcmN5Orw/dduWFYCuP694Egt0mCJJOgTA1LebiO9+Znvc37TxN/29QuVDKudJUv2mpe2Izlcd+enDAAno8W7S8Mzwlg6AtYZHYMBLFQ/WeK6mPj5Rhe3tVip4B/6osoPKw1Vsatp39PkZAuFFNSCMKPvVLqeCh7dYELj9F99QTsCEZKkAaCbBnnBDf8HqqkrZFw+bqBpax6ZITA0gvMm/qf5/k8pBKl81APuapVFf76zPp6jY14b8VZ8fXQPCyNZbLen7NkCcMa4pALqGR/UWwqAzOkfWldMKtoAkRgH/gMq9VHgoHiRg/SJAdyd9902Va5l7n9ff/UULGJNXxOgq8hgE+pEyQKolqgPAVHh069JIQM+AGGrAcwnHaSw30wKcp3JfsxCHCVDvi6FJ9F/RvfuZ+//U3weL/pICAIYWt9VYSOlqTTyNQEjtSMtjBXtbSbO1mtE5ii3q3OKn7qsP79T9Iw3Nd/V3TwHqtwkAvlf3DnPuHyn6czJtxFwcrTtH76lsBXrlcvgBPf2jk5SKWIR2LZslaykg1f7uov2Sit1dPqzPBwtQ/04A8IO6h55oryNE/64MAGNbZov+R8jMjd/7TTcJBM+g9Hn+X1Uondgh6TzDoVO0QrxSugyB90HHrPZP11w9zZmv09Xk0zNgcrdgSPdVnU9m6sS2zGprtcAAaVqTiIFkh7UqqQddjBLQeoDpbKVmnjq6VBVOKhmDpVHbGBKA6e5OvdM00ccmpN9tdO/bKtcxND/W34eozk8yAIxtmS0ATD20TccoIgaSHdJEFVooAD3Do2atu9A2Pc0lDWo8dxTdp1Vu6dCfLTAdlQDga3TvOOd+9iGM+P5gQcIB9WtdVykDpEklSngjptxriwZgykQvWfMWmmoJUdpIBIAA8lEht4roSe7EWr65aQOLEYPllxnp5x95aAKebaNv32lCD5+JTS8MgAVbZem619JVK+mlDWhM1xUt7pO7OXWCPkDR3lY05zu0PzdAzSYOOGoLGS5IvGydhATOGSBV85VYV6QyxsxUXxcCQLP12sPlzE2T6yAxqQsLxwUUb/qCE/oLjsTZU5+JENzFfMdcsNBfLwG70a/QzZqB5/QldoDMktTkAMZ0SR4UxjefMyG5SdQEujpH764R8U/5tLI6Vq7/me3xBN0/0aM5QZP/KvPgPVn3nqNyTZXfqbxN5eW6T2LC3K8+vAbigRTlgbJvKrPjyJ4DmrsEDAy4d50so9M0e/VL0KG2ie9eqXJVh/4b+oy++3iVnVT+ovIelbMEvFTWcEmTnWg8YeDzSjruDfA4b+LnEAK8onNAcwVgwHobJDab8T8NGg1R29fX5KMH2u3VLurf9QE96I0q5wt4P+uEHFNZ7e0UijGX8s48rDPrY7b/2JFOzpsUnQe2/ZsbAM3T4r7LOXq+t3TyYnSZp7rJr5Xrk9rEj0c47XCVvQL0pwgoz8rxyd1XO0jWu6rg6nmAys4pN0+Kn1mTVAQk1x37Inke6urjtjCfJwB9X1PvW6+dLU1sMgVIdMWKdW4F1NbVRXOoyotUyGxhu8W18mwVpKG9PqcPj4hluRj98M1enVDz19aXJDuQR0jbB4jnx3L9DN1XmzkDpJQtRgaSr/rlT3MBYEDvG9oQSIbjNFlNsU1/NTQu/HivUNlHhVjvK1U2q5CEerHK/Z06/9LnA0MhNvGB/kyVJ5SuuOj+q3Kc+L2uos4UacYAmdkpDGBJgmAL9g0Oyzt57NPv6+AAVKdRUt03lw6qgzHAnGUnks4PgNogvPZSlRupkOlyuMAwORCl+y/Tdy/xJhyj4ynud6JjDZgjpF/pRc7gyeL10dIKIbqMqpKNgGTmOXsMlD7NANAwxTWSPcaXG3wAfJ1fTJ5r0wDQB71frVkP1JhIpcfqe55hig51kOYLiTe5RMdrg/HrudswrpZ7ivYHltDoju/Q/zurINW4kIgksqLv/UflchXyBNneySu8RDz+UTIXKZqMAVL0kBo9MnQU1DaddGRPAdBBdNVxvtAgA09HZ56lE24stdTxTFhVefipYPQ9tlkLPr4+VmA4LTIHZEQ/xruH5HJjvzNV1c7t9eW3VNDxrhS9G1kpnYYkXYEBUqWmZPTuqOtrAsAAYIKhk9zozcBCTsnBjA6/T+pD7nW9VKl+IAISnXMeDxRA0O9CQOKsB2lV7oP+U/1PxvOPYnOpdo7QvbPN/ReLFj2z16vAAKk21DJbOr5BMDAVDVmdmMDEuoMtlhQGxKH3ys0NfGY8uQPR7vhmfFfmITpGkzV5k7++u50qsaXewKn8JNG8PQEkYsOfAKQeDZEP9MfgpbbIhsZpzWLdQ7SAttcro781qShm3vyX0rv9npGEKxnw2crW3zPjZDQDIRQTeiNSp19C6jLj6lcqHlzCespYEjuMBPflmr/X/3sIHKTcRy/VIxnV36J/pe/urbozWS+iv4XuoU/eQQWn9TNFZ3XDkn4X0WSkVZH+F2ooA2yqTAk0AGh/XyP1JqOiQXlEOCZprCo3raWhyESk4sElzUxFATRP31cldDN7Ee3Ar5d05Koe/rovqhCic68TVRff4dQlekAO2AEnianfK+lsLY3aSR0Wat6xCnTLqdi/3YJjweTacUGP1CO7pdop2dJYrE5mgkPV7Js8uTfz+jLxI5SGE9heSCn8esR1k1dECpKIsLvqT37rTnREU4gWEcZ7vu69Nse75X4GJJ2TQ8Q/9IJSt6sT/dK3glHe7QsNa8eGpGPhOv0CUm2jCQCmkl3pIw8Kuk7RgxLY0gHgI1X/z7k+qy6uGFL1fSl4ruo/ztYXHXrhZhWSWPfRvehBplybqftm14u9Raxzapz45yJRk2046og2eznjAJAo9f7l/qA0yuVCttoEAJlgHigLsKoguc83AECcwUjAP5WAISIF8fEdJR7v1n2iJp9Rwam9l75jyx/kUluxd3g3HWoPzFUuEpUH4CAjX8NMAwDkgcOdUpTVovrXEz3vfbGH1e1soOM9VQVrmhjvfuL52SGnKrFFdpZ+9LvGEBk8FDfkRM6TtyYVaeXm+NE8r9D4eGk/xIOYMW4Z/4I3URIkw7ml/Fro1IeYi6qz7mf7UwDAsA7YMqCNUkeTitFA3Ne9LhBgeMNV8SU+/iF0W/dM8XJ/zLuYZw1hAhzVjudYuxkdcMrHOErAwtXTpGIlPzRAnnzvi08vPmyzvDnB16vRv44WCHlXYPYSnx1Ei+SsuiLbby9bryMBU1bwlHtrBGDh8mnhDhRpKPvk1/r+UIFhKhkhxFY8OAdC0iqhNd4V6F+4dIiuEEMOXobHAbp5Ra2PUHXdn7yw/HvNSs+4eGhz6lz2CMByAKL/8dqN0E+NsT0T0jtHoCBrZerSouA/fKypu4f+IiFw34Qyp9EFcVCf6ko48biGvmO7f6EK0jMYSUkNRzx811Tv52My+t9MhGUEYCEAITOW7Fv1MZaMSbrUR1TscUn8fwBuXwMa2LxeZbMKQCXlDWkWuvAFkpBAyI83LhAbJkWL9wY+t9R/aRmr736KWq+Sz8wPAY1YLDiYBzoCsAKAZpJJRjhZ5ejKqqTp856YTzmggNdZKn7KVow1vk2kSNH5Yacd3y/Xq87ntBNz/gczYag3ArASRQaEzBuHy9HlCJvdOMAGfY6tmZjxqSqXCjgzaVuSTOT8sa1yXvjWHh8SKtAxSft6g8rF4lGUmCC+SGm2ajc7CSDg6ul8oN0fb2B7tyQYb+QWzhxKHwHYAD63iiadrGd8e4DR/X0OQIM0+LLK5Zp8/o9e4kPaFrmDHG5y+ZDEQHTkIvHg1R3By/j2aC8UsbJ1ViNXfYdKzdYOyENtZyXtKAE7gnDR1QvBF+um/9O52ZCqsXKtvzL2ozZIPcCXlbQjABeNoA7tdwRfh5ajVYvfiGA5jAAcYhnmwFPgY6vGKEltu3PoyWoTWPNIz+qDbCMA57VEPbZjwJf7OdQeWwyyIsuI+HGn9LsRgEMv0wD80cN8q9JEOfzfBo61Hjq3E6NlW51Itq6A8xv5H69m6Xuv9krXAAAAAElFTkSuQmCC"/><image xmlns="http://www.w3.org/2000/svg" href="data:image/png;base64,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" preserveAspectRatio="none" x="244.9068500392585" y="12.972781195600712" width="139.3119475898768" height="25.636904650819318" jweel_original="data:image/png;base64,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"/></svg>'
	};
	this.setDefaultParams();
	this.defaultParams.init.initCamPos = {
		rotNode : {
			px : 0,
			py : 0,
			pz : 0,
			rx : -1.6858431255114774,
			ry : 0.18628425567764723,
			rz : -0.0016350143948474607
		},
		distToTarget : 700
	};
	this.initParams.trackballHelper = !1;
	this.lastToolinfo = this.unpolish_img_data = this.image = null;
	this.undoStack = [];
	this.redoStack = []
};
site.EmbossedRingTool.prototype = Object.create(site.RingTool.prototype);
site.EmbossedRingTool.prototype.constructor = site.EmbossedRingTool;
site.EmbossedRingTool.prototype.savejsonInfo = function () {
	return JSON.stringify({})
};
site.EmbossedRingTool.prototype.setToolInfo = function (a) {
	for (var b = Object.keys(a), c = {}, d = 0; d < b.length; ++d)
		c[b[d]] = a[b[d]];
	b = Object.keys(this.toolInfo);
	for (d = 0; d < b.length; ++d)
		void 0 !== c[b[d]] && (this.toolInfo[b[d]] = c[b[d]]);
	void 0 === this.toolInfo.uniform_zlength && (this.toolInfo.uniform_zlength = !0);
	var e = new Image;
	e.src = this.toolInfo.dataurl;
	var f = this;
	e.onload = function () {
		f.setImageAndSVG(e, f.toolInfo.svg)
	}
};
site.EmbossedRingTool.prototype.setImageAndSVG = function (a, b) {
	this.image = a;
	var c = document.createElement("canvas");
	c.width = this.image.width;
	c.height = this.image.height;
	var d = c.getContext("2d");
	d.drawImage(this.image, 0, 0, this.image.width, this.image.height);
	this.unpolish_img_data = d.getImageData(0, 0, this.image.width, this.image.height);
	this.computeUnpolishedAreas();
	this.toolInfo.dataurl = c.toDataURL();
	this.toolInfo.svg = b;
	this.toolInfo.svg = b.replace(RegExp('href="[^"]*"', "g"), 'href=""');
	95E4 < this.toolInfo.svg.length &&
	console.warn("Next image addition may oversize the toolinfo size limit - 1mo")
};
site.EmbossedRingTool.prototype.getImage = function (a) {
	return this.image
};
site.EmbossedRingTool.prototype.computeUnpolishedAreas = function () {
	var a = document.createElement("canvas");
	a.width = this.image.width;
	a.height = this.image.height;
	var b = a.getContext("2d");
	b.drawImage(this.image, 0, 0, this.image.width, this.image.height);
	for (var c = b.getImageData(0, 0, this.image.width, this.image.height), d = 0; d < this.unpolish_img_data.data.length; d += 4)
		for (var e = 0; 3 > e; ++e)
			this.unpolish_img_data.data[d + e] = 0;
	for (var f = 0, g = 0, h = 0, l = 0, k = this, e = function (a, b) {
		g = 0.5 * k.toolInfo.lambda * (c.data[a] - 128) / 255;
		h = 0.5 * k.toolInfo.lambda * (c.data[b] - 128) / 255;
		0 < g - h ? f = Math.min(f + Math.min(g - h, 0.4) / 0.4, 1) : -0 > g - h && (f = Math.max(f + Math.min(g - h, 0.4) / 0.4, 0));
		Math.abs(0.05 > g - h) ? (l++, 2 < l && (f = Math.max(f - 0.1, 0))) : l = 0;
		k.unpolish_img_data.data[b] = Math.max(k.unpolish_img_data.data[b], Math.round(255 * f));
		k.unpolish_img_data.data[b + 1] = k.unpolish_img_data.data[b];
		k.unpolish_img_data.data[b + 2] = k.unpolish_img_data.data[b]
	}, d = 0; d < this.image.width; d++)
		for (var m = f = 0; m < this.image.height - 1; m++) {
			var n = 4 * (d + this.image.width * m),
			p = 4 * (d + this.image.width *
					(m + 1));
			e(n, p)
		}
	for (d = 0; d < this.image.width; d++)
		for (f = 0, m = this.image.height - 1; 0 < m; m--)
			n = 4 * (d + this.image.width * m), p = 4 * (d + this.image.width * (m - 1)), e(n, p);
	for (m = 0; m < this.image.height; m++)
		for (d = f = 0; d < this.image.width; d++)
			n = 4 * (d + this.image.width * m), p = 4 * (d + 1 + this.image.width * m), e(n, p);
	for (m = 0; m < this.image.height; m++)
		for (f = 0, d = this.image.width - 1; 0 < d; d--)
			n = 4 * (d + this.image.width * m), p = 4 * (d - 1 + this.image.width * m), e(n, p);
	for (d = 0; d < this.unpolish_img_data.data.length; d += 4)
		for (e = 0; 3 > e; ++e)
			this.unpolish_img_data.data[d +
				e] = 255 - this.unpolish_img_data.data[d + e];
	b.putImageData(this.unpolish_img_data, 0, 0);
	console.log(a.toDataURL());
	stackBlurCanvasRGBANoID(a, 0, 0, a.width, a.height, 1);
	this.unpolish_img_data = b.getImageData(0, 0, this.image.width, this.image.height)
};
site.EmbossedRingTool.prototype.getBestImageResolution = function (a) {
	var b = skim.engine.getMaterialInfos();
	a = null !== a ? a : this.toolInfo;
	return (new skim.parametrics.HeightMapRing(10 * a.rlength, 10 * a.zlength, 10 * a.round, 10 * a.bump, 10 * a.size / (2 * Math.PI), 10 * a.lambda, a.uniform_zlength, b.print_wall, b.print_detail, this.image, this.unpolish_img_data)).getHmapresolution()
};
site.EmbossedRingTool.prototype.buildHeightMapRing = function () {
	null !== this.heightmap_ring && this.heightmap_ring.destroy();
	this.heightmap_ring = new skim.engine.HeightMapRingDef(10 * this.toolInfo.rlength, 10 * this.toolInfo.zlength, 10 * this.toolInfo.round, 10 * this.toolInfo.bump, 10 * this.toolInfo.size / (2 * Math.PI), 10 * this.toolInfo.lambda, void 0 === this.toolInfo.uniform_zlength ? !0 : this.toolInfo.uniform_zlength, this.image, this.unpolish_img_data);
	this.heightmap_ring.commit();
	skim.engine.update_skeleton();
	skim.engine.update_parametrics()
};
site.EmbossedRingTool.prototype.loadObject = function () {
	skim.instances.modeler.pageInterface.startSurface();
	skim.utils.assert(null !== this.image, "Error : no image loaded in HeightMapTool, cannot load Object");
	this.buildHeightMapRing();
	this.pageInterface.updateToolMenu(this.toolInfo)
};
site.EmbossedRingTool.prototype.utilsInit = function () {
	site.RingTool.prototype.utilsInit.call(this);
	this.progress = new site.JweelProgress2D(this.canvas);
	this.computeWarning = new site.JweelComputationWarning(this)
};
site.EmbossedRingTool.prototype.loadFiles = function () {
	this.filesToLoad.push("/static/js/fontdetect/fontdetect.2.2.min.js");
	site.RingTool.prototype.loadFiles.call(this)
};
site.EmbossedRingTool.prototype.startingLoad = function () {
	0 !== this.jsonInfo.length && skim.engine.loadJSON(this.jsonInfo);
	this.heightmap_ring = null;
	var a = new Image;
	a.src = this.toolInfo.dataurl;
	var b = this;
	a.onload = function () {
		b.setImageAndSVG(a, b.toolInfo.svg);
		b.pageInterface.updateToolMenu(b.toolInfo);
		b.mode == site.toolModes.view && b.buildHeightMapRing();
		b.saveCurrentToolInfo()
	}
};
site.EmbossedRingTool.prototype.saveCurrentToolInfo = function () {
	this.lastToolinfo = {};
	for (var a = this.getToolInfo(), b = Object.keys(a), c = 0; c < b.length; ++c)
		this.lastToolinfo[b[c]] = a[b[c]]
};
site.EmbossedRingTool.prototype.resetToLastSavedToolInfo = function () {
	this.setToolInfo(this.lastToolinfo)
};
site.EmbossedRingTool.prototype.getLastToolInfo = function () {
	return this.lastToolinfo
};
site.EmbossedRingTool.prototype.pushState = function () {
	this.redoStack.length = 0;
	var a = this.getToolInfo(),
	b = !1;
	0 === this.undoStack.length && (b = !0);
	this.undoStack.push({});
	for (var c = Object.keys(a), d = 0; d < c.length; ++d)
		this.undoStack[this.undoStack.length - 1][c[d]] = a[c[d]], b || this.undoStack[this.undoStack.length - 2][c[d]] === a[c[d]] || (b = !0);
	b || (this.undoStack.length -= 1);
	20 < this.undoStack.length && (this.undoStack = this.undoStack.slice(this.undoStack.length - 20, this.undoStack.length))
};
site.EmbossedRingTool.prototype.undo = function () {
	0 !== this.undoStack.length && (this.redoStack.push(this.getToolInfo()), this.setToolInfo(this.undoStack[this.undoStack.length - 1]), this.undoStack.length -= 1)
};
site.EmbossedRingTool.prototype.redo = function () {
	0 !== this.redoStack.length && (this.undoStack.push(this.getToolInfo()), this.setToolInfo(this.redoStack[this.redoStack.length - 1]), this.redoStack.length -= 1)
};
var RingSliceWidget = function (a) {
	this.slice = Snap(a.svg_tag);
	this.c = {
		x : 140,
		y : 40
	};
	this.ring_infos = void 0 !== a.ring_infos ? a.ring_infos : {
		rlength : 13,
		zlength : 100,
		round : 3,
		bump : 10,
		lambda : 10
	};
	this.min_zlength = 40;
	this.max_zlength = 150;
	this.min_rlength = 11;
	this.max_rlength = 30;
	this.max_height = 45;
	this.events = {
		ring_infos_change : [],
		ring_infos_slide : []
	};
	var b = this;
	this.rl_text = this.slice.text(this.c.x - this.ring_infos.zlength / 2 - 40, this.c.y + this.ring_infos.rlength / 2, (this.ring_infos.rlength + this.ring_infos.bump) / 10 + "mm");
	this.zl_text = this.slice.text(this.c.x - 15, this.c.y + this.ring_infos.rlength / 2 + 33, this.ring_infos.zlength / 10 + "mm");
	var c = {
		fontFamily : "Arial",
		fontSize : 12,
		fontWeight : "bold",
		fill : "#4d4d4d"
	};
	this.zl_text.attr(c);
	this.rl_text.attr(c);
	this.left_line = {
		main : this.slice.line(72, 0, 72, 0),
		bottom : this.slice.line(70, 0, 74, 0),
		head : this.slice.line(70, 0, 74, 0)
	};
	this.left_line.main.attr({
		stroke : "#4d4d4d",
		strokeWidth : "1px"
	});
	this.left_line.bottom.attr({
		stroke : "#4d4d4d",
		strokeWidth : "1px"
	});
	this.left_line.head.attr({
		stroke : "#4d4d4d",
		strokeWidth : "1px"
	});
	this.bottom_line = {
		main : this.slice.line(0, 102, 0, 102),
		left : this.slice.line(0, 100, 0, 104),
		right : this.slice.line(0, 100, 0, 104)
	};
	this.bottom_line.main.attr({
		stroke : "#4d4d4d",
		strokeWidth : "1px"
	});
	this.bottom_line.left.attr({
		stroke : "#4d4d4d",
		strokeWidth : "1px"
	});
	this.bottom_line.right.attr({
		stroke : "#4d4d4d",
		strokeWidth : "1px"
	});
	this.cut_path = this.slice.path("M0,0");
	this.cut_path.attr(void 0 !== a.slice_style ? a.slice_style : {
		stroke : "#999999",
		strokeWidth : "0.5px",
		fill : "#999999"
	});
	this.handles = [this.slice.circle(0,
			0, 1), this.slice.circle(0, 0, 1), null, this.slice.circle(0, 0, 1), this.slice.circle(0, 0, 1)];
	this.handles[2] = this.slice.circle(0, 0, 1);
	this.round_buttons = [];
	for (c = 0; 7 > c; ++c)
		this.round_buttons.push(this.slice.circle(0, 0, this.ring_infos.round)), this.round_buttons[c].attr({
			fill : "#00626b",
			stroke : "#002e32",
			strokeWidth : 0.5
		}), this.round_buttons[c].mousedown(function (a, c, d) {
			a = parseFloat(this.attr("r"));
			b.ring_infos.round = a;
			2 * b.ring_infos.round > b.ring_infos.rlength && (b.ring_infos.rlength = 2 * b.ring_infos.round);
			b.draw();
			b.callEventCallbacks("ring_infos_change")
		});
	for (c = 0; c < this.handles.length; ++c)
		this.handles[c].attr(void 0 !== a.handle_style ? a.handle_style : {
			fill : "#00626b",
			stroke : "#002e32",
			strokeWidth : 0.5
		});
	var d = 0,
	e = 0,
	f = 0,
	g = [null, null, null, null];
	a = [{
			x : 0,
			y : 0
		}, {
			x : 0,
			y : -1
		}, {
			x : 1,
			y : -1
		}, {
			x : 1,
			y : 0
		}
	];
	for (var h = !1, l = function () {
		this.attr({
			fill : "#f98d8d",
			stroke : "#b05a5a",
			strokeWidth : 1
		})
	}, k = function () {
		this.attr({
			fill : "#00626b",
			stroke : "#002e32",
			strokeWidth : 0.5
		})
	}, m = function () {
		h = !0
	}, n = function () {
		h = !1
	}, c = 0; 4 > c; ++c)
		g[this.handles[c].id] =
			a[c], this.handles[c].drag(function (a, c, f, h, k) {
			b.ring_infos.zlength = Math.max(b.min_zlength, Math.min(b.max_zlength, d + g[this.id].x * a));
			b.ring_infos.rlength = Math.max(b.min_rlength, Math.min(b.max_rlength, e + g[this.id].y * c));
			b.ring_infos.bump >= b.ring_infos.zlength / 2 - b.ring_infos.round && (b.ring_infos.bump = b.ring_infos.zlength / 2 - b.ring_infos.round);
			b.ring_infos.bump + b.ring_infos.rlength > b.max_height && (b.ring_infos.bump = b.max_height - b.ring_infos.rlength);
			b.ring_infos.rlength < 2 * b.ring_infos.round && (b.ring_infos.rlength =
					Math.max(b.min_rlength, Math.min(b.max_rlength, 2 * b.ring_infos.round)));
			b.draw();
			b.callEventCallbacks("ring_infos_slide")
		}, function (a, c, f) {
			d = b.ring_infos.zlength;
			e = b.ring_infos.rlength;
			h = !0;
			for (a = 0; 5 > a; ++a)
				b.handles[a].unhover(l, k);
			this.hover(m, n)
		}, function () {
			for (var a = 0; 5 > a; ++a)
				b.handles[a].hover(l, k);
			this.unhover(m, n);
			h ? l.call(this) : k.call(this);
			b.callEventCallbacks("ring_infos_change")
		});
	for (c = 0; 5 > c; ++c)
		this.handles[c].hover(l, k);
	this.handles[4].drag(function (a, c, d, g, h) {
		b.ring_infos.bump = Math.min(f -
				c, b.ring_infos.zlength / 2 - b.ring_infos.round);
		b.ring_infos.rlength = 0 > b.ring_infos.bump ? Math.max(Math.max(b.min_rlength, e - Math.abs(b.ring_infos.bump)), 2 * b.ring_infos.round) : e;
		3 > b.ring_infos.bump && (b.ring_infos.bump = 0);
		b.ring_infos.bump + b.ring_infos.rlength > b.max_height && (b.ring_infos.bump = b.max_height - b.ring_infos.rlength);
		b.callEventCallbacks("ring_infos_slide");
		b.draw()
	}, function (a, c, d) {
		f = b.ring_infos.bump;
		e = b.ring_infos.rlength;
		for (a = 0; 5 > a; ++a)
			b.handles[a].unhover(l, k);
		this.hover(m, n)
	}, function () {
		for (var a =
				0; 5 > a; ++a)
			b.handles[a].hover(l, k);
		this.unhover(m, n);
		h ? l.call(this) : k.call(this);
		b.callEventCallbacks("ring_infos_change")
	});
	this.draw()
};
RingSliceWidget.prototype.addEventCallback = function (a, b) {
	this.events[b].push(a)
};
RingSliceWidget.prototype.removeEventCallback = function (a, b) {
	for (var c = 0; c < this.events[b].length; ++c)
		if (a === this.events[b][c]) {
			for (var d = c + 1; d < this.events[b].length; ++d)
				this.events[b][d - 1] = this.events[b][d];
			this.events[b].length -= 1
		}
};
RingSliceWidget.prototype.callEventCallbacks = function (a) {
	for (var b = 0; b < this.events[a].length; ++b)
		this.events[a][b]()
};
RingSliceWidget.prototype.setRingInfos = function (a) {
	skim.utils.assert(void 0 !== a.rlength && void 0 !== a.zlength && void 0 !== a.bump && void 0 !== a.round, "Error : all parameters must be defined in ring_infos");
	this.ring_infos = a;
	this.callEventCallbacks("ring_infos_change");
	this.draw()
};
RingSliceWidget.prototype.getRingInfos = function () {
	return this.ring_infos
};
RingSliceWidget.prototype.draw = function () {
	this.ring_infos.bump_var = {};
	this.ring_infos.bump_var.r = ((this.ring_infos.zlength / 2 - this.ring_infos.round) * (this.ring_infos.zlength / 2 - this.ring_infos.round) - this.ring_infos.bump * this.ring_infos.bump) / (2 * this.ring_infos.bump);
	this.ring_infos.bump_var.R = this.ring_infos.bump_var.r + (this.ring_infos.bump + this.ring_infos.round);
	this.ring_infos.bump_var.theta = Math.atan((this.ring_infos.zlength / 2 - this.ring_infos.round) / this.ring_infos.bump_var.r);
	var a = this.c.x - (this.max_zlength -
			this.ring_infos.zlength) / 2,
	b = this.c.y + (this.max_rlength - this.ring_infos.rlength) / 2;
	this.rl_text.attr({
		x : a - this.ring_infos.zlength / 2 - 60,
		y : b - this.ring_infos.bump / 2 + 3
	});
	this.zl_text.attr({
		x : a - 15,
		y : b + this.ring_infos.rlength / 2 + 33
	});
	this.rl_text.node.textContent = (this.ring_infos.rlength + this.ring_infos.bump) / 10 + "mm";
	this.zl_text.node.textContent = this.ring_infos.zlength / 10 + "mm";
	this.left_line.main.attr({
		y1 : b + this.ring_infos.rlength / 2,
		y2 : b - this.ring_infos.rlength / 2 - this.ring_infos.bump,
		x1 : a - this.ring_infos.zlength /
		2 - 16,
		x2 : a - this.ring_infos.zlength / 2 - 16
	});
	this.left_line.bottom.attr({
		y1 : b + this.ring_infos.rlength / 2,
		y2 : b + this.ring_infos.rlength / 2,
		x1 : a - this.ring_infos.zlength / 2 - 18,
		x2 : a - this.ring_infos.zlength / 2 - 14
	});
	this.left_line.head.attr({
		y1 : b - this.ring_infos.rlength / 2 - this.ring_infos.bump,
		y2 : b - this.ring_infos.rlength / 2 - this.ring_infos.bump,
		x1 : a - this.ring_infos.zlength / 2 - 18,
		x2 : a - this.ring_infos.zlength / 2 - 14
	});
	this.bottom_line.main.attr({
		x1 : a - this.ring_infos.zlength / 2,
		x2 : a + this.ring_infos.zlength / 2,
		y1 : b + this.ring_infos.rlength /
		2 + 12,
		y2 : b + this.ring_infos.rlength / 2 + 12
	});
	this.bottom_line.left.attr({
		x1 : a - this.ring_infos.zlength / 2,
		y1 : b + this.ring_infos.rlength / 2 + 10,
		x2 : a - this.ring_infos.zlength / 2,
		y2 : b + this.ring_infos.rlength / 2 + 14
	});
	this.bottom_line.right.attr({
		x1 : a + this.ring_infos.zlength / 2,
		y1 : b + this.ring_infos.rlength / 2 + 10,
		x2 : a + this.ring_infos.zlength / 2,
		y2 : b + this.ring_infos.rlength / 2 + 14
	});
	for (var c = a - this.ring_infos.zlength / 2, d = a + this.ring_infos.zlength / 2, e = b - this.ring_infos.rlength / 2, b = b + this.ring_infos.rlength / 2, f = [{
				x : c + this.ring_infos.round,
				y : b - this.ring_infos.round
			}, {
				x : c + this.ring_infos.round,
				y : e + this.ring_infos.round
			}, {
				x : d - this.ring_infos.round,
				y : e + this.ring_infos.round
			}, {
				x : d - this.ring_infos.round,
				y : b - this.ring_infos.round
			}, {
				x : a,
				y : e - this.ring_infos.bump + this.ring_infos.round
			}
		], g = 0; g < f.length; ++g)
		this.handles[g].transform("t" + f[g].x + "," + f[g].y), this.handles[g].attr({
			r : this.ring_infos.round.toString()
		});
	f = 5;
	this.round_buttons[0].transform("t245," + f);
	this.round_buttons[0].attr({
		r : "3",
		"fill-opacity" : (3 === this.ring_infos.round ? 1 : 0.6).toString()
	});
	for (g = 1; g < this.round_buttons.length; ++g) {
		f += 1 + 2 * (g + 3);
		this.round_buttons[g].transform("t245," + f);
		var h = 1 + g + 2;
		this.round_buttons[g].attr({
			r : h.toString(),
			"fill-opacity" : (h === this.ring_infos.round ? 1 : 0.6).toString()
		})
	}
	a = [{
			x : d,
			y : b - this.ring_infos.round
		}, {
			x : d - this.ring_infos.round,
			y : b
		}, {
			x : c + this.ring_infos.round,
			y : b
		}, {
			x : c,
			y : b - this.ring_infos.round
		}, {
			x : c,
			y : e + this.ring_infos.round
		}, {
			x : c + this.ring_infos.round * (1 - Math.sin(this.ring_infos.bump_var.theta)),
			y : e + this.ring_infos.round * (1 - Math.cos(this.ring_infos.bump_var.theta))
		}, {
			x : d - this.ring_infos.round * (1 - Math.cos(Math.PI / 2 - this.ring_infos.bump_var.theta)),
			y : e + this.ring_infos.round * (1 - Math.sin(Math.PI / 2 - this.ring_infos.bump_var.theta))
		}, {
			x : d,
			y : e + this.ring_infos.round
		}, {
			x : a,
			y : e - this.ring_infos.bump
		}
	];
	c = "A" + this.ring_infos.round.toString() + "," + this.ring_infos.round.toString() + " 0 0,1 ";
	d = "";
	d = 1 <= this.ring_infos.bump ? "A" + this.ring_infos.bump_var.R.toString() + "," + this.ring_infos.bump_var.R.toString() + " 0 0,1 " + a[6].x.toString() + "," + a[6].y.toString() : "L" + a[6].x.toString() +
		"," + a[6].y.toString();
	this.cut_path.attr("d", "M" + a[0].x.toString() + "," + a[0].y.toString() + c + a[1].x.toString() + "," + a[1].y.toString() + "L" + a[2].x.toString() + "," + a[2].y.toString() + c + a[3].x.toString() + "," + a[3].y.toString() + "L" + a[4].x.toString() + "," + a[4].y.toString() + c + a[5].x.toString() + "," + a[5].y.toString() + d + c + a[7].x.toString() + "," + a[7].y.toString() + "Z")
};
var RingMapWidget = function (a) {
	this.slice = Snap(a.svg_tag);
	this.cvs_w = $(a.svg_tag).width();
	this.cvs_h = $(a.svg_tag).height();
	this.cvs_ratio = this.cvs_h / this.cvs_w;
	this.events = {
		map_changed : [],
		element_unselected : [],
		element_selected : []
	};
	this.selected = null;
	this.ring_res = {
		w : a.ring_res.width,
		h : a.ring_res.height
	};
	this.mapbox = null;
	this.buildMapbox(this.ring_res.w, this.ring_res.h);
	var b = this;
	this.bg = this.slice.rect(0, 0, this.cvs_w, this.cvs_h);
	this.bg.attr({
		stroke : "#ffffff",
		strokeWidth : "1px",
		fill : "#ffffff"
	});
	this.bg.mousedown(function (a,
			c, f) {
		b.unselectAll()
	});
	this.ring_place = this.slice.rect(this.mapbox.x_min, this.mapbox.y_min, this.mapbox.getWidth(), this.mapbox.getHeight()).attr({
			fill : "#808080",
			stroke : "none",
			strokeWidth : "0px"
		});
	this.ring_place.mousedown(function (a, c, f) {
		b.unselectAll()
	});
	this.elements = [];
	this.border_res = a.border_res;
	this.corners = {
		up : this.slice.rect(this.mapbox.x_min, this.mapbox.y_min, this.mapbox.getWidth(), 0).attr({
			fill : "none",
			stroke : "#000000",
			opacity : 0.15,
			strokeWidth : "1px"
		}),
		bottom : this.slice.rect(this.mapbox.x_min,
			this.mapbox.y_max - 0, this.mapbox.getHeight(), 0).attr({
			fill : "none",
			stroke : "#000000",
			opacity : 0.15,
			strokeWidth : "1px"
		})
	};
	this.ring_limits = this.slice.rect(this.mapbox.x_min - 1, this.mapbox.y_min - 1, this.mapbox.getWidth() + 1, this.mapbox.getHeight() + 1, 1, 1).attr({
			fill : "none",
			stroke : "#f98d8d",
			strokeWidth : "2px"
		});
	var c = {
		stroke : "#808080",
		strokeWidth : "1px"
	};
	this.ring_rulers = {
		left0 : this.slice.line(0, 0, 0, 0).attr(c),
		mid0 : this.slice.line(0, 0, 0, 0).attr(c),
		right0 : this.slice.line(0, 0, 0, 0).attr(c),
		left1 : this.slice.line(0,
			0, 0, 0).attr(c),
		right1 : this.slice.line(0, 0, 0, 0).attr(c),
		left2 : this.slice.line(0, 0, 0, 0).attr(c),
		midleft2 : this.slice.line(0, 0, 0, 0).attr(c),
		midright2 : this.slice.line(0, 0, 0, 0).attr(c),
		right2 : this.slice.line(0, 0, 0, 0).attr(c),
		up0 : this.slice.line(0, 0, 0, 0).attr(c),
		hmid0 : this.slice.line(0, 0, 0, 0).attr(c),
		bottom0 : this.slice.line(0, 0, 0, 0).attr(c),
		hmidline : this.slice.line(0, 0, 0, 0).attr(c),
		vmidline : this.slice.line(0, 0, 0, 0).attr(c)
	};
	this.rulers_group = this.slice.group(this.ring_rulers.left0, this.ring_rulers.mid0,
			this.ring_rulers.right0, this.ring_rulers.left1, this.ring_rulers.right1, this.ring_rulers.left2, this.ring_rulers.midleft2, this.ring_rulers.midright2, this.ring_rulers.right2, this.ring_rulers.up0, this.ring_rulers.hmid0, this.ring_rulers.bottom0, this.ring_rulers.hmidline, this.ring_rulers.vmidline);
	this.ring_rulers.vmidline.attr({
		display : "none",
		stroke : "#00626b",
		strokeWidth : 1,
		"stroke-dasharray" : "6,6",
		opacity : 0.6
	});
	this.ring_rulers.hmidline.attr({
		display : "none",
		stroke : "#00626b",
		strokeWidth : 1,
		"stroke-dasharray" : "6,6",
		opacity : 0.6
	});
	this.el_handlers_attr = {
		fill : "#00626b",
		stroke : "none"
	};
	this.el_handlers = null;
	void 0 !== a.image && null !== a.image && this.addImage(a.image);
	this.group = this.slice.group(this.bg, this.ring_place, this.corners.up, this.corners.bottom, this.ring_limits, this.rulers_group)
};
RingMapWidget.prototype.getSelected = function () {
	return this.selected
};
RingMapWidget.prototype.addImage = function (a) {
	var b = a.height / a.width,
	c = a.height * a.width,
	d = 1;
	12E4 < c && (d = 12E4 / c);
	c = document.createElement("canvas");
	c.width = Math.round(a.width * d);
	c.height = Math.round(a.height * d);
	d = c.getContext("2d");
	d.drawImage(a, 0, 0, c.width, c.height);
	for (var e = d.getImageData(0, 0, c.width, c.height), f = e.data, g = 0; g < f.length; g += 4) {
		var h = 0.34 * f[g] + 0.5 * f[g + 1] + 0.16 * f[g + 2];
		f[g] = h;
		f[g + 1] = h;
		f[g + 2] = h
	}
	d.putImageData(e, 0, 0);
	c = c.toDataURL();
	d = this.slice.image("", 0, 0, 0, 0);
	this.elements.push(d);
	1 == this.elements.length ?
	d.insertAfter(this.ring_place) : d.insertAfter(this.elements[this.elements.length - 2]);
	this.setSnapImageBind(d);
	b > this.mapbox.getRatio() ? d.attr({
		"xlink:href" : c,
		jweel_original : c,
		x : this.mapbox.x_min + this.mapbox.getWidth() / 2 - a.width * this.mapbox.getHeight() / a.height / 2,
		y : this.mapbox.y_min,
		width : a.width * this.mapbox.getHeight() / a.height,
		height : this.mapbox.getHeight()
	}) : d.attr({
		"xlink:href" : c,
		jweel_original : c,
		x : this.mapbox.x_min,
		y : this.mapbox.y_min + this.mapbox.getHeight() / 2 - a.height * this.mapbox.getWidth() / a.width /
		2,
		width : this.mapbox.getWidth(),
		height : a.height * this.mapbox.getWidth() / a.width
	});
	this.callEventCallbacks({
		name : "map_changed"
	});
	return d
};
RingMapWidget.prototype.addText = function (a, b) {
	var c = this.slice.text(0, 0, a);
	c.attr(b);
	this.elements.push(c);
	1 == this.elements.length ? c.insertAfter(this.ring_place) : c.insertAfter(this.elements[this.elements.length - 2]);
	this.setSnapTextBind(c);
	var d = c.getBBox();
	c.attr({
		x : this.mapbox.x_min + this.mapbox.getWidth() / 2 - d.cx,
		y : this.mapbox.y_min + this.mapbox.getHeight() / 2 - d.cy
	});
	d = d.height / d.width > this.mapbox.getRatio() ? 0.9 * this.mapbox.getHeight() / d.height : 0.9 * this.mapbox.getWidth() / d.width;
	c.attr({
		transform : "Scale(" +
		d + "," + d + ")"
	});
	this.callEventCallbacks({
		name : "map_changed"
	});
	c.attr({
		cursor : "default",
		"font-family" : "Verdana",
		"font-size" : 12,
		"font-weight" : "normal",
		"font-style" : "normal",
		"text-align" : "center"
	});
	return c
};
RingMapWidget.prototype.duplicateImage = function (a) {
	var b = this.slice.image("", 0, 0, 0, 0);
	this.elements.push(b);
	1 == this.elements.length ? b.insertAfter(this.ring_place) : b.insertAfter(this.elements[this.elements.length - 2]);
	b.attr({
		"xlink:href" : a.attr("href"),
		x : parseFloat(a.attr("x")) + 5,
		y : parseFloat(a.attr("y")) + 5,
		width : a.attr("width"),
		height : a.attr("height")
	});
	null !== a.attr("jweel_original") && b.attr({
		jweel_original : a.attr("jweel_original")
	});
	null !== a.attr("jweel_greylevels") && b.attr({
		jweel_greylevels : a.attr("jweel_greylevels")
	});
	this.setSnapImageBind(b);
	this.callEventCallbacks({
		name : "map_changed"
	});
	return b
};
RingMapWidget.prototype.setSnapImageBind = function (a) {
	var b = 0,
	c = 0,
	d = this;
	a.drag(function (e, f, g, h, l) {
		e = {
			x : b + e,
			y : c + f
		};
		f = parseFloat(a.attr("width"));
		g = parseFloat(a.attr("height"));
		h = e.x - d.mapbox.x_min;
		3 >= Math.abs(h) && (e.x = d.mapbox.x_min);
		h = e.y - d.mapbox.y_min;
		3 >= Math.abs(h) && (e.y = d.mapbox.y_min);
		h = e.x + f - d.mapbox.x_max;
		3 >= Math.abs(h) && (e.x = d.mapbox.x_max - f);
		h = e.y + g - d.mapbox.y_max;
		3 >= Math.abs(h) && (e.y = d.mapbox.y_max - g);
		d.moveImage(a, e);
		d.updateElementHandlers(a)
	}, function (e, f, g) {
		b = parseFloat(a.attr("x"));
		c = parseFloat(a.attr("y"));
		d.select(a);
		d.ring_rulers.vmidline.attr({
			display : ""
		});
		d.ring_rulers.hmidline.attr({
			display : ""
		})
	}, function () {
		b === parseFloat(a.attr("x")) && c === parseFloat(a.attr("y")) || d.callEventCallbacks({
			name : "map_changed"
		});
		d.ring_rulers.vmidline.attr({
			display : "none"
		});
		d.ring_rulers.hmidline.attr({
			display : "none"
		})
	});
	a.mousedown(function (b, c, g) {
		d.select(a)
	})
};
RingMapWidget.prototype.setSnapElementAttr = function () {
	var a = null;
	return function (b, c) {
		var d = b.getBBox();
		b.attr(c);
		if (this.selected === b) {
			var e = this;
			clearInterval(a);
			var f = (new Date).getTime();
			a = setInterval(function () {
					if (e.selected === b && 500 > (new Date).getTime() - f) {
						var c = b.getBBox();
						c.x === d.x && c.y === d.y && c.w === d.w && c.h === d.h || e.updateElementHandlers(b)
					} else
						clearInterval(a)
				}, 50);
			this.updateElementHandlers(b)
		} else
			clearInterval(a);
		this.callEventCallbacks({
			name : "map_changed"
		})
	}
}
();
RingMapWidget.prototype.setSnapTextBind = function (a) {
	var b = 0,
	c = 0,
	d = 0,
	e = 0,
	f = this;
	a.drag(function (b, c, l, k, m) {
		f.moveText(a, {
			x : d + b,
			y : e + c
		});
		f.updateElementHandlers(a)
	}, function (g, h, l) {
		g = a.getBBox();
		b = parseFloat(a.attr("x"));
		c = parseFloat(a.attr("y"));
		d = g.cx;
		e = g.cy;
		f.select(a);
		f.ring_rulers.vmidline.attr({
			display : ""
		});
		f.ring_rulers.hmidline.attr({
			display : ""
		})
	}, function () {
		b === parseFloat(a.attr("x")) && c === parseFloat(a.attr("y")) || f.callEventCallbacks({
			name : "map_changed"
		});
		f.ring_rulers.vmidline.attr({
			display : "none"
		});
		f.ring_rulers.hmidline.attr({
			display : "none"
		})
	});
	a.mousedown(function (b, c, d) {
		f.select(a)
	})
};
RingMapWidget.prototype.setRingInfos = function (a, b, c) {
	this.ring_res.w = a;
	this.ring_res.h = b;
	this.border_res = c;
	this.buildMapbox(a, b);
	this.updateRingLimits();
	this.updateRingCorners();
	this.updateRingPlace();
	this.callEventCallbacks({
		name : "map_changed"
	})
};
RingMapWidget.prototype.removeElement = function (a) {
	this.selected === a && this.unselectAll();
	for (var b = 0; b < this.elements.length; ++b)
		if (this.elements[b] === a) {
			for (; b < this.elements.length - 1; ++b)
				this.elements[b] = this.elements[b + 1];
			break
		}
	this.elements.length -= 1;
	a.remove();
	this.callEventCallbacks({
		name : "map_changed"
	})
};
RingMapWidget.prototype.translateImage = function (a, b) {
	var c = {
		x : parseFloat(a.attr("x")) + b.x,
		y : parseFloat(a.attr("y")) + b.y
	};
	this.moveImage(a, c);
	this.callEventCallbacks({
		name : "map_changed"
	})
};
RingMapWidget.prototype.moveImage = function (a, b) {
	var c = parseFloat(a.attr("x")),
	d = parseFloat(a.attr("y")),
	e = parseFloat(a.attr("width")),
	f = parseFloat(a.attr("height"));
	b.x < -e / 2 && (b.x = -e / 2);
	b.y < -f / 2 && (b.y = -f / 2);
	b.x > this.cvs_w - e / 2 && (b.x = this.cvs_w - e / 2);
	b.y > this.cvs_h - f / 2 && (b.y = this.cvs_h - f / 2);
	(void 0 !== b.x && b.x !== c || void 0 !== b.y && b.y !== d) && a.attr(b);
	a === this.selected && this.updateElementHandlers(a)
};
RingMapWidget.prototype.moveText = function (a, b) {
	var c = a.getBBox(),
	d = b.x - c.cx,
	e = b.y - c.cy;
	c.x + d < -c.width / 2 && (d = -c.width / 2 - c.x);
	c.y + e < -c.height / 2 && (e = -c.height / 2 - c.y);
	c.x + d > this.cvs_w - c.width / 2 && (d = this.cvs_w - c.width / 2 - c.x);
	c.y + e > this.cvs_h - c.height / 2 && (e = this.cvs_h - c.height / 2 - c.y);
	if (void 0 !== b.x && b.x !== c.cx || void 0 !== b.y && b.y !== c.cy)
		c = a.attr("transform"), a.attr({
			transform : ""
		}), a.attr({
			x : parseFloat(a.attr("x")) + d,
			y : parseFloat(a.attr("y")) + e
		}), a.attr({
			transform : c
		});
	a === this.selected && this.updateElementHandlers(a)
};
RingMapWidget.prototype.mirrorImage = function (a, b, c) {
	var d = this,
	e = new Image;
	e.src = a.attr("href");
	e.onload = function () {
		var f = document.createElement("canvas");
		f.width = Math.round(e.width);
		f.height = Math.round(e.height);
		var g = f.getContext("2d");
		g.scale("h" === b ? -1 : 1, "v" === b ? -1 : 1);
		g.drawImage(e, "h" === b ? -f.width : 0, "v" === b ? -f.height : 0, f.width, f.height);
		var h = f.toDataURL(),
		l = new Image;
		l.src = a.attr("jweel_original");
		null !== l.src && (l.onload = function () {
			var f = document.createElement("canvas");
			f.width = Math.round(e.width);
			f.height = Math.round(e.height);
			var g = f.getContext("2d");
			g.scale("h" === b ? -1 : 1, "v" === b ? -1 : 1);
			g.drawImage(l, "h" === b ? -f.width : 0, "v" === b ? -f.height : 0, f.width, f.height);
			a.attr({
				href : h,
				jweel_original : f.toDataURL()
			});
			d.callEventCallbacks({
				name : "map_changed"
			});
			c()
		})
	}
};
RingMapWidget.prototype.getAsyncRingMapDataURL = function (a) {
	var b = this.slice.attr("width"),
	c = this.slice.attr("height");
	this.slice.attr({
		width : (2 * this.ring_res.w).toString() + "px",
		height : (2 * this.ring_res.h).toString() + "px"
	});
	var d = "scale(" + (2 * this.ring_res.w / this.mapbox.getWidth()).toString() + "," + (2 * this.ring_res.h / this.mapbox.getHeight()).toString() + ") translate(" + (-this.mapbox.x_min).toString() + "," + (-this.mapbox.y_min).toString() + ")";
	this.group.attr({
		transform : d
	});
	this.ring_limits.attr({
		strokeWidth : "0px"
	});
	var e = document.createElement("canvas");
	e.width = 2 * this.ring_res.w;
	e.height = 2 * this.ring_res.h;
	this.hideCorners();
	this.hideElementHandlers();
	var f = this,
	d = this.slice.outerSVG();
	canvg(e, d, {
		renderCallback : function () {
			var b = e.getContext("2d"),
			c = b.getImageData(0, 0, 2 * f.ring_res.w, 2 * f.ring_res.h);
			e.width = 2 * f.ring_res.w;
			e.height = 2 * f.ring_res.h;
			b.putImageData(c, 0, 0);
			stackBlurCanvasRGBANoID(e, 0, 0, e.width, e.height, 2);
			b = document.createElement("canvas");
			b.width = f.ring_res.w;
			b.height = f.ring_res.h;
			b.getContext("2d").drawImage(e,
				0, 0, f.ring_res.w, f.ring_res.h);
			b = b.toDataURL();
			a(b)
		}
	});
	this.group.attr({
		transform : ""
	});
	this.ring_limits.attr({
		strokeWidth : "2px"
	});
	this.slice.attr({
		width : b,
		height : c
	});
	this.showElementHandlers();
	this.showCorners()
};
RingMapWidget.prototype.getMapSVG = function () {
	for (var a = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="' + this.ring_res.h + '" width="' + this.ring_res.w + '">', b = this.ring_res.w / this.mapbox.getWidth(), c = this.ring_res.h / this.mapbox.getHeight(), d = 0; d < this.elements.length; ++d) {
		var e = this.elements[d];
		switch (e.type) {
		case "image":
			var f = {
				x : e.attr("x"),
				y : e.attr("y"),
				width : e.attr("width"),
				height : e.attr("height")
			};
			e.attr({
				x : (parseFloat(e.attr("x")) - this.mapbox.x_min) * b,
				y : (parseFloat(e.attr("y")) - this.mapbox.y_min) * c,
				width : parseFloat(e.attr("width")) * b,
				height : parseFloat(e.attr("height")) * c
			});
			a += e.outerSVG();
			e.attr(f);
			break;
		case "text":
			var f = {
				x : e.attr("x"),
				y : e.attr("y")
			},
			g = e.attr("transform"),
			h = e.getBBox(),
			l = (h.x - this.mapbox.x_min) * b,
			k = (h.y - this.mapbox.y_min) * c,
			m = h.width * b,
			n = h.height * c;
			e.attr({
				transform : ""
			});
			var p = e.getBBox();
			e.attr({
				x : parseFloat(e.attr("x")) + (l + m / 2) - (h.x + h.width / 2),
				y : parseFloat(e.attr("y")) + (k + n / 2) - (h.y + h.height / 2)
			});
			e.attr({
				transform : "Scale(" + m /
				p.width + "," + n / p.height + ")"
			});
			a += e.outerSVG();
			e.attr({
				transform : ""
			});
			e.attr(f);
			e.attr({
				transform : g
			});
			break;
		default:
			console.error("Error : unmanaged element type")
		}
	}
	return a + "</svg>"
};
RingMapWidget.prototype.setMapSVG = function (a) {
	var b = Snap.parse(a).selectAll(["image", "text"]).items;
	a = Snap.parse("<svg>" + a + "</svg>").select("svg");
	var c = parseFloat(a.attr("height").replace("px", ""));
	a = parseFloat(a.attr("width").replace("px", "")) / this.mapbox.getWidth();
	for (c = (this.mapbox.getHeight() - c / a) / 2; 0 < this.elements.length; )
		this.removeElement(this.elements[0]);
	for (var d = 0, e = [], f = [], g = 0; g < b.length; ++g)
		switch (b[g].type) {
		case "image":
			b[g].attr("href");
			var h = this.slice.image("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==",
					parseFloat(b[g].attr("x")) / a + this.mapbox.x_min, parseFloat(b[g].attr("y")) / a + this.mapbox.y_min + c, b[g].attr("width") / a, b[g].attr("height") / a);
			this.elements.push(h);
			1 == this.elements.length ? h.insertAfter(this.ring_place) : h.insertAfter(this.elements[this.elements.length - 2]);
			this.setSnapImageBind(h);
			null !== b[g].attr("jweel_original") && h.attr({
				jweel_original : b[g].attr("jweel_original")
			});
			null !== b[g].attr("jweel_greylevels") && h.attr({
				jweel_greylevels : b[g].attr("jweel_greylevels")
			});
			f.push(h);
			var l = this,
			k =
				new Image;
			k.src = h.attr("jweel_original");
			k.onload = function () {
				d++;
				if (d === b.length) {
					for (var a = 0; a < f.length; ++a) {
						var c = f[a],
						g = new ImageGreyLevelMapper;
						g.setImg(e[a]);
						g.clearAllMapping();
						null === c.attr("jweel_greylevels") ? g.autoMappingFromImg() : g.loadMapFromString(c.attr("jweel_greylevels"));
						l.setSnapElementAttr(c, {
							href : g.getProcessedDataURL()
						})
					}
					l.callEventCallbacks({
						name : "map_changed"
					})
				}
			};
			e.push(k);
			break;
		case "text":
			h = b[g];
			this.elements.push(h);
			1 == this.elements.length ? h.insertAfter(this.ring_place) : h.insertAfter(this.elements[this.elements.length -
					2]);
			var m = h.getBBox(),
			k = m.x / a + this.mapbox.x_min,
			n = m.y / a + this.mapbox.y_min + c,
			p = m.width / a,
			m = m.height / a;
			h.attr({
				transform : ""
			});
			var q = h.getBBox();
			h.attr({
				x : parseFloat(b[g].attr("x")) + (k + p / 2) - (q.x + q.width / 2),
				y : parseFloat(b[g].attr("y")) + (n + m / 2) - (q.y + q.height / 2)
			});
			h.attr({
				transform : "Scale(" + p / q.width + "," + m / q.height + ")"
			});
			this.setSnapTextBind(h);
			d++;
			break;
		default:
			console.error("Error : unmanaged svg element type")
		}
	d === this.elements.length && this.callEventCallbacks({
		name : "map_changed"
	})
};
RingMapWidget.prototype.addEventCallback = function (a, b) {
	this.events[b].push(a)
};
RingMapWidget.prototype.removeEventCallback = function (a, b) {
	for (var c = 0; c < this.events[b].length; ++c)
		if (a === this.events[b][c]) {
			for (var d = c + 1; d < this.events[b].length; ++d)
				this.events[b][d - 1] = this.events[b][d];
			this.events[b].length -= 1
		}
};
RingMapWidget.prototype.callEventCallbacks = function (a) {
	for (var b = 0; b < this.events[a.name].length; ++b)
		this.events[a.name][b](a)
};
RingMapWidget.prototype.buildMapbox = function (a, b) {
	var c = b / a,
	d = Math.round(this.cvs_h / 2 - c * (this.cvs_w - 4) / 2);
	this.mapbox = {
		x_min : 4,
		x_max : this.cvs_w - 4,
		y_min : d,
		y_max : d + c * (this.cvs_w - 4),
		getWidth : function () {
			return this.x_max - this.x_min
		},
		getHeight : function () {
			return this.y_max - this.y_min
		},
		getRatio : function () {
			return this.getHeight() / this.getWidth()
		}
	}
};
RingMapWidget.prototype.updateRingLimits = function () {
	this.ring_limits.attr({
		x : this.mapbox.x_min - 1,
		y : this.mapbox.y_min - 1,
		width : this.mapbox.getWidth() + 1,
		height : this.mapbox.getHeight() + 1
	});
	this.ring_rulers.left0.attr({
		x1 : this.mapbox.x_min,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min,
		y2 : this.mapbox.y_min - 10
	});
	this.ring_rulers.mid0.attr({
		x1 : this.mapbox.x_min + this.mapbox.getWidth() / 2,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min + this.mapbox.getWidth() / 2,
		y2 : this.mapbox.y_min - 10
	});
	this.ring_rulers.right0.attr({
		x1 : this.mapbox.x_min +
		this.mapbox.getWidth(),
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min + this.mapbox.getWidth(),
		y2 : this.mapbox.y_min - 10
	});
	this.ring_rulers.left1.attr({
		x1 : this.mapbox.x_min + this.mapbox.getWidth() / 4,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min + this.mapbox.getWidth() / 4,
		y2 : this.mapbox.y_min - 8
	});
	this.ring_rulers.right1.attr({
		x1 : this.mapbox.x_min + 3 * this.mapbox.getWidth() / 4,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min + 3 * this.mapbox.getWidth() / 4,
		y2 : this.mapbox.y_min - 8
	});
	this.ring_rulers.left2.attr({
		x1 : this.mapbox.x_min +
		this.mapbox.getWidth() / 8,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min + this.mapbox.getWidth() / 8,
		y2 : this.mapbox.y_min - 6
	});
	this.ring_rulers.midleft2.attr({
		x1 : this.mapbox.x_min + 3 * this.mapbox.getWidth() / 8,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min + 3 * this.mapbox.getWidth() / 8,
		y2 : this.mapbox.y_min - 6
	});
	this.ring_rulers.midright2.attr({
		x1 : this.mapbox.x_min + 5 * this.mapbox.getWidth() / 8,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min + 5 * this.mapbox.getWidth() / 8,
		y2 : this.mapbox.y_min - 6
	});
	this.ring_rulers.right2.attr({
		x1 : this.mapbox.x_min +
		7 * this.mapbox.getWidth() / 8,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min + 7 * this.mapbox.getWidth() / 8,
		y2 : this.mapbox.y_min - 6
	});
	this.ring_rulers.up0.attr({
		x1 : this.mapbox.x_min,
		y1 : this.mapbox.y_min,
		x2 : this.mapbox.x_min - 10,
		y2 : this.mapbox.y_min
	});
	this.ring_rulers.hmid0.attr({
		x1 : this.mapbox.x_min,
		y1 : this.mapbox.y_min + this.mapbox.getHeight() / 2,
		x2 : this.mapbox.x_min - 8,
		y2 : this.mapbox.y_min + this.mapbox.getHeight() / 2
	});
	this.ring_rulers.bottom0.attr({
		x1 : this.mapbox.x_min,
		y1 : this.mapbox.y_min + this.mapbox.getHeight(),
		x2 : this.mapbox.x_min - 10,
		y2 : this.mapbox.y_min + this.mapbox.getHeight()
	});
	this.ring_rulers.hmidline.attr({
		x1 : 0,
		y1 : this.mapbox.y_min + this.mapbox.getHeight() / 2,
		x2 : this.cvs_w,
		y2 : this.mapbox.y_min + this.mapbox.getHeight() / 2
	});
	this.ring_rulers.vmidline.attr({
		x1 : this.mapbox.x_min + this.mapbox.getWidth() / 2,
		y1 : 0,
		x2 : this.mapbox.x_min + this.mapbox.getWidth() / 2,
		y2 : this.cvs_h
	})
};
RingMapWidget.prototype.updateRingCorners = function () {
	var a = Math.round(this.border_res / this.ring_res.h * this.mapbox.getHeight());
	this.corners.up.attr({
		x : this.mapbox.x_min,
		y : this.mapbox.y_min,
		width : this.mapbox.getWidth(),
		height : a
	});
	this.corners.bottom.attr({
		x : this.mapbox.x_min,
		y : this.mapbox.y_max - a,
		width : this.mapbox.getWidth(),
		height : a
	})
};
RingMapWidget.prototype.updateRingPlace = function () {
	this.ring_place.attr({
		x : this.mapbox.x_min,
		y : this.mapbox.y_min,
		width : this.mapbox.getWidth(),
		height : this.mapbox.getHeight()
	})
};
RingMapWidget.prototype.buildElementHandlers = function (a) {
	this.removeElementHandlers();
	this.el_handlers = {
		box : this.slice.rect(0, 0, 1, 1).attr({
			fill : "none",
			stroke : "#00626b",
			strokeWidth : 1,
			"stroke-dasharray" : "6,6"
		}),
		ul : this.slice.circle(0, 0, 4).attr(this.el_handlers_attr),
		bl : this.slice.circle(0, 0, 4).attr(this.el_handlers_attr),
		ur : this.slice.circle(0, 0, 4).attr(this.el_handlers_attr),
		br : this.slice.circle(0, 0, 4).attr(this.el_handlers_attr),
		umid : this.slice.circle(0, 0, 4).attr(this.el_handlers_attr),
		lmid : this.slice.circle(0,
			0, 4).attr(this.el_handlers_attr),
		bmid : this.slice.circle(0, 0, 4).attr(this.el_handlers_attr),
		rmid : this.slice.circle(0, 0, 4).attr(this.el_handlers_attr),
		del : this.slice.group(this.slice.circle(0, 0, 4).attr({
				fill : "#cc0000",
				stroke : "none"
			}), this.slice.line(-3, 3, 3, -3).attr({
				stroke : "#ffffff",
				strokeWidth : "1px"
			}), this.slice.line(-3, -3, 3, 3).attr({
				stroke : "#ffffff",
				strokeWidth : "1px"
			}))
	};
	var b = Object.keys(this.el_handlers),
	b = b.slice(1, b.length - 1),
	c = this,
	d = {
		s : {},
		signs : {
			ul : {
				x : 1,
				y : 1,
				w : -1,
				h : -1
			},
			bl : {
				x : 1,
				y : 0,
				w : -1,
				h : 1
			},
			ur : {
				x : 0,
				y : 1,
				w : 1,
				h : -1
			},
			br : {
				x : 0,
				y : 0,
				w : 1,
				h : 1
			},
			umid : {
				x : 0,
				y : 1,
				w : 0,
				h : -1
			},
			lmid : {
				x : 1,
				y : 0,
				w : -1,
				h : 0
			},
			bmid : {
				x : 0,
				y : 0,
				w : 0,
				h : 1
			},
			rmid : {
				x : 0,
				y : 0,
				w : 1,
				h : 0
			}
		},
		name : {}

	};
	switch (a.type) {
	case "image":
		for (var e = 0; e < b.length; ++e)
			d.s[this.el_handlers[b[e]].id] = d.signs[b[e]], d.name[this.el_handlers[b[e]].id] = b[e], this.el_handlers[b[e]].drag(function (b, e, h, l, k) {
				h = d.name[this.id];
				l = b;
				k = e;
				if ("ul" == h || "br" == h)
					b > d.ratio * e ? l = e * d.ratio : k = b / d.ratio;
				else if ("bl" == h || "ur" == h)
					b > -d.ratio * e ? l = -e * d.ratio : k = -b / d.ratio;
				b = {
					x : d.o_x + d.s[this.id].x *
					l,
					y : d.o_y + d.s[this.id].y * k,
					width : Math.max(d.o_w + d.s[this.id].w * l, 3),
					height : Math.max(d.o_h + d.s[this.id].h * k, 3)
				};
				e = b.x - c.mapbox.x_min;
				3 >= Math.abs(e) && (b.x = c.mapbox.x_min, b.width += e);
				e = b.y - c.mapbox.y_min;
				3 >= Math.abs(e) && (b.y = c.mapbox.y_min, b.height += e);
				e = b.x + b.width - c.mapbox.x_max;
				3 >= Math.abs(e) && (b.width -= e);
				e = b.y + b.height - c.mapbox.y_max;
				3 >= Math.abs(e) && (b.height -= e);
				a.attr(b);
				c.updateElementHandlers(a)
			}, function (b, c, e) {
				d.o_x = parseFloat(a.attr("x"));
				d.o_y = parseFloat(a.attr("y"));
				d.o_w = parseFloat(a.attr("width"));
				d.o_h = parseFloat(a.attr("height"));
				d.ratio = d.o_w / d.o_h
			}, function () {
				c.callEventCallbacks({
					name : "map_changed"
				})
			});
		this.el_handlers.del.mousedown(function (a, b, d) {
			c.removeElement(c.selected)
		});
		break;
	case "text":
		for (e = 0; e < b.length; ++e)
			d.s[this.el_handlers[b[e]].id] = d.signs[b[e]], d.name[this.el_handlers[b[e]].id] = b[e], this.el_handlers[b[e]].drag(function (b, e, h, l, k) {
				k = d.name[this.id];
				l = b;
				h = e;
				if ("ul" == k || "br" == k)
					b > d.ratio * e ? l = e * d.ratio : h = b / d.ratio;
				else if ("bl" == k || "ur" == k)
					b > -d.ratio * e ? l = -e * d.ratio : h = -b / d.ratio;
				b = d.o_text_bbox.x + d.s[this.id].x * l;
				e = d.o_text_bbox.y + d.s[this.id].y * h;
				l = Math.max(d.o_text_bbox.w + d.s[this.id].w * l, 3);
				h = Math.max(d.o_text_bbox.h + d.s[this.id].h * h, 3);
				a.attr({
					x : d.o_x + (b + l / 2) - d.o_text_bbox.cx,
					y : d.o_y + (e + h / 2) - d.o_text_bbox.cy,
					transform : "Scale(" + l / d.o_text_bbox2.width + "," + h / d.o_text_bbox2.height + ")"
				});
				c.updateElementHandlers(a)
			}, function (b, c, e) {
				d.o_text_bbox = a.getBBox();
				d.o_x = parseFloat(a.attr("x"));
				d.o_y = parseFloat(a.attr("y"));
				d.ratio = d.o_text_bbox.w / d.o_text_bbox.h;
				b = a.attr("transform");
				a.attr({
					transform : ""
				});
				d.o_text_bbox2 = a.getBBox();
				a.attr({
					transform : b
				})
			}, function () {
				c.callEventCallbacks({
					name : "map_changed"
				})
			});
		this.el_handlers.del.mousedown(function (a, b, d) {
			c.removeElement(c.selected)
		});
		break;
	default:
		console.error("ERROR : unknown snap element type")
	}
	this.updateElementHandlers(a)
};
RingMapWidget.prototype.removeElementHandlers = function () {
	if (null !== this.el_handlers) {
		for (var a = Object.keys(this.el_handlers), b = 0; b < a.length; ++b)
			this.el_handlers[a[b]].remove();
		this.el_handlers = null
	}
};
RingMapWidget.prototype.unselectAll = function () {
	if (null !== this.selected) {
		var a = {
			name : "element_unselected",
			el : this.selected
		};
		this.selected = null;
		this.removeElementHandlers();
		this.callEventCallbacks(a)
	}
};
RingMapWidget.prototype.select = function (a) {
	this.selected !== a && (null !== this.selected && this.unselectAll(), this.selected = a, this.callEventCallbacks({
			name : "element_selected",
			el : this.selected
		}), this.buildElementHandlers(a))
};
RingMapWidget.prototype.updateElementHandlers = function (a) {
	switch (a.type) {
	case "image":
		this.el_handlers.ul.attr({
			cx : parseFloat(a.attr("x")),
			cy : parseFloat(a.attr("y"))
		});
		this.el_handlers.bl.attr({
			cx : parseFloat(a.attr("x")),
			cy : parseFloat(a.attr("y")) + parseFloat(a.attr("height"))
		});
		this.el_handlers.br.attr({
			cx : parseFloat(a.attr("x")) + parseFloat(a.attr("width")),
			cy : parseFloat(a.attr("y")) + parseFloat(a.attr("height"))
		});
		this.el_handlers.ur.attr({
			cx : parseFloat(a.attr("x")) + parseFloat(a.attr("width")),
			cy : parseFloat(a.attr("y"))
		});
		this.el_handlers.box.attr({
			x : parseFloat(a.attr("x")),
			y : parseFloat(a.attr("y")),
			width : parseFloat(a.attr("width")),
			height : parseFloat(a.attr("height"))
		});
		this.el_handlers.umid.attr({
			cx : parseFloat(a.attr("x")) + parseFloat(a.attr("width")) / 2,
			cy : parseFloat(a.attr("y"))
		});
		this.el_handlers.lmid.attr({
			cx : parseFloat(a.attr("x")),
			cy : parseFloat(a.attr("y")) + parseFloat(a.attr("height")) / 2
		});
		this.el_handlers.bmid.attr({
			cx : parseFloat(a.attr("x")) + parseFloat(a.attr("width")) / 2,
			cy : parseFloat(a.attr("y")) + parseFloat(a.attr("height"))
		});
		this.el_handlers.rmid.attr({
			cx : parseFloat(a.attr("x")) + parseFloat(a.attr("width")),
			cy : parseFloat(a.attr("y")) + parseFloat(a.attr("height")) / 2
		});
		a = " translate(" + this.el_handlers.ur.attr("cx") + "," + (parseFloat(this.el_handlers.ur.attr("cy")) - 3 - 2 * parseFloat(this.el_handlers.ur.attr("r"))).toString() + ")";
		this.el_handlers.del.attr({
			transform : a
		});
		break;
	case "text":
		a = a.getBBox();
		this.el_handlers.ul.attr({
			cx : a.x,
			cy : a.y
		});
		this.el_handlers.bl.attr({
			cx : a.x,
			cy : a.y + a.height
		});
		this.el_handlers.br.attr({
			cx : a.x + a.width,
			cy : a.y + a.height
		});
		this.el_handlers.ur.attr({
			cx : a.x + a.width,
			cy : a.y
		});
		this.el_handlers.box.attr({
			x : a.x,
			y : a.y,
			width : a.width,
			height : a.height
		});
		this.el_handlers.umid.attr({
			cx : a.x + a.width / 2,
			cy : a.y
		});
		this.el_handlers.lmid.attr({
			cx : a.x,
			cy : a.y + a.height / 2
		});
		this.el_handlers.bmid.attr({
			cx : a.x + a.width / 2,
			cy : a.y + a.height
		});
		this.el_handlers.rmid.attr({
			cx : a.x + a.width,
			cy : a.y + a.height / 2
		});
		a = " translate(" + this.el_handlers.ur.attr("cx") + "," + (parseFloat(this.el_handlers.ur.attr("cy")) - 3 - 2 * parseFloat(this.el_handlers.ur.attr("r"))).toString() +
			")";
		this.el_handlers.del.attr({
			transform : a
		});
		break;
	default:
		console.error("snap element type cannot be processed")
	}
};
RingMapWidget.prototype.hideElementHandlers = function () {
	if (null !== this.el_handlers)
		for (var a = Object.keys(this.el_handlers), b = 0; b < a.length; ++b)
			this.el_handlers[a[b]].attr({
				display : "none"
			})
};
RingMapWidget.prototype.showElementHandlers = function () {
	if (null !== this.el_handlers)
		for (var a = Object.keys(this.el_handlers), b = 0; b < a.length; ++b)
			this.el_handlers[a[b]].attr({
				display : ""
			})
};
RingMapWidget.prototype.hideCorners = function () {
	this.corners.up.attr({
		display : "none"
	});
	this.corners.bottom.attr({
		display : "none"
	})
};
RingMapWidget.prototype.showCorners = function () {
	this.corners.up.attr({
		display : ""
	});
	this.corners.bottom.attr({
		display : ""
	})
};
site.PendantTool = function (a, b, c) {
	site.LoaderNode.call(this, a, b, c);
	this.isChainLoaded = !1
};
site.PendantTool.prototype = Object.create(site.LoaderNode.prototype);
site.PendantTool.prototype.constructor = site.PendantTool;
site.PendantTool.prototype.getSize = function () {
	return this.toolInfo.size
};
site.PendantTool.prototype.setSize = function (a) {
	this.toolInfo.size = a
};
site.PendantTool.prototype.specializeTransformer = function () {
	site.LoaderNode.prototype.specializeTransformer.call(this);
	Transformer.jweel = {
		showHand : function () {},
		hideHand : function () {}

	};
	Transformer.pendant = {}

};
site.PendantTool.prototype.loadChain = function () {
	var a = this;
	(new skim.utils.OBJToTHREELoader(THREE.DefaultLoadingManager, 10)).load(window.media + "/static/meshes/Chain_Obj/Chain.obj", function (b) {
		b = new THREE.Mesh(b.geometry, skim.instances.modeler.sceneManager.surface_material);
		skim.instances.modeler.sceneManager.addNeutralMesh("Chain", b);
		skim.instances.modeler.sceneManager.setNeutralMeshVisible("Chain", !1);
		a.updateChain();
		skim.instances.modeler.sceneManager.neutralMeshUpdated("Chain");
		a.isChainLoaded =
			!0
	}, function () {})
};
site.PendantTool.prototype.updateChain = function () {
	console.error("PendantTool - updateChain: this pendant tool should be able to place the chain properly!")
};
site.PendantTool.prototype.setChainParams = function (a) {
	var b = skim.instances.modeler.sceneManager.getNeutralMesh("Chain");
	void 0 !== b && (a.rotation && b.rotation.copy(a.rotation), a.position && b.position.copy(a.position), a.scale && b.scale.copy(a.scale))
};
site.PendantTool.prototype.showChain = function () {
	this.isChainLoaded && skim.instances.modeler.sceneManager.setNeutralMeshVisible("Chain", !0)
};
site.PendantTool.prototype.hideChain = function () {
	this.isChainLoaded && skim.instances.modeler.sceneManager.setNeutralMeshVisible("Chain", !1)
};
site.PendantTool.prototype.getloadedEnvMap = function () {
	var a = this;
	return function () {
		a.isChainLoaded && skim.instances.modeler.sceneManager.setNeutralMeshMaterial("Chain", skim.instances.modeler.sceneManager.surface_material)
	}
};
site.PendantTool.prototype.utilsInit = function () {
	site.LoaderNode.prototype.utilsInit.call(this);
	this.loadChain()
};
site.PendantTool.prototype.computeChain = function () {
	var a = 2 / 3,
	b = function (b, c, d, e, f) {
		for (var g = 0, h = []; 12 > g; g++) {
			var s = 2 * g * Math.PI / 12,
			t = e * a * Math.cos(s),
			s = e * Math.sin(s),
			t = new skim.engine.VertexDef(new THREE.Vector3(b.x + c.x * t + d.x * s, b.y + c.y * t + d.y * s, b.z + c.z * t + d.z * s), f);
			h.push(t);
			t.commit();
			t.name = "anchor" + g
		}
		g = 0;
		for (b = h.length - 1; g < h.length; g++, b = g - 1)
			(new skim.engine.SegmentDef([h[g], h[b]])).commit()
	},
	c = function (a) {
		f = 0 === a % 2 ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(0.1 * -a, 1, 0);
		g = new THREE.Vector3(1, 0.1 *
				a, 0);
		g.normalize();
		f.normalize();
		a *= d;
		a = e.clone().subVectors(new THREE.Vector3(a, 0.003 * a * a, 0), e).normalize();
		var c = e.clone().addVectors(e, a.clone().multiplyScalar(d));
		b(c, f, a, 12, 2);
		e = c
	},
	d = 20,
	e = new THREE.Vector3,
	f = null,
	g = null;
	b(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(1, 0, 0), 12, 2);
	for (var h = 1; 26 > h; h++)
		c(h);
	e = new THREE.Vector3;
	for (h = -1; -26 < h; h--)
		c(h);
	skim.engine.update_skeleton();
	skim.engine.update_parametrics();
	skim.engine.update_blobtree()
};
site.StylePendantTool = function (a, b, c) {
	site.PendantTool.call(this, a, b, c);
	this.toolType = toolNames.stylependant;
	this.defaultParams.jsonInfo = JSON.parse('{"primitives": {"rings": [], "segments": [{"v0": 0, "v1": 19, "vt": 0}, {"v0": 1, "v1": 0, "vt": 0}, {"v0": 2, "v1": 1, "vt": 0}, {"v0": 3, "v1": 2, "vt": 0}, {"v0": 4, "v1": 3, "vt": 0}, {"v0": 5, "v1": 4, "vt": 0}, {"v0": 6, "v1": 5, "vt": 0}, {"v0": 7, "v1": 6, "vt": 0}, {"v0": 8, "v1": 7, "vt": 0}, {"v0": 9, "v1": 8, "vt": 0}, {"v0": 10, "v1": 9, "vt": 0}, {"v0": 11, "v1": 10, "vt": 0}, {"v0": 12, "v1": 11, "vt": 0}, {"v0": 13, "v1": 12, "vt": 0}, {"v0": 14, "v1": 13, "vt": 0}, {"v0": 15, "v1": 14, "vt": 0}, {"v0": 16, "v1": 15, "vt": 0}, {"v0": 17, "v1": 16, "vt": 0}, {"v0": 18, "v1": 17, "vt": 0}, {"v0": 19, "v1": 18, "vt": 0}, {"v0": 15, "v1": 21, "vt": 0}, {"v0": 15, "v1": 22, "vt": 0}, {"v0": 20, "v1": 23, "vt": 0}], "triangles": []}, "relations": {"p": {"spsa": [{"a": "x", "s0": 21, "s1": 22}]}, "r": {"rpsa": []}, "v": {"vpsa": [{"a": "x", "v0": 15, "v1": 20}, {"a": "x", "v0": 22, "v1": 23}]}}, "version": "1", "vertices": [{"n": "anchor0", "t": 6.5, "vt": 0, "x": 0.0, "y": 190.76643, "z": 14.5}, {"n": "anchor1", "t": 6.5, "vt": 0, "x": 0.0, "y": 195.24718, "z": 13.79032}, {"n": "anchor2", "t": 6.5, "vt": 0, "x": 0.0, "y": 199.28932, "z": 11.73075}, {"n": "anchor3", "t": 6.5, "vt": 0, "x": 0.0, "y": 202.49718, "z": 8.52289}, {"n": "anchor4", "t": 6.5, "vt": 0, "x": 0.0, "y": 204.55675, "z": 4.48075}, {"n": "anchor5", "t": 6.5, "vt": 0, "x": 0.0, "y": 205.26643, "z": 0.0}, {"n": "anchor6", "t": 6.5, "vt": 0, "x": 0.0, "y": 204.55675, "z": -4.48075}, {"n": "anchor7", "t": 6.5, "vt": 0, "x": 0.0, "y": 202.49718, "z": -8.52289}, {"n": "anchor8", "t": 6.5, "vt": 0, "x": 0.0, "y": 199.28932, "z": -11.73075}, {"n": "anchor9", "t": 6.5, "vt": 0, "x": 0.0, "y": 195.24718, "z": -13.79032}, {"n": "anchor10", "t": 6.5, "vt": 0, "x": 0.0, "y": 190.76643, "z": -14.5}, {"n": "anchor11", "t": 6.5, "vt": 0, "x": 0.0, "y": 178.86927, "z": -13.79032}, {"n": "anchor12", "t": 6.5, "vt": 0, "x": 0.0, "y": 168.1367, "z": -11.73075}, {"n": "anchor13", "t": 6.5, "vt": 0, "x": 0.0, "y": 159.61927, "z": -8.52289}, {"n": "anchor14", "t": 6.5, "vt": 0, "x": 0.0, "y": 154.15075, "z": -4.48075}, {"n": "anchor15", "t": 6.5, "vt": 0, "x": 0.0, "y": 152.26643, "z": 0.0}, {"n": "anchor16", "t": 6.5, "vt": 0, "x": 0.0, "y": 154.15075, "z": 4.48075}, {"n": "anchor17", "t": 6.5, "vt": 0, "x": 0.0, "y": 159.61927, "z": 8.52289}, {"n": "anchor18", "t": 6.5, "vt": 0, "x": 0.0, "y": 168.1367, "z": 11.73075}, {"n": "anchor19", "t": 6.5, "vt": 0, "x": 0.0, "y": 178.86927, "z": 13.79032}, {"n": "v0", "t": 6.5, "vt": 0, "x": 0.0, "y": 152.26643, "z": 0.0}, {"n": "v1", "t": 24.19, "vt": 0, "x": 0.0, "y": 0.0, "z": 0.0}, {"n": "v2", "t": 8.15, "vt": 0, "x": 78.13099, "y": 83.38241, "z": 0.0}, {"n": "v3", "t": 8.15, "vt": 0, "x": -78.13099, "y": 83.38241, "z": 0.0}]}');
	this.defaultParams.toolInfo = {
		size : 1,
		symX : !0,
		symY : !1,
		symZ : !1
	};
	this.defaultParams.init.initCamPos = {
		rotNode : {
			px : 0,
			py : 0,
			pz : 0,
			rx : -0.8,
			ry : -0.7,
			rz : -0.5
		},
		distToTarget : 1E3
	};
	this.defaultParams.anchorParams = {
		resolution : 4,
		innerRadius : 10,
		thickness : 5,
		yCenterPos : 250,
		vertices : null,
		XPlane : !0,
		zLimit : 25,
		minThicknessLimit : 6.5,
		innerAnchorFunctor : null,
		isPresent : !0
	};
	this.anchorParams = {};
	$.extend(this.anchorParams, this.defaultParams.anchorParams);
	this.extractor = new site.Geometry.RadialCoordExtractor(this.anchorParams.innerRadius +
			this.anchorParams.thickness, this.anchorParams.yCenterPos, this.anchorParams.XPlane);
	this.setDefaultParams();
	this.gridVisu = this.cylinderVisu = null;
	this.storageKey = "skimlab-code#stylependanttool"
};
site.StylePendantTool.prototype = Object.create(site.PendantTool.prototype);
site.StylePendantTool.prototype.constructor = site.StylePendantTool;
site.StylePendantTool.prototype.loadFiles = function () {
	this.mode === site.toolModes.edit && this.filesToLoad.push("/static/js/site/tools/pendant/stylependant/SMDef.js");
	site.PendantTool.prototype.loadFiles.call(this)
};
site.StylePendantTool.prototype.loadObject = function () {
	this.anchorParams.innerAnchorFunctor && this.anchorParams.innerAnchorFunctor.destroy();
	if (this.jsonInfo) {
		skim.engine.loadJSON(this.jsonInfo)
	}
	this.loadAnchor();
	skim.engine.setSymmetries({
		x : this.toolInfo.symX,
		y : this.toolInfo.symY,
		z : this.toolInfo.symZ,
		rad : !1
	});
	a = this.cloneToolInfo();
	this.addPrimInfo(a);
	this.pageInterface.updateToolMenu(a);
	skim.instances.modeler.setAccuracyLevel(3)
};
site.StylePendantTool.prototype.utilsInit = function () {
	site.PendantTool.prototype.utilsInit.call(this);
	this.cylinderVisu = new site.ForbiddenCylinder(this.anchorParams);
	this.gridVisu = new site.PlaneGrid;
	this.computeWarning = new site.JweelComputationWarning(this);
	this.mode === site.toolModes.edit ? (this.progress = new site.JweelProgress3D({
				rotation : new THREE.Euler(-Math.PI / 2, 0, 0),
				position : new THREE.Vector3(0, -300, 0),
				scale : new THREE.Vector3(200, 200, 1)
			}), this.cylinderVisu.setSystemAllows(!0), this.cylinderVisu.show(),
		this.gridVisu.show()) : (this.progress = new site.JweelProgress2D(this.canvas), this.cylinderVisu.setSystemAllows(!1), this.cylinderVisu.hide(), this.gridVisu.hide())
};
site.StylePendantTool.prototype.buildInitParams = function () {
	site.PendantTool.prototype.buildInitParams.call(this);
	this.mode === site.toolModes.edit && (this.initParams.statemachine = StylePendantSM);
	this.thickLimitMin = 3;
	this.thickLimitMax = 150;
	this.initParams.engine = {
		adjust_functors : {
			print_min_thick : new skim.engine.adjustAttrFunctors.VLimitMin(this.thickLimitMin),
			vert_max_thick : new skim.engine.adjustAttrFunctors.VLimitMax(this.thickLimitMax),
			sphere_pos_limit : new skim.engine.adjustAttrFunctors.SpherePosLimit(600)
		}
	};
	this.initParams.pageInterface.loadedEnvMap = this.getloadedEnvMap()
};
site.StylePendantTool.prototype.getSurfaceHidden = function () {
	var a = this;
	return function () {
		a.hideChain();
		a.progress.show();
		a.mode === site.toolModes.edit && (a.cylinderVisu.show(), a.gridVisu.show());
		a.pageInterface.surfaceHidden()
	}
};
site.StylePendantTool.prototype.getSurfaceShown = function () {
	var a = this;
	return function () {
		a.showChain();
		a.progress.hide();
		a.cylinderVisu.hide();
		a.gridVisu.hide();
		a.pageInterface.surfaceShown()
	}
};
site.StylePendantTool.prototype.updateChain = function () {
	var a = 12 * (2 / 3) + 2,
	a = Math.sqrt(0.75) * this.anchorParams.innerRadius / a;
	this.setChainParams({
		position : new THREE.Vector3(0, this.anchorParams.yCenterPos + this.anchorParams.innerRadius / 2, 0),
		scale : new THREE.Vector3(a, a, a)
	})
};
site.StylePendantTool.prototype.showChain = function () {
	this.isChainLoaded && this.anchorParams.isPresent && skim.instances.modeler.sceneManager.setNeutralMeshVisible("Chain", !0)
};
site.StylePendantTool.prototype.delAnchor = function () {
	if (this.anchorParams.isPresent || this.anchorParams.vertices && 0 < this.anchorParams.vertices.length)
		for (var a = 0; a < this.anchorParams.vertices.length; a++)
			this.anchorParams.vertices[a].destroy();
	this.anchorParams.vertices = [];
	this.anchorParams.innerAnchorFunctor && this.anchorParams.innerAnchorFunctor.destroy();
	this.anchorParams.isPresent = !1;
	this.cylinderVisu.setSystemAllows(!1);
	this.cylinderVisu.hide()
};
site.StylePendantTool.prototype.addAnchor = function () {
	this.anchorParams.vertices = [];
	for (var a = 0; a < 4 * (this.anchorParams.resolution + 1); a++) {
		var b = new skim.engine.VertexDef(new THREE.Vector3, this.anchorParams.thickness);
		this.anchorParams.vertices.push(b);
		b.commit();
		b.setName("anchor" + a);
		b.removeAdjustAttrFunctor(b.getAdjustAttrFunctorByClass(skim.engine.adjustAttrFunctors.InnerAnchorLimit)[0])
	}
	a = 0;
	for (b = this.anchorParams.vertices.length - 1; a < this.anchorParams.vertices.length; a++, b = a - 1)
		(new skim.engine.SegmentDef([this.anchorParams.vertices[a],
					this.anchorParams.vertices[b]])).commit();
	this.updateAnchor();
	skim.engine.update_skeleton();
	skim.engine.update_parametrics();
	skim.engine.update_blobtree()
};
site.StylePendantTool.prototype.updateAnchor = function () {
	null !== this.anchorParams.innerAnchorFunctor && this.anchorParams.innerAnchorFunctor.destroy();
	this.extractor.radius = this.anchorParams.innerRadius + this.anchorParams.thickness;
	this.extractor.yOffset = this.anchorParams.yCenterPos;
	for (var a = 0; a < 2 * (this.anchorParams.resolution + 1); a++) {
		var b = a * Math.PI / (2 * (this.anchorParams.resolution + 1)),
		b = this.extractor.get2DFromAngle(b, 1),
		b = this.extractor.get3DFrom2D(b, 0),
		c = this.anchorParams.vertices[a];
		c.setVertexAndPropagate(b.x,
			b.y, b.z, this.anchorParams.thickness, c.getMaterial(), c.getVolType())
	}
	for (a = 2 * (this.anchorParams.resolution + 1); a < 4 * (this.anchorParams.resolution + 1); a++)
		b = a * Math.PI / (2 * (this.anchorParams.resolution + 1)), b = this.extractor.get2DFromAngle(b, this.getTearFactor()), b = this.extractor.get3DFrom2D(b, 0), c = this.anchorParams.vertices[a], c.setVertexAndPropagate(b.x, b.y, b.z, this.anchorParams.thickness, c.getMaterial(), c.getVolType());
	this.anchorParams.isPresent = !0;
	this.createInnerAnchorFunctor();
	this.updateChain();
	this.cylinderVisu.setSystemAllows(!0);
	this.cylinderVisu.update(this.anchorParams)
};
site.StylePendantTool.prototype.getTearFactor = function () {
	return Math.max(1, (40 - this.extractor.radius + 2 * this.anchorParams.thickness) / this.extractor.radius)
};
site.StylePendantTool.prototype.flattenAll = function () {
	skim.engine.processVertices(function (a) {
		a.setVertexAndPropagate(a.getPos().x, a.getPos().y, 0, a.getThickness(), a.getMaterial(), a.getVolType())
	});
	this.updateAnchor()
};
site.StylePendantTool.prototype.updateAnchorDiameter = function (a) {
	a *= 50;
	this.anchorParams.yCenterPos += this.anchorParams.innerRadius - a;
	this.anchorParams.innerRadius = a;
	this.anchorParams.isPresent && (this.updateAnchor(), this.hideSurface(), skim.engine.update_skeleton(), skim.engine.update_parametrics(), skim.engine.update_blobtree())
};
site.StylePendantTool.prototype.isPartOfAnchor = function (a) {
	if (this.anchorParams.isPresent) {
		for (var b = 0, c = !1; b < this.anchorParams.vertices.length && !c; b++) {
			var d = {};
			skim.engine.getVertexById(this.anchorParams.vertices[b].id).getSyms({}, d);
			for (var e = Object.keys(d), f = 0; f < e.length; f++)
				a === d[e[f]].id && (c = !0)
		}
		return c
	}
};
site.StylePendantTool.prototype.createInnerAnchorFunctor = function () {
	this.anchorParams.innerAnchorFunctor = new skim.engine.adjustAttrFunctors.InnerAnchorLimit(this.anchorParams);
	for (var a = Object.keys(skim.engine.vars.vertices), b = 0; b < a.length; ++b) {
		var c = skim.engine.vars.vertices[a[b]];
		if (!this.isPartOfAnchor(c.id)) {
			var d = c.getPos().clone();
			this.anchorParams.innerAnchorFunctor.adjustAttr(d, {
				t : c.getThickness()
			}, c);
			c.setVertexAndPropagate(d.x, d.y, d.z, c.getThickness(), c.getMaterial(), c.getVolType());
			c.insertAdjustAttrFunctor(this.anchorParams.innerAnchorFunctor)
		}
	}
	skim.engine.adjust_functors.anchorRadialLimit =
		this.anchorParams.innerAnchorFunctor
};
site.StylePendantTool.prototype.loadAnchor = function () {
	for (var a = Object.keys(skim.engine.vars.vertices), b = [], c = 0; c < a.length; c++) {
		var d = skim.engine.vars.vertices[a[c]];
		"anchor" === (null !== d.getName() ? d.getName().slice(0, 6) : "") && b.push(d)
	}
	if (0 < b.length) {
		a = {
			resolution : 3,
			innerRadius : 20,
			thickness : 5,
			yCenterPos : 70,
			vertices : [],
			XPlane : !0
		};
		a.resolution = b.length / 4 - 1;
		for (var e = d = c = 0, f = 0; c < b.length; c++) {
			var g = b[c].getPos();
			a.vertices.push(b[c]);
			b[c].setName("anchor" + c);
			d += g.x;
			e += g.z;
			f += b[c].getThickness()
		}
		0 === d ?
		a.XPlane = !0 : 0 === e ? a.XPlane = !1 : console.error("StylePendantTool - anchor seems to be twisted");
		skim.utils.isApproxEqual(f / b.length, b[0].getThickness(), skim.engine.functorPrecision) || console.error("StylePendantTool - anchor thickness seems to be wrong");
		a.thickness = b[0].getThickness();
		c = b[0].getPos();
		a.innerRadius = (a.XPlane ? c.z : c.x) - a.thickness;
		a.yCenterPos = b[b.length / 4].getPos().y - a.innerRadius - a.thickness;
		this.extractor = new site.Geometry.RadialCoordExtractor(a.innerRadius + a.thickness, a.yCenterPos,
				a.XPlane);
		$.extend(this.anchorParams, a);
		this.setAnchorThickness(a.thickness);
		this.updateAnchor();
		this.anchorParams.isPresent = !0;
		this.createInnerAnchorFunctor();
		this.updateChain();
		this.cylinderVisu.update(this.anchorParams)
	} else
		$.extend(this.anchorParams, this.defaultParams.anchorParams), this.anchorParams.isPresent = !1;
	this.cylinderVisu.update(this.anchorParams)
};
site.StylePendantTool.prototype.setAnchorThickness = function (a) {
	this.anchorParams.thickness = Math.max(a, this.anchorParams.minThicknessLimit)
};
site.StylePendantTool.prototype.specializeTransformer = function () {
	site.PendantTool.prototype.specializeTransformer.call(this);
	var a = this;
	Transformer.pendant.addAnchor = function () {
		skim.instances.modeler.sceneManager.setShowSurface(!1);
		a.delAnchor();
		var b = a.anchorParams.innerRadius;
		$.extend(a.anchorParams, a.defaultParams.anchorParams);
		a.anchorParams.innerRadius = b;
		a.addAnchor()
	};
	Transformer.Replacer = {};
	Transformer.Replacer.allVerticesPos = {};
	Transformer.Replacer.replaceVertices = function () {
		for (var a = Object.keys(Transformer.Replacer.allVerticesPos),
			c = 0; c < a.length; c++) {
			var d = Transformer.Replacer.allVerticesPos[a[c]],
			e = d.orig_pos.clone();
			d.v.setVertexAndPropagate(e.x, e.y, e.z, d.t, d.v.getMaterial(), d.v.getVolType())
		}
	};
	Transformer.Replacer.saveVerticesPos = function () {
		Transformer.Replacer.allVerticesPos = {};
		for (var b = skim.engine.vars.vertices, c = Object.keys(skim.engine.vars.vertices), d = 0; d < c.length; d++) {
			var e = b[c[d]];
			a.isPartOfAnchor(e.id) || (Transformer.Replacer.allVerticesPos[e.id] = {
					orig_pos : e.getPos().clone(),
					v : e,
					t : e.getThickness()
				})
		}
	};
	Transformer.vertex.translate.init =
	function () {
		$("body").addClass("noselect");
		this.prevCanvasX = this.canvasX;
		this.prevCanvasY = this.canvasY;
		"vertices_widget" == this.w3dHit.w.get("name") ? this.v = this.w3dHit.v : "primitives_widget" == this.w3dHit.w.get("name") && (this.p = null, skim.utils.assert(!1, "Should not happen, we do not manage primitives !"));
		var b = this.w3dHit.point;
		this.hitZ = (new THREE.Vector3(b.x, b.y, b.z)).project(skim.instances.modeler.cameraMan.camera).z;
		this.prev_hit = new THREE.Vector3(b.x, b.y, b.z);
		this.v_origin = this.v.getPos().clone();
		this.runned = 0;
		a.isPartOfAnchor(this.v.id) && Transformer.Replacer.saveVerticesPos()
	};
	Transformer.vertex.translate.run = function () {
		var b = new THREE.Vector3(0, 0, this.hitZ);
		b.x = 2 * (this.canvasX / skim.instances.modeler.canvas.width) - 1;
		b.y = 2 *  - (this.canvasY / skim.instances.modeler.canvas.height) + 1;
		b.unproject(skim.instances.modeler.cameraMan.camera);
		var b = b.clone(),
		c = new THREE.Vector3;
		c.subVectors(b, this.prev_hit);
		if (void 0 !== this.v) {
			var b = new THREE.Vector3(this.v_origin.x + c.x, this.v_origin.y + c.y, this.v_origin.z +
					c.z),
			c = {
				t : this.v.get("thickness")
			},
			d = skim.engine.getVertexById(this.v.id);
			Transformer.prim.translate.magnetOnAxis(this, d, b, c);
			a.isPartOfAnchor(d.id) ? (b = b.y - d.getPos().y, a.anchorParams.yCenterPos += b, a.updateAnchor(), Transformer.Replacer.replaceVertices()) : d.setVertexAndPropagate(b.x, b.y, b.z, c.t, d.getMaterial(), d.getVolType());
			skim.engine.update_skeleton();
			this.runned++;
			this.prevCanvasX = this.canvasX;
			this.prevCanvasY = this.canvasY
		}
	};
	Transformer.vertex.translate.finalize = function () {
		skim.engine.update_parametrics();
		skim.engine.update_blobtree();
		$("body").removeClass("noselect");
		1 < this.runned && skim.file.saveState()
	};
	Transformer.vertex.del = function () {
		var b = this.hit;
		null !== b && (b = skim.engine.getVertexById(b.id), a.isPartOfAnchor(b.id) || b.destroy(), skim.file.saveState(), skim.engine.update_skeleton(), skim.engine.update_parametrics(), skim.engine.update_blobtree())
	};
	Transformer.vertex.thick.decrease = function () {
		Transformer.vertex.thick.scale(this.hit, 0.9)
	};
	Transformer.vertex.thick.increase = function () {
		Transformer.vertex.thick.scale(this.hit,
			1.1)
	};
	Transformer.vertex.thick.scale = function (b, c) {
		if (null !== b) {
			var d = skim.engine.getVertexById(b.id),
			e = d.getPos(),
			f = Math.min(a.thickLimitMax, Math.max(a.thickLimitMin, c * b.get("thickness")));
			a.isPartOfAnchor(d.id) ? (a.setAnchorThickness(f), a.updateAnchor()) : d.setVertexAndPropagate(e.x, e.y, e.z, f, d.getMaterial(), d.getVolType())
		}
		skim.engine.update_skeleton();
		skim.engine.update_parametrics();
		skim.engine.update_blobtree();
		skim.file.saveState()
	};
	Transformer.prim.translate.init = function () {
		$("body").addClass("noselect");
		this.prevCanvasX = this.canvasX;
		this.prevCanvasY = this.canvasY;
		this.p = this.w3dHit.p;
		var b = this.w3dHit.point;
		this.hitZ = (new THREE.Vector3(b.x, b.y, b.z)).project(skim.instances.modeler.cameraMan.camera).z;
		this.prev_hit = new THREE.Vector3(b.x, b.y, b.z);
		this.v_origins = {};
		for (var b = 0, c = !1; b < this.p.v.length; ++b) {
			var d = this.p.v[b],
			c = c || a.isPartOfAnchor(d.id);
			this.v_origins[d.id] = {
				pos : d.getPos().clone(),
				thick : d.getThickness()
			}
		}
		this.runned = !1;
		c && Transformer.Replacer.saveVerticesPos()
	};
	Transformer.prim.translate.run =
	function () {
		var b = new THREE.Vector3(0, 0, this.hitZ);
		b.x = 2 * (this.canvasX / skim.instances.modeler.canvas.width) - 1;
		b.y = 2 *  - (this.canvasY / skim.instances.modeler.canvas.height) + 1;
		b.unproject(skim.instances.modeler.cameraMan.camera);
		var c = b.clone(),
		b = new THREE.Vector3;
		b.subVectors(c, this.prev_hit);
		Transformer.prim.translate.adjustPrimTranslation(this, b);
		for (var c = {}, d = 0; d < this.p.v.length; ++d)
			c[this.p.v[d].id] = this.p.v[d];
		c = skim.engine.getSymConstrainsForGroup(c);
		c.x && (b.x = 0);
		c.y && (b.y = 0);
		c.z && (b.z = 0);
		if (void 0 !==
			this.p) {
			skim.engine.getPrimitiveById(this.p.id);
			for (var c = Object.keys(this.v_origins), d = 0, e = !1; d < c.length && !e; d++) {
				var f = skim.engine.getVertexById(c[d]),
				g = new THREE.Vector3(this.v_origins[c[d]].pos.x + b.x, this.v_origins[c[d]].pos.y + b.y, this.v_origins[c[d]].pos.z + b.z),
				h = {
					t : this.v_origins[c[d]].thick
				};
				Transformer.prim.translate.magnetOnAxis(this, f, g, h);
				a.isPartOfAnchor(f.id) ? (e = this.v_origins[c[d]].pos.y + b.y - f.getPos().y, a.anchorParams.yCenterPos += e, a.updateAnchor(), Transformer.Replacer.replaceVertices(),
					e = !0) : f.setVertexAndPropagate(g.x, g.y, g.z, h.t, f.getMaterial(), f.getVolType())
			}
		}
		skim.engine.update_skeleton();
		this.runned = !0;
		this.prevCanvasX = this.canvasX;
		this.prevCanvasY = this.canvasY
	};
	Transformer.segment.split = function () {
		var b = this.w3dHit.point,
		c = this.w3dHit.p,
		d = c.v[0],
		e = c.v[1];
		a.isPartOfAnchor(d.id) && a.isPartOfAnchor(e.id) || (b = (new THREE.Vector3).subVectors(b, d.get("pos")).dot(c.unit_dir) / c.length, c = skim.engine.getPrimitiveById(c.id), skim.engine.splitSegment(c, b), skim.file.saveState(), skim.engine.update_skeleton(),
			skim.engine.update_parametrics(), skim.engine.update_blobtree(), skim.instances.modeler.statemachine.activate_over(), skim.instances.modeler.statemachine.activate_over(), Transformer.vertex.unhighlight())
	};
	Transformer.segment.del = function () {
		var b = this.w3dHit.p;
		skim.utils.assert(null !== b && void 0 !== b && skim.engine.getPrimitiveById(b.id)instanceof skim.engine.SegmentDef, "Error : calling segment.del on a non segment primitive");
		var c = skim.engine.getPrimitiveById(b.id),
		b = [c.v[0], c.v[1]];
		if (!a.isPartOfAnchor(c.v[0].id) ||
			!a.isPartOfAnchor(c.v[1].id)) {
			c.destroy();
			for (c = 0; c < b.length; ++c)
				b[c].hasOwners() || a.isPartOfAnchor(b[c].id) || b[c].destroy();
			skim.file.saveState();
			skim.engine.update_skeleton();
			skim.engine.update_parametrics();
			skim.engine.update_blobtree()
		}
	};
	Transformer.hierarchy.select_anchor = function () {
		Transformer.hierarchy.anchor = this.w3dHit.v;
		Transformer.hierarchy.anchorSyms = {};
		skim.engine.getVArrSym(this.hit, Transformer.hierarchy.anchorSyms);
		Transformer.hierarchy.groups.length = 0;
		var b = Transformer.hierarchy.anchor.vAdj,
		c = Object.keys(b),
		d = c.length,
		e = Transformer.hierarchy.groups;
		e.length = 0;
		for (var f = Transformer.hierarchy.sym_constrained_groups.length = 0; f < d; ++f) {
			var g = c[f],
			h = b[g].v;
			if (!skim.engine.hasOwnersRings(h) && !a.isPartOfAnchor(h.id)) {
				for (var l = !1, k = 0; k < e.length; ++k)
					void 0 !== e[k][h.id] && (l = !0);
				l || (h = {}, Transformer.hierarchy.add_to_group(b[g].v, Transformer.hierarchy.anchor, h), e.push(h), Transformer.hierarchy.sym_constrained_groups[e.length - 1] = skim.engine.getSymConstrainsForGroup(h))
			}
		}
	};
	Transformer.hierarchy.add_to_group =
	function (b, c, d) {
		skim.utils.assert(c === Transformer.hierarchy.anchor || void 0 !== d[c.id], "v should be in g");
		if (void 0 === d[b.id] && !skim.engine.hasOwnersRings(b) && !a.isPartOfAnchor(b.id)) {
			for (var e = Object.keys(Transformer.hierarchy.anchorSyms), f = 0; f < e.length; f++)
				if (b.id === Transformer.hierarchy.anchorSyms[e[f]].id)
					return;
			d[b.id] = b;
			e = Object.keys(b.vAdj);
			for (f = 0; f < e.length; ++f) {
				var g = e[f];
				g != c.id && g != Transformer.hierarchy.anchor.id && Transformer.hierarchy.add_to_group(b.vAdj[g].v, b, d)
			}
		}
	};
	Transformer.vertex.merge =
	function () {
		var b = Object.keys(Transformer.selection.vertices);
		skim.utils.assert(1 === b.length, "Error : can only merge if one and only one vertex is selected");
		var b = Transformer.selection.vertices[b[0]],
		c = this.w3dHit.v;
		b == c || (a.isPartOfAnchor(c.id) || a.isPartOfAnchor(b.id)) || skim.engine.hasOwnersRings(b) || (Transformer.selection.unsetAllVertices.call(this), skim.engine.merge_vertex(b, c), skim.engine.update_skeleton(), skim.engine.update_parametrics(), skim.engine.update_blobtree(), skim.file.saveState(), Transformer.selection.setVertexUnderMouse.call(this));
		Transformer.creation.updateGrid()
	};
	Transformer.step = {
		prev : function () {
			var b = skim.file;
			b.state_index > b.firstStateIndex + 1 && (b.state_index--, a.setjsonInfo(b.states[b.state_index - 1]), skim.instances.modeler.sceneManager.setShowSurface(!1), a.loadObject())
		},
		next : function () {
			var b = skim.file;
			b.state_index < b.states.length && (a.setjsonInfo(b.states[b.state_index++]), skim.instances.modeler.sceneManager.setShowSurface(!1), a.loadObject())
		}
	};
	Transformer.creation.x_symmetry_activate_toggle = function () {
		a.toolInfo.symX =
			!skim.engine.symmetry.x;
		skim.engine.setSymmetries({
			x : !skim.engine.symmetry.x
		})
	};
	Transformer.creation.y_symmetry_activate_toggle = function () {
		a.toolInfo.symY = !skim.engine.symmetry.y;
		skim.engine.setSymmetries({
			y : !skim.engine.symmetry.y
		})
	};
	Transformer.creation.z_symmetry_activate_toggle = function () {
		a.toolInfo.symZ = !skim.engine.symmetry.z;
		skim.engine.setSymmetries({
			z : !skim.engine.symmetry.z
		})
	};
	void 0 === Transformer.vertex.infos && (Transformer.vertex.infos = {});
	Transformer.vertex.infos.displayInfos = function () {
		document.getElementById("infos-line").style.display =
			"block"
	};
	Transformer.vertex.infos.updateInfos = function () {
		document.getElementById("infos-line").innerHTML = "Ã¸ " + (Math.round(20 * this.hit.getThickness()) / 100).toString() + " mm"
	};
	Transformer.vertex.infos.removeInfos = function () {
		document.getElementById("infos-line").style.display = "none"
	};
	Transformer.vertex.styleWrap = {};
	Transformer.vertex.styleWrap.thickIncrease = function () {
		Transformer.vertex.thick.increase.call(this);
		Transformer.vertex.infos.updateInfos.call(this)
	};
	Transformer.vertex.styleWrap.thickDecrease =
	function () {
		Transformer.vertex.thick.decrease.call(this);
		Transformer.vertex.infos.updateInfos.call(this)
	};
	Transformer.vertex.styleWrap.highlight = function () {
		Transformer.vertex.highlight.call(this);
		Transformer.vertex.infos.updateInfos.call(this)
	}
};
site.StylePendantTool.prototype.specializeFunctors = function () {
	skim.engine.adjustAttrFunctors.InnerAnchorLimit = function (a) {
		skim.engine.adjustAttrFunctors.Global.call(this);
		this.zLimit = a.zLimit;
		this.innerRadius = a.innerRadius;
		this.extractor = new site.Geometry.RadialCoordExtractor(a.innerRadius, a.yCenterPos, a.XPlane)
	};
	skim.engine.adjustAttrFunctors.InnerAnchorLimit.prototype = Object.create(skim.engine.adjustAttrFunctors.Global.prototype);
	skim.engine.adjustAttrFunctors.InnerAnchorLimit.prototype.constructor =
		skim.engine.adjustAttrFunctors.InnerAnchorLimit;
	skim.engine.adjustAttrFunctors.InnerAnchorLimit.prototype.adjustAttr = function (a, b, c) {
		c = this.extractor.get2DFrom3D(a);
		var d = Math.sqrt(c.x * c.x + c.y * c.y),
		e = this.innerRadius + b.t,
		f = this.extractor.getZFrom3D(a);
		if (f * f < (b.t + this.zLimit) * (b.t + this.zLimit) && d <= e && Math.abs(d - e) > skim.engine.functorPrecision) {
			e += skim.engine.functorPrecision;
			b = (0 > f ? -1 : 1) * (b.t + this.zLimit + skim.engine.functorPrecision);
			var g = null;
			(b - f) * (b - f) < (d - this.innerRadius) * (d - this.innerRadius) ?
			g = this.extractor.get3DFrom2D(c, b) : (d = this.extractor.getAngleFrom2D(c), c.x = e * Math.cos(d), c.x = skim.utils.isApproxEqual(c.x, 0, skim.engine.functorPrecision) ? 0 : c.x, c.y = e * Math.sin(d), c.y = skim.utils.isApproxEqual(c.y, 0, skim.engine.functorPrecision) ? 0 : c.y, g = this.extractor.get3DFrom2D(c, f));
			a.set(g.x, g.y, g.z)
		}
	};
	skim.engine.adjustAttrFunctors.InnerAnchorLimit.prototype.checkAttr = function (a, b, c) {
		c = this.extractor.get2DFrom3D(a);
		c = Math.sqrt(c.x * c.x + c.y * c.y);
		var d = this.innerRadius + b.t;
		a = this.extractor.getZFrom3D(a);
		return !(a * a < (b.t + this.zLimit) * (b.t + this.zLimit) && c <= d && Math.abs(Math.sqrt(c) - d) > skim.engine.functorPrecision)
	};
	skim.engine.adjustAttrFunctors.InnerAnchorLimit.prototype.destroy = function () {
		for (var a = Object.keys(skim.engine.vars.vertices), b = 0; b < a.length; ++b)
			skim.engine.vars.vertices[a[b]].removeAdjustAttrFunctor(this);
		a = Object.keys(skim.engine.adjust_functors);
		for (b = 0; b < a.length; ++b)
			skim.engine.adjust_functors[a[b]]instanceof skim.engine.adjustAttrFunctors.InnerAnchorLimit && delete skim.engine.adjust_functors[a[b]]
	};
	skim.engine.adjustAttrFunctors.InnerAnchorLimit.prototype.setActive = function (a) {
		this.active = a
	};
	skim.engine.adjustAttrFunctors.InnerAnchorLimit.prototype.isActive = function () {
		return this.active
	}
};
site.TextpendantTool = function (a, b, c, d) {
	site.PendantTool.call(this, a, b, c);
	this.toolType = toolNames.textpendant;
	this.symbolsFont = "Symbols";
	this.defaultParams.toolInfo = {
		size : 1,
		width : 397,
		height : 197,
		depth : 20,
		thickness : 3,
		svg : '<svg width="397" height="197" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <title>Layer 1</title> <g>  <title>Layer 1</title>  <text xml:space="preserve" text-anchor="middle" font-family="Norican, Symbols" font-size="170" id="svg_6" y="157.10811" x="177.72072" stroke-width="null" fill="black">Jweel</text>  <ellipse cx="69.10811" cy="27.40089" rx="17.5" ry="17.5" stroke-width="9px" fill="#FFFFFF" class="jweelSVGEditorAnchors" stroke="#000000" id="svg_2"/>  <ellipse cx="370.2973" cy="27.4009" rx="17.5" ry="17.5" stroke-width="9px" id="svg_3" fill="#FFFFFF" class="jweelSVGEditorAnchors" stroke="#000000"/> </g></svg>'
	};
	this.toolInfo = this.defaultParams.toolInfo;
	this.genMethod = "LQ";
	this.defaultParams.init.initCamPos = {
		rotNode : {
			px : 0,
			py : 0,
			pz : 0,
			rx : 0.03,
			ry : -0.5,
			rz : -0.04
		},
		distToTarget : 700
	};
	this.initParams.trackballHelper = !1;
	this.jweelSVGEditor = this.canvasTextCreator = null;
	this.uiParams = d
};
site.TextpendantTool.prototype = Object.create(site.PendantTool.prototype);
site.TextpendantTool.prototype.constructor = site.TextpendantTool;
site.TextpendantTool.prototype.loadFiles = function () {
	this.filesToLoad.push("/static/js/fontdetect/fontdetect.2.2.min.js");
	this.filesToLoad.push("/static/js/canvg-1.3/canvg.js");
	this.filesToLoad.push("/static/js/canvg-1.3/rgbcolor.js");
	this.filesToLoad.push("/static/js/canvg-1.3/StackBlur.js");
	this.filesToLoad.push("/static/js/snap/snap.svg-min.js");
	site.PendantTool.prototype.loadFiles.call(this)
};
site.TextpendantTool.prototype.setDepth = function (a) {
	this.toolInfo.depth = a
};
site.TextpendantTool.prototype.getThickness = function () {
	return this.toolInfo.thickness
};
site.TextpendantTool.prototype.setThickness = function (a) {
	this.toolInfo.thickness = a;
	this.jweelSVGEditor.setThickness(a)
};
site.TextpendantTool.prototype.getAllFonts = function (a) {
	var b = {};
	$("<div/>").html(a).find("*").each(function () {
		var a = $(this).attr("font-family");
		a || (a = $(this).css("font-family"));
		a && (a = a.split(",")[0].trim());
		a && (a = a.trim(), b[a] = a)
	});
	return b
};
site.TextpendantTool.prototype.applyFontDetect = function (a, b) {
	var c = Object.keys(a);
	if (0 < c.length) {
		var d = this;
		console.log("loading font: " + c[0]);
		fontdetect.onFontLoaded(c[0], function () {
			console.log("loaded font: " + c[0]);
			delete a[c[0]];
			d.applyFontDetect(a, b)
		}, function () {
			console.warn("applyFontDetect - failed to get " + c[0] + " font.");
			delete a[c[0]];
			d.applyFontDetect(a, b)
		}, {
			msTimeout : 3E3
		})
	} else
		b()
};
site.TextpendantTool.prototype.detectFontsAndLaunch = function (a) {
	var b = this.getAllFonts(this.toolInfo.svg),
	c = this;
	c.applyFontDetect(b, function () {
		console.log("loading font: Symbols");
		fontdetect.onFontLoaded("Symbols", function () {
			console.log("loaded font: Symbols");
			a()
		}, function () {
			console.error("CanvasTextTool - failed to get " + c.symbolsFont + " font.");
			a()
		}, {
			msTimeout : 3E3,
			testString : "ഀഁംഃഄഅആഇഈഉഊഋഌ഍എഏഐ഑ഒഓഔകഖഗഘങചഛജഝഞടഠഡഢണതഥദധനഩപഫബഭമയരറലΆ·ΈΉΉΊ΋"
		})
	})
};
site.TextpendantTool.prototype.loadEditor = function () {
	console.log("loading object into editor");
	skim.engine.setSymmetries({
		x : !1,
		y : !1,
		z : !1
	});
	skim.engine.loadJSON(this.defaultParams.jsonInfo);
	this.canvasTextCreator.setParams({
		width : this.toolInfo.width,
		height : this.toolInfo.height,
		depth : this.toolInfo.depth,
		thickness : this.toolInfo.thickness
	});
	skim.instances.modeler.sceneManager.showWidgets(!1);
	this.pageInterface.updateToolMenu(this.toolInfo)
};
site.TextpendantTool.prototype.startingLoad = function () {
	if (this.mode === site.toolModes.edit) {
		var a = this;
		this.detectFontsAndLaunch(function () {
			console.log("all font detected !");
			a.loadEditor();
			setTimeout(function () {
				a.jweelSVGEditor.setSVG(a.jweelSVGEditor.toolInfo.svg)
			}, 500)
		})
	} else
		this.loadObject()
};
site.TextpendantTool.prototype.loadObject = function () {
	var a = this;
	this.detectFontsAndLaunch(function () {
		console.log("all font detected !");
		a.loadEditor();
		var b = a.canvasTextCreator.getDimensions(),
		c = a.parseVerticalAnchorsFromSVG();
		a.canvasTextCreator.create(site.SVGUtils.SVGToCanvas(c, b))
	})
};
site.TextpendantTool.prototype.addZYCircle = function (a) {
	for (var b = [], c = 0; c < a.numberOfVertices; c++) {
		var d = 2 * c * Math.PI / a.numberOfVertices,
		e = a.radius * Math.cos(d),
		d = a.radius * Math.sin(d),
		e = skim.engine.addVertex(a.cx, d + a.cy, e, a.thickness, a.material, a.volType);
		b.push(e)
	}
	c = 0;
	for (e = b.length - 1; c < b.length; c++, e = c - 1)
		(new skim.engine.SegmentDef([b[c], b[e]], [a.material], a.volType)).commit()
};
site.TextpendantTool.prototype.parseVerticalAnchorsFromSVG = function () {
	var a = Snap(this.toolInfo.width, this.toolInfo.height),
	b = Snap.parse(this.toolInfo.svg);
	a.append(b);
	for (var b = a.selectAll(".jweelSVGEditorAnchors.jweelSVGEditorVerticalAnchors").items, c = 0; c < b.length; c++) {
		var d = parseFloat(b[c].attr("x")),
		e = parseFloat(b[c].attr("y")),
		f = parseFloat(b[c].attr("width")),
		g = parseFloat(b[c].attr("height"));
		this.addZYCircle({
			cx : d - this.toolInfo.width / 2 + f / 2,
			cy :  - (e + g / 2) + this.toolInfo.height / 2,
			radius : (g - f) / 2,
			thickness : (f +
				2 * this.toolInfo.thickness) / 2,
			numberOfVertices : 100,
			material : Transformer.creation.mode.v_material,
			volType : Transformer.creation.mode.voltype
		});
		b[c].remove()
	}
	return a.outerSVG()
};
site.TextpendantTool.prototype.utilsInit = function () {
	site.PendantTool.prototype.utilsInit.call(this);
	this.progress = new site.JweelProgress2D(this.canvas);
	this.computeWarning = new site.JweelComputationWarning(this);
	"LQ" === this.genMethod ? this.setFastGeneration() : this.setNiceGeneration();
	this.canvasTextCreator = new skim.textUtils.CanvasTextCreator;
	console.log("MODE: " + this.mode);
	if (this.mode === site.toolModes.edit) {
		var a = this;
		this.jweelSVGEditor = new site.JweelSVGEditWrapper({
				ui : this.uiParams,
				callbacks : {
					onClose : function () {
						a.setToolInfo(a.jweelSVGEditor.getToolInfo());
						a.pageInterface.updateToolMenu(a.toolInfo)
					},
					onOpen : function () {
						a.jweelSVGEditor.setToolInfo(a.toolInfo)
					},
					cleanObject : function () {
						a.stopLoadObject()
					},
					loadObject : function () {
						a.loadObject()
					}
				}
			});
		this.jweelSVGEditor.setToolInfo(this.toolInfo);
		console.warn("loading toolinfo!")
	}
};
site.TextpendantTool.prototype.stopLoadObject = function () {
	this.canvasTextCreator.clean();
	skim.engine.update_skeleton();
	skim.engine.update_parametrics();
	skim.engine.update_blobtree()
};
site.TextpendantTool.prototype.setGenMethod = function (a) {
	this.genMethod = a
};
site.TextpendantTool.prototype.setNiceGeneration = function () {
	skim.instances.modeler.setAccuracyLevel(4);
	skim.textUtils.canvasCompression = 1
};
site.TextpendantTool.prototype.setFastGeneration = function () {
	skim.instances.modeler.setAccuracyLevel(2);
	skim.textUtils.canvasCompression = 2
};
site.TextpendantTool.prototype.loadChain = function () {};
site.TextpendantTool.prototype.updateChain = function () {};
site.TextpendantTool.prototype.setChainParams = function (a) {};
site.TextpendantTool.prototype.showChain = function () {};
site.TextpendantTool.prototype.hideChain = function () {};
